  \chapter{Data Manipulation Language (DML)}
    \setcounter{page}{1}\kapitelnummer{chapter}
    \minitoc
\newpage
      In den vergangenen Kapiteln wurde bisher nur der Teil von SQL beschrieben,
      der als sog. \enquote{Query language} bezeichnet wird. Hier wird jetzt
      gezeigt, wie vorhandene Daten manipuliert werden k\"onnen. Der daf\"ur
      zust\"andige Teil von SQL hei\ss{}t: \enquote{Data Manipulation Language}
      oder kurz \enquote{DML}.

      Gem\"a\ss\ SQL-Standard besteht DML aus drei Befehlen:
      \begin{itemize}
        \item \INSERT: Daten einf\"ugen.
        \item \UPDATE: Daten \"andern.
        \item \DELETE: Daten l\"oschen.
      \end{itemize}
    \section{Die DML-Anweisungen}
      \subsection{Datens\"atze einf\"ugen - Die INSERT-Anweisung}
        Mit Hilfe der \INSERT-Anweisung werden neue Datens\"atze an eine Tabelle
        angef\"ugt. Die Syntax f\"ur ein einfaches \INSERT lautet:
        \begin{lstlisting}[language=oracle_sql,caption={Die INSERT Anweisungen},label=sql07_01]
INSERT INTO <Tabelle> (<Spalte 1>, <Spalte 2>, ..., <Spalte n>)
VALUES (<Wert 1>, <Wert 2>, ..., <Wert n>);
        \end{lstlisting}
        \begin{center}
          \tablecaption{Die INSERT-Anweisung}
          \label{insertsyntax}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail{
              \hline
            }
            \begin{supertabular}{|l|p{10.8cm}|}
              INSERT INTO <Tabelle> & An dieser Stelle steht der Name der
              Tabelle oder View, in die der Datensatz eingef\"ugt werden soll.
              \\
              \hline
              <Spalte 1>, <Spalte 2>, ... & Dies ist die Spaltenliste. Hier
              k\"onnen alle Spalten angegeben werden, in die Daten eingef\"ugt
              werden. Die Spaltenliste ist optional. \\
              \hline
              VALUES <Wert 1>, ... & Dies ist die Werteliste. Hier werden alle
              Werte aufgef\"uhrt, die in <Tabelle> eingef\"ugt werden sollen.
              Statt einem festen Wert, kann an jeder Stelle auch ein Ausdruck
              stehen, der einen Wert erzeugt (z. B. eine Funktion). \\
            \end{supertabular}
          \end{small}
        \end{center}
        \beispiel{sql07_02} demonstriert die einfachste Form eines
        \INSERT-Statements: Es wird eine neue Zeile in die Tabelle
        \identifier{Bankfiliale} eingef\"ugt.
        \begin{lstlisting}[language=oracle_sql,caption={Ein einfaches INSERT},label=sql07_02]
INSERT INTO Bankfiliale (Bankfiliale_ID, Strasse, Hausnummer, PLZ, Ort)
VALUES (22, 'Rosenweg', '14a', '06425', 'Ploetzkau');
        \end{lstlisting}
\clearpage
        In obigem Beispiel wird der Wert \enquote{22} in die Spalte
        \identifier{Bankfiliale\_ID}, der Wert \enquote{Rosenweg} in die Spalte
        \identifier{Strasse} eingef\"ugt. Die restlichen drei Werte werden in
        die Spalten \identifier{Hausnummer}, \identifier{PLZ} und
        \identifier{Ort} geschrieben.
        Die Spaltenliste der \INSERT-Anweisung muss die einzelnen Spalten keineswegs in der Reihenfolge enthalten, wie sie in der Tabelle enthalten sind.
        \begin{lstlisting}[language=oracle_sql,caption={Ein einfaches INSERT},label=sql07_03]
INSERT INTO Bankfiliale (Strasse, Hausnummer, PLZ, Ort, Bankfiliale_ID)
VALUES ('Rosenweg', '14a', '06425', 'Ploetzkau', 22);
        \end{lstlisting}
        \begin{merke}
          In der Spaltenliste m\"ussen die Spalten nicht in der Reihenfolge
          aufgef\"uhrt werden, wie sie in der Tabelle vorkommen. Die Reihenfolge
          in der Spaltenliste ist beliebig!
        \end{merke}
        \vspace{1em}
        Wie in \tabelle{insertsyntax} bereits beschrieben, ist die Spaltenliste
        hinter den \languageorasql{INSERT INTO}-Schl\"ussel\-w\"ortern optional.
        Daraus folgt, dass sich \beispiel{sql07_02} auch so schreiben l\"asst:
        \begin{lstlisting}[language=oracle_sql,caption={Ein einfaches INSERT ohne Spaltenliste},label=sql07_04]
INSERT INTO Bankfiliale
VALUES (22, 'Rosenweg', '14a', '06425', 'Ploetzkau');
        \end{lstlisting}
        Das \INSERT-Statement in \beispiel{sql07_04} wird vom DBMS so
        interpretiert, dass der erste Wert in die erste Spalte, der zweite Wert
        in die zweite Spalte, der dritte Wert in die dritte Spalte, usw.
        eingef\"ugt wird.
        \subsubsection{Die INSERT-Anweisung und NULL-Werte}
          Soll mit einer \INSERT-Anweisung ein NULL-Wert in eine Tabellenspalte
          eingef\"ugt werden, geschieht dies mit Hilfe des Schl\"usselwortes
          \languageorasql{NULL}. In \beispiel{sql07_05} wird eine neue Zeile in
          die Tabelle \identifier{Bank} eingef\"ugt. W\"ahrend des
          Einf\"ugevorgangs ist der Wert f\"ur die Spalte \identifier{Rating}
          noch nicht bekannt. Die Zeile soll nun ohne diesen Wert eingef\"ugt
          werden.
        \begin{lstlisting}[language=oracle_sql,caption={Ein einfaches \INSERT{} mit \languageorasql{NULL}-Werten},label=sql07_05]
INSERT INTO Bank
VALUES (21, 'KRDCU21SES', 'Lokki Bank of Cyprus', 'Steuerparadies', '42',
        '01067', 'Berlin', NULL);
        \end{lstlisting}
        \begin{merke}
          Mit Hilfe des Schl\"usselwortes \languageorasql{NULL} kann ein
          \languageorasql{NULL}-Wert in eine Tabellenspalte eingef\"ugt werden.
        \end{merke}
        \subsubsection{Standardwerte}
          \label{defaultvalues}
          Standardwerte werden meist dann genutzt, wenn in eine Spalte h\"aufig
          der gleiche Wert eingef\"ugt werden muss. Sie m\"ussen bei der
          Erstellung einer Tabelle mit definiert werden. Ein Beispiel hierf\"ur
          k\"onnte die Spalte \identifier{Buchungsdatum} der Tabelle
          \identifier{Buchung} sein. Wird eine neue Buchung erfasst, muss immer
          das aktuelle Tagesdatum eingetragen werden. Diese kann durch die
          Funktion \languageorasql{SYSDATE} (Oracle) bzw.
          \languagemssql{GETDATE} (SQL Server) erzeugt werden.

          \beispiel{sql07_06} zeigt, wie in die Spalte
          \identifier{Buchungsdatum} das aktuelle Datum, als Standardwert
          eingef\"ugt wird.
          \begin{lstlisting}[language=oracle_sql,caption={Einf\"ugen eines Standardwertes},label=sql07_06]
INSERT INTO Buchung (Buchungs_ID, Betrag, Buchungsdatum, Konto_ID,
                     Transaktions_ID)
VALUES (500000, 300.20, DEFAULT, 1, 666666);
          \end{lstlisting}
          \begin{merke}
            Soll in eine Tabellenspalte deren Standardwert eingef\"ugt werden,
            muss das Schl\"usselwort \languageorasql{DEFAULT} benutzt werden.
          \end{merke}
        \subsubsection{Die INSERT-Anweisung und Unterabfragen}
          Die \INSERT-Anweisung ist in der Lage eine Unterabfrage zu verwenden,
          um den Inhalt einer Tabelle in eine andere Tabelle einzuf\"ugen. Dies
          kann z. B. das Kopieren eines Datensatzes in eine Tabelle gleicher
          Struktur sein oder das Abfragen einzelner Attribute, um diese f\"ur
          die Berechnung neuer Werte zu nutzen. Die Syntax f\"ur die
          \INSERT-Anweisung mit Unterabfrage lautet:
          \begin{lstlisting}[language=oracle_sql,caption={Die \INSERT-Anweisung mit Unterabfrage},label=sql07_07]
INSERT INTO <Tabelle> (<Spalte 1>, <Spalte 2>, ..., <Spalte n>)
<Unterabfrage>;
          \end{lstlisting}
          Das \INSERT-Statement kann eine beliebig komplexe Unterabfrage, wie in
          \abschnitt{subqueries} beschrieben, verwenden. \beispiel{sql07_08}
          zeigt, wie ein Datensatz aus der Tabelle \identifier{Mitarbeiter} in
          die strukturgleiche Tabelle \identifier{Ausgeschieden} kopiert wird.
          \begin{lstlisting}[language=oracle_sql,caption={Die \INSERT-Anweisung
      mit Unterabfrage},label=sql07_08]
-- Erstellen der Tabelle in Oracle
CREATE TABLE Ausgeschieden
AS
  SELECT *
  FROM   Mitarbeiter
  WHERE  1 = 2;
          \end{lstlisting}
\clearpage
          \begin{lstlisting}[language=oracle_sql]
-- Erstellen der Tabelle in SQL Server
SELECT *
INTO   Ausgeschieden
FROM   Mitarbeiter
WHERE  1 = 2;

-- Die INSERT-Anweisung für Oracle und SQL Server
INSERT INTO Ausgeschieden
SELECT *
FROM   Mitarbeiter
WHERE  Mitarbeiter_ID = 70;
          \end{lstlisting}
          Der Datensatz des Mitarbeiters Nummer 70 wird in die Tabelle
          \identifier{Ausgeschieden} kopiert.
      \subsection{Datens\"atze \"andern - Die UPDATE-Anweisung}
        Die \UPDATE-Anweisung repr\"asentiert den Teil von DML der es
        erm\"oglicht, bestehende Datens\"atze zu ver\"andern. Die Syntax von
        \UPDATE{} lautet:
        \begin{lstlisting}[language=oracle_sql,caption={Die Syntax des \UPDATE-Kommandos},label=sql07_09]
UPDATE <Tabelle>
SET    <Spalte 1> = <Wert>,
       <Spalte 2> = <Wert>,
       ...
       <Spalte n> = <Wert>
[WHERE  <Where-Klausel>];
        \end{lstlisting}

        \begin{center}
          \tablecaption{Die UPDATE-Anweisung}
          \label{updatesyntax}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail{\hline}
            \begin{supertabular}{|l|p{10.8cm}|}
              UPDATE <Tabelle> & An dieser Stelle steht der Name der Tabelle
              oder View, in der ein Datensatz ver\"andert werden soll. \\
              \hline
              SET <Spalte 1> = <Wert> & Die SET-Anweisung gibt die Spalten an,
              deren aktueller Wert durch den neuen Wert <Wert> ersetzt werden
              soll. Hier k\"onnen mehrere \enquote{Spalte = Wert}-Paare, durch
              Komma getrennt, stehen.\\
              \hline
              WHERE <Where-Klausel> & Optionale WHERE-Klausel, die den Umfang
              der Datens\"atze, die ge\"andert werden sollen, einschr\"ankt. \\
            \end{supertabular}
          \end{small}
        \end{center}
        Eine genauso einfache, wie auch gef\"ahrliche Form der
        \UPDATE-Anweisung, ist in \beispiel{sql07_10} zu sehen.
        \begin{lstlisting}[language=oracle_sql,caption={Ein gef\"ahrliches \UPDATE},label=sql07_10]
UPDATE Mitarbeiter
SET    Gehalt = Gehalt * 1.035;
        \end{lstlisting}
        Die Gefahr bei dieser \UPDATE-Anweisung besteht darin, das die Angabe
        einer einschr\"ankenden \WHERE-Klausel fehlt. Das DBMS wird in diesem
        Falle alle Datens\"atze der Tabelle \identifier{Mitarbeiter} ver\"andern
        und nicht nur eine bestimmte Gruppe.

        Soll nur das Gehalt des Mitarbeiters \textit{Max Winter} ge\"andert
        werden, muss das \UPDATE-Statement um eine \WHERE-Klausel erweitert
        werden:
        \begin{lstlisting}[language=oracle_sql,caption={Ein korrektes \UPDATE},label=sql07_11]
UPDATE Mitarbeiter
SET    Gehalt = Gehalt * 1.035
WHERE  Mitarbeiter_ID = 1;
        \end{lstlisting}
        Wie in \tabelle{updatesyntax} zu sehen ist, k\"onnen auch mehrere
        Spalten eines Datensatzes gleichzeitig ge\"andert werden. In
        \beispiel{sql07_12} wird die Mitarbeiterin \enquote{Lena Hermann}
        (Mitarbeiter\_ID 40) von Filiale 4 nach Filiale 8 versetzt und
        gleichzeitig wird ihre Provision von 20 \% auf 30 \% erh\"oht.
        \begin{lstlisting}[language=oracle_sql,caption={Ein korrektes \UPDATE{} mehrerer Spalten},label=sql07_12]
UPDATE Mitarbeiter
SET    Bankfiliale_ID = 8,
       Provision = 30
WHERE  Mitarbeiter_ID = 40;
        \end{lstlisting}
        Wo Licht ist, da ist aber immer auch Schatten. Wenn bei einem
        Mitarbeiter die Provision erh\"oht wird, muss sie bei einem anderen
        gek\"urzt oder gestrichen werden. Der Mitarbeiter \enquote{Lukas
        Wei\ss{}} hat im vergangenen Gesch\"aftsjahr ein sehr schlechtes
        Ergebnis erziehlt, weshalb ihm die Provision gestrichen wird. Dies
        geschieht, in dem die Spalte \identifier{Provision} mit einem
        \languageorasql{NULL}-Wert gef\"ullt wird.
        \begin{lstlisting}[language=oracle_sql,caption={Da geht sie hin, die Provision},label=sql07_13]
UPDATE Mitarbeiter
SET    Provision = NULL
WHERE  Mitarbeiter_ID = 38;
        \end{lstlisting}
        Nicht nur NULL-Werte, auch Standardwerte k\"onnen innerhalb eines
        \UPDATE-Statements genutzt werden.
        \begin{lstlisting}[language=oracle_sql,caption={Ein \UPDATE{} mit Standardwert},label=sql07_14]
UPDATE Mitarbeiter
SET    Gehalt = DEFAULT
WHERE  Mitarbeiter_ID = 82;
        \end{lstlisting}
        \beispiel{sql07_14} geht davon aus, dass f\"ur die Spalte
        \identifier{Gehalt} ein Standardwert von \enquote{1500} festgelegt
        worden ist.
        \subsubsection{UPDATE mit Unterabfrage}
          Wie bei der \INSERT-Anweisung, kann auch bei der \UPDATE-Anweisung
          eine Unterabfrage genutzt werden. Diese kann an zwei Stellen stehen:
          In der \languageorasql{SET}-Klausel und in der \WHERE-Klausel. Hierzu
          einige Beispiele.

          Das Gehalt des Mitarbeiters \enquote{Jannis Friedrich} soll ge\"andert
          werden. Das neue Gehalt muss 20 \% des Gehalts seines unmittelbaren
          Vorgesetzten betragen.
          \begin{lstlisting}[language=oracle_sql,caption={\UPDATE{} mit Unterabfrage},label=sql07_15]
UPDATE Mitarbeiter
SET    Gehalt = (SELECT v.Gehalt
                 FROM   Mitarbeiter m INNER JOIN Mitarbeiter v
                          ON (m.Vorgesetzter_ID = v.Mitarbeiter_ID)
                 WHERE  m.Mitarbeiter_ID = 79) * 0.20
WHERE  Mitarbeiter_ID = 79;
          \end{lstlisting}
          Mit Hilfe der folgenden \SELECT-Anweisung kann die Korrektheit des
          \UPDATE-Statements aus \beispiel{sql07_15} nachgewiesen werden.
          \begin{lstlisting}[language=oracle_sql,caption={Der Beweis},label=sql07_16]
SELECT Mitarbeiter_ID, Vorname, Nachname, Gehalt
FROM   Mitarbeiter
WHERE  Mitarbeiter_ID IN (79, 21);
          \end{lstlisting}
          In \beispiel{sql07_15} wird die Mitarbeiter\_ID 79 an zwei Stellen
          angegeben. Durch eine Ver\"anderung des \UPDATE-Statements kann dies
          auf eine Angabe reduziert werden.
          \begin{lstlisting}[language=oracle_sql,caption={\UPDATE{} mit
korrelierter Unterabfrage in Oracle},label=sql07_17]
UPDATE Mitarbeiter m1
SET    Gehalt = (SELECT v.Gehalt
                 FROM   Mitarbeiter m INNER JOIN Mitarbeiter v
                          ON (m.Vorgesetzter_ID = v.Mitarbeiter_ID)
                 WHERE  m.Mitarbeiter_ID = m1.Mitarbeiter_ID)
WHERE  m1.Mitarbeiter_ID = 79;
          \end{lstlisting}

          In der \UPDATE-Klausel wird ein Alias f\"ur die Tabelle
          \identifier{Mitarbeiter} festgelegt. Diesen Alias benutzt die
          Unterabfrage, um auf die Werte des \"au\ss{}eren Statements, des
          \UPDATE-Statements, zuzugreifen. Dadurch gen\"ugt es, wenn die
          Mitarbeiter\_ID nur einmal gesetzt wird. Im MS SQL Server muss der
          Alias f\"ur die Tabelle \identifier{Mitarbeiter} \"uber eine
          \FROM-Klausel definiert werden, so dass sich \beispiel{sql07_17} wie
          folgt \"andert:
\clearpage
          \begin{lstlisting}[language=ms_sql,caption={\UPDATE{} mit
korrelierter Unterabfrage im MS SQL Server},label=sql07_171]
UPDATE m1
SET    Gehalt = (SELECT v.Gehalt
								 FROM   Mitarbeiter m INNER JOIN Mitarbeiter v
													ON (m.Vorgesetzter_ID = v.Mitarbeiter_ID)
								 WHERE  m.Mitarbeiter_ID = m1.Mitarbeiter_ID)
FROM Mitarbeiter m1
WHERE  m1.Mitarbeiter_ID = 79;
          \end{lstlisting}

          \enquote{Was des einen Freud ist, ist des andern Leid}. Dieser
          Grundsatz trifft auch bei der Gehaltserh\"ohung f\"ur Herrn Friedrich
          zu. Da er nun 400 EUR mehr Gehalt bekommt, m\"ussen bei den anderen
          Angestellten dementsprechende Einsparungen vorgenommen  werden. F\"ur
          alle Mitarbeiter der Filiale 14, mit Ausnahme von Herrn Friedrich,
          muss das Gehalt um 2~\% gek\"urzt werden.
          \begin{lstlisting}[language=oracle_sql,caption={Gehaltsk\"urzung f\"ur eine ganze Filiale},label=sql07_18]
UPDATE Mitarbeiter
SET    Gehalt = Gehalt * 0.98
WHERE  Mitarbeiter_ID IN (SELECT Mitarbeiter_ID
                          FROM   Mitarbeiter
                          WHERE  Bankfiliale_ID = 14
                            AND  Mitarbeiter_ID <> 79);
          \end{lstlisting}
      \subsection{Datens\"atze l\"oschen - Die DELETE-Anweisung}
        Die dritte und letzte der DML-Anweisungen, ist die \DELETE-Anweisung.
        Sie erm\"oglicht es, Datens\"atze zu l\"oschen. Die Syntax der
        \DELETE-Anweisung lautet wie folgt:
        \begin{lstlisting}[language=oracle_sql,caption={Die \DELETE-Anweisung},label=sql07_19]
DELETE FROM <Tabelle>
WHERE <Where-Klausel>;
        \end{lstlisting}
        \begin{center}
          \tablecaption{Die DELETE-Anweisung}
          \label{deletesyntax}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \begin{supertabular}{|l|p{10.8cm}|}
              DELETE <Tabelle> & An dieser Stelle steht der Name der Tabelle
              oder View, aus der Datens\"atze gel\"oscht werden sollen. \\
              \hline
              WHERE <Where-Klausel> & Optionale WHERE-Klausel, die den Umfang
              der Datens\"atze begrenzt, die gel\"oscht werden sollen. \\
            \end{supertabular}
          \end{small}
        \end{center}
        \"Ahnlich wie bei der \UPDATE-Anweisung, gibt es auch bei der
        \DELETE-Anweisung eine kleine Falle. \beispiel{sql07_20} zeigt, wie man
        mit einer sehr einfachen \DELETE-Anweisung in gro\ss{}e Schwierigkeiten
        geraten kann.
        \begin{lstlisting}[language=oracle_sql,caption={Eine t\"odliche \DELETE-Anweisung},label=sql07_20]
DELETE FROM Buchung;
        \end{lstlisting}
        Die Auswirkungen der \DELETE-Anweisung aus \beispiel{sql07_20} sind
        einfach und kurz erkl\"art. Es werden alle Datens\"atze aus der Tabelle
        \identifier{Buchung} gel\"oscht. Des R\"atsels L\"osung ist die gleiche
        wie beim \UPDATE-Statement: Es fehlt die einschr\"ankende
        \WHERE-Klausel. Um beispielsweise nur eine einzelne Buchung zu l\"oschen
        ist folgende Modifikation notwendig:
        \begin{lstlisting}[language=oracle_sql,caption={Schon viel besser!!!},label=sql07_21]
DELETE FROM Buchung
WHERE  Transaktions_ID = 345;
        \end{lstlisting}
        \subsubsection{DELETE mit Unterabfrage}
         Auch in der \DELETE-Anweisung kann eine Unterabfrage genutzt werden.
         Hierzu ein einfaches Beispiel: Da die Bankfiliale, in der
         Poststra\ss{}e, in Aschersleben aufgel\"ost wird, m\"ussen leider auch
         die dort besch\"aftigten Mitarbeiter wieder dem Arbeitsmarkt zur
         Verf\"ugung gestellt werden.
          \begin{lstlisting}[language=oracle_sql,caption={\DELETE{} mit Unterabfrage},label=sql07_22]
DELETE FROM Mitarbeiter
WHERE  Bankfiliale_ID = (SELECT Bankfiliale_ID
                         FROM   Bankfiliale
                         WHERE  LOWER(Strasse) LIKE 'poststraße'
                           AND  PLZ = '06449');
          \end{lstlisting}
    \section{Das Transaktionskonzept - COMMIT und ROLLBACK}
      Die Datenbankmanagementsysteme Oracle und SQL Server sind beides
      transaktionsbasierte DBMS. Das bedeutet, dass alle DML-Anweisungen
      innerhalb einer Transaktion ablaufen. Die Frage die sich dabei stellt ist:
      \enquote{Was ist eine Transaktion?} Der Begriff Transaktion ist dem
      sp\"atlateinischen \enquote{transagere = \"Uberf\"uhren, \"Ubertragen}
      entliehen und den meisten Leuten aus dem Finanzbereich bekannt. Man denke
      einfach an die \"Uberweisung eines Betrags von Konto A auf Konto B. Der
      vereinfachte Ablauf einer solchen Finanztransaktion k\"onnte wie folgt
      aussehen:
      \begin{enumerate}
        \item Kontoinhaber A f\"ullt einen \"Uberweisungstr\"ager aus. Damit
        beginnt die Transaktion.
        \item Die Bank des Kontoinhabers A zieht den \"Uberweisungsbetrag von
        seinem Konto ab und \"ubermittelt die Informationen bez\"uglich der
        \"Uberweisung an Bank B.
        \item Bank B schreibt den Betrag auf dem Konto von Kontoinhaber B gut.
        \item Der Vorgang wird in einem Journal protokolliert. Damit ist die
        \"Uberweisung abgeschlossen.
      \end{enumerate}
      Warum aber der Begriff der Transaktion? Die Antwort auf diese Frage
      h\"angt eng mit der Antwort auf eine andere Frage zusammen: \enquote{Was
      w\"are wenn, nach der Abbuchung von Konto A der Vorgang unterbrochen
      w\"urde?} In so einem Falle ist das gewohnte Verhalten, das alle bisher
      gemachten Schritte wieder r\"uckg\"angig gemacht werden, d. h. der
      abgebuchte Betrag muss wieder auf das Konto von A zur\"uckgebucht werden.
      W\"urde dies nicht geschehen, w\"are das Geld von A verschwunden.

      Das R\"uckg\"angigmachen aller bisher gemachten Aktionen ist aber nur dann
      m\"oglich, wenn
      \begin{itemize}
        \item genau bekannt ist, welche Aktionen zusammengeh\"oren und
        \item  in welcher Reihenfolge sie stattgefunden haben.
      \end{itemize}
      Deshalb werden alle Aktionen in einer gr\"o\ss eren Einheit, der
      Transaktion, zusammengefa\ss t. Es muss also im Ernstfall nur ermittelt
      werden, zu welcher Transaktion die letzte Aktion geh\"orte um alle
      Vorg\"angeraktionen ermitteln zu k\"onnen.
      \begin{merke}
        Definition \textit{Transaktion}: Eine Transaktionen ist eine logische
        Arbeitseinheit, die einen oder mehrere Arbeitsschritte enth\"alt.
        Transaktionen sind in sich geschlossene Einheiten. Die Ergebnisse aller
        Arbeitsschritte einer Transaktion k\"onnen entweder \"ubernommen oder
        r\"uckg\"angig gemacht werden.
      \end{merke}
      Dieses Konzept l\"asst sich auch auf Datenbanken \"ubertragen. Werden
      mehrere zusammengeh\"orende SQL-Anweisungen ausgef\"uhrt, muss auch
      gew\"ahrleistet werden, dass entweder alle erfolgreich beendet werden oder
      aber alle r\"uckg\"angig gemacht werden.
      \subsection{Beginn und Ende einer Transaktion}
        \subsubsection{Wann beginnt eine Transaktion?}
          In Oracle startet eine Transaktion:
          \begin{itemize}
            \item Implizit bei jedem ersten DML-Statement.
            \item Explizit durch die Anweisung \languageorasql{SET TRANSACTION}.
          \end{itemize}
          In MS SQL Server startet eine Transaktion:
          \begin{itemize}
            \item Wenn der implizite Transaktionsmodus aktiviert wurde, bei
            jedem ersten DML-State\-ment.
            \item Explizit durch die Anweisung \languagemssql{BEGIN TRANSACTION}
          \end{itemize}
          \begin{merke}
            Das Standardverhalten in SQL Server ist, dass jedes einzelne
            DML-Statement als eigene Transaktion abgehandelt wird. Zur
            Ak\-ti\-vie\-rung des impliziten Transaktionsmodus muss die
            SQL-Anweisung \languagemssql{SET IMPLICIT_TRANSACTIONS ON} abgesetzt
            werden.
          \end{merke}
        \subsubsection{Wann endet eine Transaktion?}
          Eine Transaktion kann an zwei verschiedenen Punkten enden:
          \begin{itemize}
            \item Sie wird erfolgreich abgeschlossen.
            \item Sie wird manuell r\"uckg\"angig gemacht.
          \end{itemize}
      \subsection{Eine Transaktion erfolgreich abschlie\ss en}
        \subsubsection{Das COMMIT-Kommando}
          Wenn alle Statements einer Transaktion erfolgreich verlaufen sind, muss
          die Transaktion beendet werden, um die gemachten \"Anderungen dauerhaft
          in der Datenbank zu speichern. Dies geschieht in Oracle mit Hilfe des
          Kommandos \COMMIT. Wird eine Transaktion nicht mit \COMMIT{} abgeschlossen, werden
          automatisch alle unbestätigten \"Anderungen r\"uckg\"angig gemacht.
          \beispiel{sql07_23} ff. zeigen dieses Verhalten.
          \begin{lstlisting}[language=oracle_sql,caption={Eine Transaktion wird abgebrochen},label=sql07_23]
SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{lstlisting}[language=oracle_sql,label=sql07_24]
INSERT INTO Bank
VALUES      (21, 'NOSDEL21SES', 'Lokki Bank of Cyprus',
             'Strasse der Europaeischen Union', '3', '00000', 'Pleitingen',
             'D--');

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
        \end{lstlisting}
\clearpage
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                  21 & NOSDEL21SES & Lokki Bank of Cyprus  \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{lstlisting}[language=oracle_sql,label=sql07_25]
-- An dieser Stelle findet ein Absturz der Client-Anwendung statt
-- und die Anwendung wird neu gestartet.

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          Weil vor dem Absturz der Client-Anwendung die Transaktion nicht mit
          \COMMIT{} abgeschlossen wurde, ist die gemachte \"Anderung wieder
          verschwunden. Das gleiche Szenario nun noch einmal, aber mit \COMMIT{}
          am Ende.
          \begin{lstlisting}[language=oracle_sql,label=sql07_26]
INSERT INTO Bank
VALUES      (21, 'NOSDEL21SES', 'Lokki Bank of Cyprus',
             'Strasse der Europaeischen Union', '3', '00000', 'Pleitingen',
             'D--');

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;

COMMIT;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
  %               \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                  21 & NOSDEL21SES & Lokki Bank of Cyprus  \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
\clearpage
         \begin{lstlisting}[language=oracle_sql,label=sql07_27]
-- An dieser Stelle wird die Client-Anwendung beendet und
-- neugestartet.

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                  21 & NOSDEL21SES & Lokki Bank of Cyprus  \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{merke}
            Die \COMMIT-Anweisung persistiert\footnote{persistent = dauerhaft}
  					die Aktionen einer Transaktion in der Datenbank. Ohne \COMMIT{} werden alle
  					\"Anderungen wieder zur\"uckgerollt.
          \end{merke}
        \subsubsection{COMMIT in Microsoft SQL Server}
          In Microsoft SQL Server muss dem \COMMIT-Kommando noch das
          Schlüsselwort \languagemssql{TRANSACTION} (oder
          \languagemssql{TRAN}) hinzugefügt werden. Dies beendet sowohl
          implizite als auch explizite Transaktionen.
        \begin{lstlisting}[language=ms_sql,caption={Eine implizite Transaktion
        committen},label=sql07_27a]
SET IMPLICIT_TRANSACTIONS ON
INSERT INTO Bank
VALUES      (21, 'NOSDEL21SES', 'Lokki Bank of Cyprus',
             'Strasse der Europaeischen Union', '3', '00000', 'Pleitingen',
             'D--');

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;

COMMIT TRAN;
        \end{lstlisting}
\clearpage
        \begin{lstlisting}[language=ms_sql,caption={Eine explizite Transaktion
        committen},label=sql07_27b]
BEGIN TRANSACTION
INSERT INTO Bank
VALUES      (21, 'NOSDEL21SES', 'Lokki Bank of Cyprus',
             'Strasse der Europaeischen Union', '3', '00000', 'Pleitingen',
             'D--');

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
COMMIT TRAN;
        \end{lstlisting}
          
      \subsection{Eine Transaktion r\"uckg\"angig machen}
        \subsubsection{Das ROLLBACK-Kommando}
          Das Kommando \ROLLBACK{} stellt das Gegenst\"uck zu \COMMIT{} dar.
          Sollen die Aktionen einer Transaktion nicht dauerhaft in der Datenbank
          gespeichert werden, k\"onnen sie mit \ROLLBACK{} zur\"uckgerollt
          (r\"uckg\"angig gemacht) werden.
          \begin{lstlisting}[language=oracle_sql,caption={Eine Transaktion wird
        abgebrochen},label=sql07_28] SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                  21 & NOSDEL21SES & Lokki Bank of Cyprus \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{lstlisting}[language=oracle_sql,label=sql07_29]
DELETE FROM Bank
WHERE  Bank_ID = 21;

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{lstlisting}[language=oracle_sql,label=sql07_30]
ROLLBACK;

SELECT Bank_ID, BIC, Name
FROM   Bank
WHERE  Bank_ID >= 18;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{BANK\_ID}} &
                \multicolumn{1}{l}{\textbf{BIC}} &
                \multicolumn{1}{l}{\textbf{NAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{4 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{rll}
                  18 & BVXYDE21SES & Bank der Landwirte \\
                  19 & BGIODE21SES & Austrailian Bank Association \\
                  20 & DFGHDE21SES & South Africa Bank \\
                  21 & NOSDEL21SES & Lokki Bank of Cyprus \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          \begin{merke}
            Die Anweisung \ROLLBACK{} rollt alle Aktionen einer Transaktion
            zur\"uck und beendet sie.
          \end{merke}
        \subsubsection{ROLLBACK in Microsoft SQL Server}
          Genau wie das \COMMIT-Kommando, muss auch das \ROLLBACK-Kommando um
          das Schlüsselwort \languagemssql{TRANSACTION} ergänzt werden.
