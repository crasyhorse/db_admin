  \chapter{Unterabfragen (Subqueries)}
  \label{subqueries}
    \setcounter{page}{1}\kapitelnummer{chapter}
    \minitoc
\newpage
    \section{Grunds\"atzliches zu Unterabfragen}
      \subsection{Was sind Unterabfragen?}\label{whataresubqueries}
        Unterabfragen sind Abfragen, die in eine andere Abfrage, die Hauptabfrage oder \enquote{Mainquery}, eingebettet werden. Dies kann an mehreren Stellen geschehen.
        \begin{itemize}
          \item \SELECT-Klausel
          \item \FROM-Klausel (Inlineview)
          \item \WHERE-Klausel
          \item \HAVING-Klausel
        \end{itemize}
        \bild{Unterabfragen}{abfrage}{0.8}
        F\"ur Unterabfragen gibt es die unterschiedlichsten Bezeichnungen.
        \begin{itemize}
          \item Subquery
          \item Inner query
          \item Nested query
        \end{itemize}
      \subsection{Wann sind Unterabfragen notwendig?}
        Mit Hilfe von SQL k\"onnen zwei verschiedene Arten von Problemstellungen gel\"ost werden:
        \begin{itemize}
          \item Einschrittige Problemstellungen
          \item Mehrschrittige Problemstellungen
        \end{itemize}
        Unter einer einschrittigen Problemstellung versteht man die Art von Fragestellung, die mit einer einzigen Abfrage (einem einzigen Arbeitsschritt) gel\"ost werden kann, so wie dies in den vorangegangenen Kapiteln der Fall war.

        Mehrschrittige Problemstellungen erfordern, wie der Name es sagt, mehrere Abfragen, die aufeinander aufbauen (die eine Abfrage ben\"otigt das Ergebnis der anderen), um zu einer L\"osung zu kommen. Eine solche Problemstellung k\"onnte z. B. so lauten: \enquote{Wie hoch ist das Gehalt des Vorgesetzten der Mitarbeiterin \textit{Lena Gro\ss{}e}?}
\clearpage
        Diese Frage l\"asst sich in zwei Fragen teilen:
        \begin{enumerate}
          \item Wer ist der Vorgesetzte von Lena Gro\ss{}e?
          \item Wie hoch ist dessen Gehalt?
        \end{enumerate}
        Die Antworten zu beiden Fragen lassen sich sehr einfach als SQL-Statements formulieren.
        \begin{lstlisting}[language=oracle_sql,caption={Wer ist der Vorgesetzte von Lena Gro\ss{}e},label=sql06_01]
SELECT Vorgesetzter_ID
FROM   Mitarbeiter
WHERE  Vorname LIKE 'Lena' AND  Nachname LIKE 'Große';
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{VORGESETZTER\_ID}} \\
              \cmidrule(r){1-1}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{r}
                6 \\
              \end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
        \begin{lstlisting}[language=oracle_sql,caption={Wie hoch ist dessen Gehalt},label=sql06_02]
SELECT Gehalt
FROM   Mitarbeiter
WHERE  Mitarbeiter_ID = 6;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{GEHALT}} \\
              \cmidrule(r){1-1}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{r}
                30000 \\
              \end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
        Mit Hilfe der beiden Abfragen wurde die Antwort ermittelt: \enquote{Der Vorgesetzte von Lena Gro\ss{}e hat ein Gehalt von 30.000 EUR.}. Durch das Kombinieren beider Queries, l\"asst sich diese Aufgabe viel eleganter l\"osen. \beispiel{sql06_03} zeigt einen m\"oglichen L\"osungsansatz.
        \begin{lstlisting}[language=oracle_sql,caption={Wie hoch ist das Gehalt des Vorgesetzten der Mitarbeiterin \textit{Lena Gro\ss{}e}?},label=sql06_03]
SELECT Gehalt
FROM   Mitarbeiter
WHERE  Mitarbeiter_ID = (SELECT Vorgesetzter_ID
                         FROM   Mitarbeiter
                         WHERE  Vorname LIKE 'Lena'
                           AND  Nachname LIKE 'Grosse');
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{GEHALT}} \\
              \cmidrule(r){1-1}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{1}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{r}
                30000 \\
              \end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
\clearpage
        \begin{merke}
          Das DBMS arbeitet bei einer solchen Auswahlabfrage immer zuerst die Unterabfrage(n) ab!
        \end{merke}
      \subsection{Regeln f\"ur Unterabfragen}
        F\"ur die Anwendung von Unterabfragen gelten die folgenden Grunds\"atze:
        \begin{itemize}
          \item Unterabfragen stehen immer in Klammern!
          \item Es k\"onnen alle ihnen bisher bekannten Operatoren eingesetzt werden!
          \item Unterabfragen \textbf{sollten immer ohne \ORDERBY-Klausel} erstellt werden!
        \end{itemize}
        Die Aussage, dass Unterabfragen immer ohne \ORDERBY{} verwendet werden sollten, r\"uhrt daher, dass falls eine Sortierung in der Hauptabfrage stattfindet, zuerst in der Unterabfrage sortiert wird und anschlie\ss end nochmals in der Hauptabfrage. Dies f\"uhrt zu unn\"otiger Sortierarbeit, die die Datenbank belastet.
        \begin{merke}
          In MS SQL Server darf eine Unterabfrage kein \ORDERBY{} enthalten. Das DBMS antwort sonst mit einer Fehlermeldung (Meldung 1033, Ebene 15).
        \end{merke}
      \subsection{Arten von Unterabfragen}
        Grunds\"atzlich gibt es vier unterschiedliche Arten von Unterabfragen:
        \begin{itemize}
          \item Skalare Unterabfragen: Eine solche Abfrage liefert exakt einen Wert zur\"uck.
          \item Einspaltige Unterabfragen: Dieser Abfragetyp liefert mehrere Werte aus einer Spalte zur\"uck.
          \item Mehrspaltige Unterabfragen: Mit einer solchen Abfrage werden Werte mehrerer Spalten zur\"uckgeliefert.
          \item Korrelierte Unterabfragen: Ihre Ausf\"uhrung ist von der Hauptabfrage abh\"angig.
        \end{itemize}
\clearpage
    \section{Skalare Unterabfragen (Scalar Subqueries)}
      \begin{merke}
        \textbf{Skalar:}
        \vspace{1em}

        Gr\"o\ss{}e aus der Mathematik, die durch die Angabe eines einzelnen Wertes genau definiert werden kann.
        \vspace{1em}

        Beispiele f\"ur Skalare sind: Gehalt, Provision, \dots
      \end{merke}
      Skalare Unterabfragen zeichnen sich dadurch aus, dass sie genau einen einzigen Wert zur\"uckliefern.   Dies wird mit Hilfe einer entsprechenden \WHERE-Klausel innerhalb der Unterabfrage erreicht. Ergibt die Abfrage kein Ergebnis, wird NULL zur\"uckgliefert. Ein erstes Beispiel f\"ur diese Art von Unterabfrage war in \beispiel{sql06_03} zu sehen. Es wird nur das \identifier{Gehalt} eines einzigen Angestellten angezeigt.
      \subsection{Wo k\"onnen skalare Unterabfragen stehen?}
        Skalare Unterabfragen k\"onnen in allen in \abschnitt{whataresubqueries} erw\"ahnten Klauseln stehen.
        \subsubsection{Skalare Unterabfragen in der SELECT-Klausel}
          Skalare Unterabfragen sind die einzigen, die in der \SELECT-Klausel eines SQL-Statements stehen d\"urfen. Sie k\"onnen beispielsweise dazu dienen, um einen Outer-Join zu vermeiden, meist ist jedoch die Join-Variante sehr viel performanter. Aus diesem Grund sollten skalare Unterabfragen in der \SELECT-Klausel absolut vermieden werden.
          \begin{merke}
            Skalare Unterabfragen in der \SELECT-Klausel sollten unter allen Umst\"anden vermieden werden!
          \end{merke}
        \subsubsection{Skalare Unterabfragen in der WHERE-Klausel}
          Die \WHERE-Klausel ist der Ort, an dem skalare Unterabfragen am h\"aufigsten anzutreffen sind. Sie dienen zur Berechnung von Werten, mit deren Hilfe das Resultat der Hauptabfrage eingeschr\"ankt wird (siehe \beispiel{sql06_03}).
        \subsubsection{Skalare Unterabfragen in der Having-Klausel}
        Hier gelten die gleichen Grunds\"atze, wie in der \WHERE-Klausel. Der einzige Unterschied ist, das hier ein Aggregat mit dem Resultat einer skalaren Unterabfrage verglichen werden kann.
      \subsection{Fehlerquellen in skalaren Unterabfragen}
        Die h\"aufigste Fehlerquelle, im Umgang mit skalaren Unterabfragen, ist eine falsche \WHERE-Klausel. Schr\"ankt sie das Ergebnis der Unterabfrage nicht gen\"ugend ein, wird mehr als ein Datensatz/Wert zur\"uckgeliefert und die Datenbank antwortet mit einer Fehlermeldung.
          \begin{lstlisting}[language=oracle_sql,caption={Mehr als eine Zeile: Fehlermeldung in Oracle},label=sql06_04]
ORA-01427: Unterabfrage fuer eine Zeile liefert mehr als eine Zeile
          \end{lstlisting}
          \begin{lstlisting}[language=ms_sql,caption={Mehr als eine Zeile: Fehlermeldung in SQL Server},label=sql06_05]
Meldung 512, Ebene 16, Status 1, Zeile 1
Die Unterabfrage hat mehr als einen Wert zurueckgegeben. Das ist nicht
zulaessig, wenn die Unterabfrage auf =, !=, <, <=, > oder >= folgt oder
als Ausdruck verwendet wird.
          \end{lstlisting}
          Hier ein Beispiel zu diesen Fehlermeldungen: Es soll das Geburtsdatum des Vorgesetzten der Mitarbeiterin \enquote{Gro\ss{}e} ermittelt werden.
          \begin{lstlisting}[language=oracle_sql,caption={Eine Single Row Unterabfrage mit Problemen!},label=sql06_06]
SELECT Geburtsdatum
FROM   Mitarbeiter
WHERE  Mitarbeiter_ID = (SELECT Vorgesetzter_ID
                         FROM   Mitarbeiter
                         WHERE  LOWER(Nachname) LIKE 'große');
          \end{lstlisting}
          Das Problem bei dieser Abfrage ist, dass die Tabelle \identifier{Mitarbeiter} zwei Angestellte mit dem Namen \enquote{Gro\ss{}e} enth\"alt. Das bedeutet, die Unterabfrage liefert mehr als einen Wert zur\"uck, so dass der Vergleich mit einem Single Row Operator scheitert.
          \begin{merke}
            Als Single Row Operatoren werden relationale Operatoren bezeichnet, die einen Wert auf ihrer linken Seite mit genau einem Wert auf ihrer rechten Seite vergleichen k\"onnen. Hierzu z\"ahlen: = >= <= < > != LIKE
          \end{merke}
    \section{Einspaltige Unterabfragen}
      Diese Kategorie der Unterabfragen unterschiedet sich von den skalaren dahingehend, dass sie eine einspaltige Liste von mehreren Werten (Vektor) zur\"uckliefern und das sie nicht in der \SELECT-Klausel eines SQL-Statements vorkommen d\"urfen.
      \subsection{Einspaltige Unterabfragen in WHERE- und HAVING-Klausel}
        \languageorasql{IN} (bekannt aus \abschnitt{relopersql}) ist der einzige Operator, der auf seiner rechten Seite nicht nur einen einzelnen Wert, sondern eine ganze Wertemenge verarbeiten kann. Dies kann eine konstante Menge sein, so wie dies bisher der Fall war, aber es kann auch eine, durch eine Query dynamisch generierte Menge sein. \beispiel{sql06_07} zeigt den Einsatz des \languageorasql{IN}-Operators. Es muss eine Liste aller Kunden ermittelt werden, die vor dem \enquote{01.01.1980} ein Konto bei der Bank er\"offnet haben.
        \begin{lstlisting}[language=oracle_sql,caption={\languageorasql{IN} mit Unterabfrage},label=sql06_07]
SELECT Vorname, Nachname
FROM   Kunde
WHERE  Kunden_ID IN (SELECT Kunden_ID
                     FROM   EigenkundeKonto
                     WHERE  Eroeffnungsdatum < TO_DATE('01.01.1980'));
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{VORNAME}} &
              \multicolumn{1}{l}{\textbf{NACHNAME}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{2}{l}{\textbf{28 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{28 Zeilen ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{ll}
									Jan & Wei\ss{} \\
									Petra & Berger \\
									Karolin & Lange \\
									Tom & Hartmann \\
								\end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
        Auf die gleiche Art und Weise, wie in \beispiel{sql06_07} gezeigt, k\"onnen einspaltige Unterabfragen auch in einer \HAVING-Klausel eingesetzt werden, was jedoch nur sehr selten vorkommt.
      \subsection{Existenzpr\"ufungen}
				\subsubsection{Der EXISTS-Operator}
          Der Name \textit{Existenzpr\"ufung} sagt ohne Umschweife aus, worum es geht. Mit Hilfe des Operators \languageorasql{EXISTS} kann die Existenz bestimmter Daten gepr\"uft werden. \beispiel{sql06_08} zeigt auf worum es sich hierbei handelt. Es soll eine Liste der Bankfilialen ermittelt werden, in denen Mitarbeiter eingesetzt sind.
          \begin{lstlisting}[language=oracle_sql,caption={Der \languageorasql{EXISTS}-Operator},label=sql06_08]
SELECT Strasse, Hausnummer, PLZ, Ort
FROM   Bankfiliale b
WHERE  EXISTS (SELECT 1
               FROM   Mitarbeiter m
               WHERE  b.Bankfiliale_ID = m.Bankfiliale_ID);
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{l}{\textbf{STRASSE}} &
                \multicolumn{1}{l}{\textbf{HAUSNUMMER}} &
                \multicolumn{1}{l}{\textbf{PLZ}} &
                \multicolumn{1}{l}{\textbf{ORT}} \\
                \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
              }
              \tablehead{}
              \tabletail {
              }
              \tablelasttail {
                \multicolumn{4}{l}{\textbf{20 Zeilen ausgew\"ahlt}} \\
              }
              \begin{msoraclesql}
                \begin{supertabular}{llll}
                  Poststra\ss{}e & 1 & 06449 & Aschersleben \\
                  Markt & 5 & 06449 & Aschersleben \\
                  Goethestra\ss{}e & 4 & 39240 & Calbe \\
                  Lessingstra\ss{}e & 1 & 06406 & Bernburg \\
                  Schillerstra\ss{}e & 7 & 39240 & Barby \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
          Das Ergebnis dieser Auswahlabfrage sind alle Bankfilialen, in denen Mitarbeiter arbeiten. Es verbleibt eine Filiale ohne Mitarbeiter.

          Was geschieht in dieser Abfrage nun in welcher Reihenfolge?
          \begin{enumerate}
            \item Die \FROM-Klausel der Hauptabfrage wird ausgewehrtet und die erforderlichen Daten werden ermittelt.
            \item Die \FROM-Klausel der Unterabfrage wird ausgewehrtet und die erforderlichen Daten werden ermittelt.
            \item Die \WHERE-Klausel der Unterabfrage wird ausgef\"uhrt. Der Join zwischen \identifier{Bankfiliale} und \identifier{Mitarbeiter} wird gebildet.
            \item Die \WHERE-Klausel der Hauptabfrage wird ausgef\"uhrt.
            \item Die \SELECT-Klausel der Hauptabfrage liefert die ben\"otigten Daten.
          \end{enumerate}
          Das Besondere an dieser Form der Abfrage ist die \WHERE-Klausel der Unterabfrage. Dort wird die Tabelle \identifier{Bankfiliale} (Hauptabfrage) mit der Tabelle \identifier{Mitarbeiter} (Unterabfrage) verkn\"upft. Die Unterabfrage kann somit auf die Datens\"atze der Hauptabfrage zugreifen.
          \begin{merke}
            Werden die Tabellen einer Unterabfrage mit einer Tabelle der Hauptabfrage verkn\"upft, spricht man von einer \enquote{korrelierten Unterabfrage}.
          \end{merke}
\clearpage
          F\"ur die Ausf\"uhrung des gesamten Statements bedeutet dies, das die Unterabfrage nicht nur einmal, sondern mehrfach ausgef\"uhrt werden muss. Genauer gesagt wird die Unterabfrage f\"ur jede Zeile der Hauptabfrage einmal ausgef\"uhrt. Bezogen auf \beispiel{sql06_08} bedeutet dies, dass die Unterabfrage 21 mal ausgef\"uhrt wird, da die Tabelle Bankfiliale 21 Datens\"atze hat. Die Mehrfachausf\"uhrung der Unterabfrage ist notwendig, da f\"ur jede Bankfiliale einzeln gepr\"uft werden muss, ob es dort Mitarbeiter gibt oder nicht.

          Eine weitere Besonderheit dieser Art von Abfrage ist die \SELECT-Klausel der Unterabfrage. Dort stehen keine Spaltenbezeichner und auch kein *. Statt dessen wird hier ein Literal, eine 1 (eins) verwendet. Der Hintergrund hierf\"ur ist, das die \SELECT-Klausel der Unterabfrage f\"ur die Ausf\"uhrung des gesamten Statements keine Bedeutung hat. Es wird nur gepr\"uft, ob f\"ur jeden Datensatz der Hauptabfrage ein Datensatz in der Unterabfrage existiert. Das bedeutet, dass sobald die Unterabfrage eine Zeile zur\"uckliefert die Bedingung erf\"ullt ist und der Datensatz der Hauptabfrage angezeigt wird.
        \subsubsection{Der NOT EXISTS-Operator}
          Der \languageorasql{NOT EXISTS}-Operator stellt das Pendant zum \languageorasql{EXISTS}-Operator dar. M\"ussen beispielsweise alle Filialen ermittelt werden, in denen keine Mitarbeiter arbeiten kommt \languageorasql{NOT EXISTS} zum Einsatz.
          \begin{lstlisting}[language=oracle_sql,caption={Der \languageorasql{NOT EXISTS}-Operator},label=sql06_09]
SELECT Strasse, Hausnummer, PLZ, Ort
FROM   Bankfiliale b
WHERE  NOT EXISTS (SELECT 1
                   FROM   Mitarbeiter m
                   WHERE  b.Bankfiliale_ID = m.Bankfiliale_ID);
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{l}{\textbf{STRASSE}} &
                \multicolumn{1}{l}{\textbf{HAUSNUMMER}} &
                \multicolumn{1}{l}{\textbf{PLZ}} &
                \multicolumn{1}{l}{\textbf{ORT}} \\
                \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{4}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{4}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
              }

              \begin{msoraclesql}
                \begin{supertabular}{llll}
                  Kurze Gasse & 47 & 06425 & Alsleben \\
                \end{supertabular}
              \end{msoraclesql}
            \end{small}
          \end{center}
    \section{Inlineviews / Derived Tables}
      In \abschnitt{whataresubqueries} wurde bereits erw\"ahnt, dass eine Unterabfrage auch in der \FROM-Klausel eines SQL-Statements stehen kann.
      \begin{merke}
        Eine Unterabfrage in der \FROM-Klausel wird in Oracle als \enquote{Inlineview} und in MS SQL Server als \enquote{Derived Table} bezeichnet.
      \end{merke}
      \beispiel{sql06_10} zeigt ein SQL-Statement, welches eine Inlineview nutzt.
      \begin{lstlisting}[language=oracle_sql,caption={Eine Inlineview},label=sql06_10]
SELECT Vorname, Nachname, MinGehalt
FROM   (SELECT   Bankfiliale_ID, MIN(Gehalt) MinGehalt
        FROM     Mitarbeiter
        GROUP BY Bankfiliale_ID) m1
        INNER JOIN Mitarbeiter m
        ON (m1.Bankfiliale_ID = m.Bankfiliale_ID)
WHERE   m.Gehalt = m1.MinGehalt;
      \end{lstlisting}
      \begin{center}
        \begin{small}
          \changefont{pcr}{m}{n}
          \tablefirsthead {
            \multicolumn{1}{l}{\textbf{VORNAME}} &
            \multicolumn{1}{l}{\textbf{NACHNAME}} &
            \multicolumn{1}{r}{\textbf{MINGEHALT}} \\
            \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(r){3-3}
          }
          \tablehead{}
          \tabletail {
          }
          \tablelasttail {
            \multicolumn{3}{l}{\textbf{29 Zeilen ausgew\"ahlt}} \\
          }
          \begin{msoraclesql}
            \begin{supertabular}{llr}
              Johannes & Lehmann & 2000 \\
              Louis & Schmitz & 2000 \\
              Marie & Kipp & 2000 \\
              Martin & Schacke & 1000 \\
              Oliver & Wolf & 1000 \\
              Hans & Schumacher & 1000 \\
              Lena & Herrmann & 1500 \\
            \end{supertabular}
          \end{msoraclesql}
        \end{small}
      \end{center}
      In \beispiel{sql06_10} wird die Inlineview dazu benutzt, um das kleinste Gehalt je Abteilung zu berechnen. Mit Hilfe des Joins wird sie mit der Tabelle \identifier{Mitarbeiter} verkn\"upft, so dass die Attribute \identifier{Vorname} und \identifier{Nachname} angezeigt werden k\"onnen, ohne in Konflikt mit der \GROUPBY-Klausel zu kommen.
      \begin{merke}
        Inlineviews bieten eine gute M\"oglichkeit, um gruppierte und ungruppierte Informationen in einer Abfrage gemeinsam anzeigen zu k\"onnen.
      \end{merke}
    \section{Top N Analysen}
      Die Top N Analyse ist ein Verfahren, bei dem Datens\"atze in ein Ranking eingeordnet werden. Hiermit werden Fragestellungen gekl\"art wie z. B.:
      \begin{itemize}
        \item Die 3 reichsten Kunden anzeigen
        \item Die 5 Mitarbeiter mit den h\"ochsten Geh\"altern auflisten
        \item Die beiden gr\"o\ss{}ten Schuldner der Bank ermitteln
      \end{itemize}
      Beide Datenbankmanagementsysteme beherrschen diese Technik, gehen dabei aber unterschiedliche Wege.
      \subsection{Die Top N Analyse in Oracle}
        Die Top N Analyse funktioniert in Oracle mit Hilfe einer sortierten Inlineview und einer Pseudospalte Namens \identifier{Rownum}.
        \subsubsection{Die Pseudospalte Rownum}
          Mit der Bezeichnung \enquote{Pseudospalte} ist gemeint, dass die \identifier{Rownum} keine tats\"achlich vorhandene Spalte ist, obwohl sie in jeder Abfrage verwendet werden kann. Sie bietet die M\"oglichkeit, die Ergebniszeilen einer Abfrage fortlaufend zu nummerieren (1, 2, 3, \dots, N). Zu beachten ist dabei, dass eine Zeile in einer Oracle-Datenbank keine feste Nummerierung hat. Diese wird erst im Ergebnis einer Abfrage zugeordnet.
          \begin{lstlisting}[language=oracle_sql,caption={Ein einfaches Beispiel f\"ur die Rownum},label=sql06_11]
SELECT   Rownum, Vorname, Nachname
FROM     Mitarbeiter
WHERE    Ort LIKE 'Aschersleben';
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{ROWNUM}} &
                \multicolumn{1}{l}{\textbf{VORNAME}} &
                \multicolumn{1}{l}{\textbf{NACHNAME}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
              }
              \tablehead{}
              \tabletail {
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
              }

              \begin{oraclesql}
                \begin{supertabular}{rll}
                  1 & Max & Winter \\
                  2 & Alexander & Weber \\
                  3 & Leni & D\"uhning \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
          \begin{merke}
            Eine Tabellenzeile hat keine feste Nummerierung. Die Rownum wird w\"ahrend der Abarbeitung einer Abfrage zugewiesen.
          \end{merke}
          Eine weitere, entscheidende Tatsache ist, dass die \identifier{Rownum} erst nach der Abarbeitung der \WHERE-Klausel zugeordnet wird, aber noch bevor Gruppierungen oder Sortierungen ausgef\"uhrt werden. Aus diesem Grund, wird die Abfrage in \beispiel{sql06_12} ein falsches Ergebnis liefern, da die Sortierung h\"atte zuerst stattfinden m\"ussen. Hier werden h\"ochstwahrscheinlich nicht die beiden gr\"o\ss{}ten Guthaben, sondern zwei beliebige Guthaben angezeigt. Welche Zeilen gelistet werden h\"angt davon ab, welche die Abfrage zuerst ermittelt.
          \begin{lstlisting}[language=oracle_sql,caption={Falsche Anwendung der Rownum-Pseudospalte},label=sql06_12]
SELECT   Konto_ID, Guthaben
FROM     Girokonto
WHERE    Rownum < 3
ORDER BY Guthaben DESC;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{KONTO\_ID}} &
                \multicolumn{1}{r}{\textbf{GUTHABEN}} \\
                \cmidrule(r){1-1}\cmidrule(r){2-2}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }

              \begin{oraclesql}
                \begin{supertabular}{rr}
                  1 & 111316,9 \\
                  2 & 96340,2 \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
          \begin{merke}
            Die Rownum wird erst nach Abarbeitung der \WHERE-Klausel, aber noch vor allen Gruppierungen und Sortierungen hinzugef\"ugt.
          \end{merke}
          Ein dritter \enquote{Stolperstein}, in Zusammenhang mit der \identifier{Rownum} ist, dass die \identifier{Rownum} erst inkrementiert wird, wenn sie zugewiesen wurde. Das soll hei\ss{}en, dass die \WHERE-Klausel in \beispiel{sql06_13} ebenfalls fehlschl\"agt, da nach allen Rownums gr\"o\ss{}er eins gefragt wird, ohne das Rownum eins jemals zugewiesen worden w\"are (ohne 1 keine 2).
          \begin{lstlisting}[language=oracle_sql,caption={Erneut eine falsche Anwendung der Rownum},label=sql06_13]
SELECT   Konto_ID, Guthaben
FROM     Girokonto
WHERE    Rownum > 3
ORDER BY Guthaben DESC;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{KONTO\_ID}} &
                \multicolumn{1}{r}{\textbf{GUTHABEN}} \\
                \cmidrule(r){1-1}\cmidrule(r){2-2}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{2}{l}{\textbf{0 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{2}{l}{\textbf{0 Zeilen ausgew\"ahlt}} \\
              }

              \begin{oraclesql}
                \begin{supertabular}{rr}

                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
          Die L\"osung f\"ur diese Probleme besteht nun darin,
          \begin{enumerate}
            \item dass niemals einer der beiden Operatoren \textgreater{} oder \textgreater = in Zusammenhang mit der \identifier{Rownum} verwendet werden sollte und
            \item dass die Abfrage aus \beispiel{sql06_12} in eine Inlineview geschachtelt wird.
          \end{enumerate}
        \subsubsection{Durchf\"uhrung der Top N Analyse}
          Die korrekte Form der Top N Analyse sieht in Oracle wie folgt aus:
          \begin{lstlisting}[language=oracle_sql,caption={Eine korrekt funktionierende Top N Analyse in Oracle},label=sql06_14]
SELECT *
FROM   (SELECT   Konto_ID, Guthaben
        FROM     Girokonto
        ORDER BY Guthaben DESC)
WHERE    Rownum < 3;
        \end{lstlisting}
\clearpage
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{KONTO\_ID}} &
              \multicolumn{1}{r}{\textbf{GUTHABEN}} \\
              \cmidrule(r){1-1}\cmidrule(r){2-2}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \begin{oraclesql}
              \begin{supertabular}{rr}
                362 & 147670,3 \\
                198 & 147264 \\
              \end{supertabular}
            \end{oraclesql}
          \end{small}
        \end{center}
        Im Gegensatz zu \beispiel{sql06_12} werden hier wirklich die beiden gr\"o\ss{}ten Geh\"alter angezeigt. Warum dies so ist, kann durch die Abarbeitungsreihenfolge der Abfrage aus \beispiel{sql06_14} erkl\"art werden.
        \begin{enumerate}
          \item \FROM-Klausel der Inlineview
          \item \SELECT- und \ORDERBY-Klausel der Inlineview
          \item \FROM-Klausel der Hauptabfrage
          \item Zuweisung der \identifier{Rownum}
          \item Ausf\"uhrung der \WHERE-Klausel der Hauptabfrage
          \item \SELECT-Klausel der Hauptabfrage
        \end{enumerate}
        In \beispiel{sql06_14} wird also zuerst nummeriert und dann selektiert.
      \subsection{Die Top N Analyse in MS SQL Server}
        In Microsoft SQL Server existiert eigens der Operator \languagemssql{TOP} zur Durchf\"uhrung von Top N Analysen. Er wird in der \SELECT-Klausel eingesetzt und legt fest, wie viele Zeilen angezeigt werden.
        \begin{lstlisting}[language=ms_sql,caption={Top N Analyse in MS SQL Server},label=sql06_15]
SELECT   TOP (2) Konto_ID, Guthaben
FROM     Girokonto
ORDER BY Guthaben DESC;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{KONTO\_ID}} &
              \multicolumn{1}{l}{\textbf{GUTHABEN}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \begin{mssql}
              \begin{supertabular}{ll}
                362 & 147670,3 \\
                198 & 147264 \\
              \end{supertabular}
            \end{mssql}
          \end{small}
        \end{center}
        Durch die Angabe von \languagemssql{TOP (2)} werden nur die ersten zwei Zeilen der Ergebnismenge angezeigt.
    \section{Pivot-Tabellen}
      Mit MS SQL Server 2005 bzw. Oracle 11g R1 wurden der \languageorasql{PIVOT} und der \languageorasql{UNPIVOT}-Operator eingef\"uhrt. Diese erm\"oglichen die einfache Erstellung von Pivottabellen.
      \begin{merke}
        In einer Pivottabelle werden Daten, die im Zeilenformat vorliegen, im Spaltenformat angezeigt oder umgekehrt. Das \enquote{Drehen} der Daten wird als \enquote{Pivoting} bezeichnet, woraus sich der Name f\"ur diese Tabellen ableitet.
      \end{merke}
      \begin{itemize}
        \item \textbf{PIVOT:} Dreht Daten die zeilenweise vorliegen so, dass eine spaltenweise Darstellung m\"oglich ist.
        \item \textbf{UNPIVOT:} Dreht Daten die spaltenweise vorliegen so, dass eine zeilenweise Darstellung m\"oglich ist.
      \end{itemize}
      \subsection{Der PIVOT-Operator (Oracle)}
        Die M\"oglichkeiten, die der \languageorasql{PIVOT}-Operator bietet, werden anhand des folgenden Beispiels verdeutlicht. F\"ur die Filialen 1 bis 3 sollen die jeweils kleinsten Geh\"alter angezeigt werden.
        \begin{lstlisting}[language=oracle_sql,caption={Die niedrigsten Geh\"alter in den Filialen 1 bis 3},label=sql06_16]
SELECT   Bankfiliale_ID, MIN(Gehalt)
FROM     Mitarbeiter
WHERE    Bankfiliale_ID IN (1, 2, 3)
GROUP BY Bankfiliale_ID;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{BANKFILIALE\_ID}} &
              \multicolumn{1}{r}{\textbf{MIN(GEHALT)}} \\
              \cmidrule(r){1-1}\cmidrule(r){2-2}
            }
            \tablehead{}
            \tabletail {
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
            }
            \begin{oraclesql}
              \begin{supertabular}{rr}
                1 & 2000 \\
                2 & 1000 \\
                3 & 1000 \\
              \end{supertabular}
            \end{oraclesql}
          \end{small}
        \end{center}
        In \beispiel{sql06_16} werden die gew\"unschten Zahlen ermittelt. Die Darstellung der Geh\"alter erfolgt zeilenweise. Sollen die gleichen Zahlen spaltenweise dargestellt werden, wird der \languageorasql{PIVOT}-Operator ben\"otigt. \beispiel{sql06_17} zeigt dessen Einsatz.
        \begin{lstlisting}[language=oracle_sql,caption={Das Ergebnis als Pivottabelle},label=sql06_17]
SELECT *
FROM   (SELECT Gehalt, Bankfiliale_ID
        FROM   Mitarbeiter)
PIVOT  (MIN(Gehalt) AS Gehalt FOR Bankfiliale_ID IN (1, 2, 3));
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{1\_GEHALT}} &
              \multicolumn{1}{r}{\textbf{2\_GEHALT}} &
              \multicolumn{1}{r}{\textbf{3\_GEHALT}} \\
              \cmidrule(r){1-1}\cmidrule(r){2-2}\cmidrule(r){3-3}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }

            \begin{oraclesql}
              \begin{supertabular}{rrr}
                2000 & 1000 & 1000 \\
              \end{supertabular}
            \end{oraclesql}
          \end{small}
        \end{center}
        \subsubsection{Die Syntax des PIVOT-Operators}
          Da das SQL-Statement aus \beispiel{sql06_17} auf den ersten Blick sehr komplex wirkt, ist es notwendig, es an dieser Stelle im Detail zu betrachten.

          F\"ur die Ausf\"uhrung des Pivotings wird in \beispiel{sql06_17} eine Inlineview verwendet.
          \begin{lstlisting}[language=oracle_sql,caption={Die Inlineview},label=sql06_18]
(SELECT Gehalt, Bankfiliale_ID
 FROM   Mitarbeiter)
          \end{lstlisting}
          Diese Inlineview legt fest, welche Spalten im Endergebnis der Abfrage zu sehen sein werden. Sie kann beliebig komplex sein. Der \languageorasql{PIVOT}-Operator verarbeitet im zweiten Schritt die Spalten dieser View weiter.
          \begin{lstlisting}[language=oracle_sql,caption={Der \languageorasql{PIVOT}-Operator},label=sql06_19]
PIVOT  (MIN(Gehalt) AS Gehalt FOR Bankfiliale_ID IN (1, 2, 3));
          \end{lstlisting}
          Die Bedeutung dieses Operators ist:
          \begin{itemize}
            \item Gruppiere nach der Spalte \identifier{Bankfiliale\_ID}.
            \item Zeige \languageorasql{MIN(Gehalt)} f\"ur \languageorasql{Bankfiliale_ID = 1}.
            \item Zeige \languageorasql{MIN(Gehalt)} f\"ur \languageorasql{Bankfiliale_ID = 2}.
            \item Zeige \languageorasql{MIN(Gehalt)} f\"ur \languageorasql{Bankfiliale_ID = 3}.
            \item Benutzte den Alias \enquote{Gehalt} f\"ur den Ausdruck \languageorasql{MIN(Gehalt)}.
          \end{itemize}
        \subsubsection{Spaltenaliase in der FOR-Klausel}
          Die Spaltenbezeichnungen im Ergebnis von \beispiel{sql06_17} werden
          gebildet, in dem der Name der aggregierten Spalte (hier
          \identifier{Gehalt}) mit den Werten der \languageorasql{FOR}-Klausel
          kombiniert werden. Dadurch entstehen die Namen \identifier{1\_GEHALT},
          \identifier{2\_GEHALT} und \identifier{3\_GEHALT}. Auch an dieser
          Stelle sind Aliasnamen m\"oglich.
\clearpage
          \begin{lstlisting}[language=oracle_sql,caption={Die \languageorasql{FOR}-Klausel mit Aliasnamen},label=sql06_20]
SELECT *
FROM   (SELECT Gehalt, Bankfiliale_ID
        FROM   Mitarbeiter)
PIVOT  (MIN(Gehalt) AS Gehalt FOR Bankfiliale_ID
       IN (1 AS "Filiale 1", 2 AS "Filiale 2", 3 AS "Filiale 3"));
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{Filiale 1\_GEHALT}} &
                \multicolumn{1}{r}{\textbf{Filiale 2\_GEHALT}} &
                \multicolumn{1}{r}{\textbf{Filiale 3\_GEHALT}} \\
                \cmidrule(r){1-1}\cmidrule(r){2-2}\cmidrule(r){3-3}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
              }
              \begin{oraclesql}
                \begin{supertabular}{rrr}
                  2000 & 1000 & 1000 \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
        \subsubsection{Zus\"atzliche Spalten zum Pivoting}
          In einer Pivot-Abfrage k\"onnen noch weitere Spalten enthalten sein, die nicht aggregiert oder in der \languageorasql{FOR}-Klausel genutzt werden. Diese Spalten werden als zus\"atzliche Gruppierungsmerkmale genutzt.
          \begin{merke}
            Oracle f\"uhrt eine implizite Gruppierung der Ergebnismenge durch. Diese basiert auf allen nicht gruppierten Spalten, inklusive der Spalten, die in der \languageorasql{FOR}-Klausel genutzt werden.
          \end{merke}
          In \beispiel{sql06_21} wird im ersten Schritt nach dem Geburtsjahr, von 1987 bis 1989 gruppiert. Da diese Spalte in der \languageorasql{FOR}-Klausel verwendet wird, wird diese Information in Spaltenform dargestellt.

          Die Spalte Ort hingegen, wird in Zeilenform angezeigt, da sie nicht in der \languageorasql{FOR}-Klausel angegeben wurde.
          \begin{merke}
            Ob eine Information in Spalten- oder Zeilenform dargestellt wird, h\"angt davon ab, ob die betreffende Spalte in der \languageorasql{FOR}-Klausel gelistet wurde oder nicht.
          \end{merke}
          \begin{lstlisting}[language=oracle_sql,caption={Zus\"atzliche Gruppierungen in einer Pivot-Abfrage},label=sql06_21]
SELECT *
FROM   (SELECT Gehalt, TO_CHAR(Geburtsdatum, 'YYYY') AS Geburtsdatum, Ort
        FROM   Mitarbeiter)
PIVOT  (MIN(Gehalt) AS Gehalt FOR Geburtsdatum IN ('1987', '1988', '1989'));
          \end{lstlisting}
\clearpage
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{l}{\textbf{ORT}} &
                \multicolumn{1}{r}{\textbf{'1987'\_GEHALT}} &
                \multicolumn{1}{r}{\textbf{'1988'\_GEHALT}} &
                \multicolumn{1}{r}{\textbf{'1989'\_GEHALT}} \\
                \cmidrule(l){1-1}\cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule(r){4-4}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{4}{l}{\textbf{25 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{4}{l}{\textbf{25 Zeilen ausgew\"ahlt}} \\
              }
              \begin{oraclesql}
                \begin{supertabular}{lrrr}
                  Calbe &  &  &  \\
                  Pl\"otzkau & 2500 &  &  \\
                  Nienburg &  &  &  \\
                  Bernburg &  &  &  \\
                  Dresden &  &  &  \\
                  Hecklingen &  &  & 3000 \\
                  Borne &  &  & 30000 \\
                  Sch\"onebeck &  &  &  \\
                  Giersleben &  &  &  \\
                  Gera &  &  & 3500 \\
                  M\"unchen &  &  &  \\
                  Egeln &  &  &  \\
                  G\"usten &  &  &  \\
                  Seeland &  &  & 2500 \\
                  Ilberstedt &  &  &  \\
                  B\"ordeaue &  &  &  \\
                  Hamburg & 12000 &  &  \\
                  Alsleben &  &  &  \\
                  Schwerin &  &  &  \\
                  Dessau & 2500 &  &  \\
                  K\"onnern &  &  &  \\
                  Cottbus &  &  &  \\
                  Potsdam & 3500 & 2000 & 2000 \\
                  Aschersleben & 12000 & 88000 & 2000 \\
                  Magdeburg &  &  & 3000 \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
          Die vorangegangenen Beispiele stellen nur einen Einstieg in das Thema \enquote{Pivottabellen} dar. Tats\"achlich ist der \languageorasql{PIVOT}-Operator noch weitaus m\"achtiger.
      \subsection{Der PIVOT-Operator (MS SQL Server)}
        Die M\"oglichkeiten, welche der \languageorasql{PIVOT}-Operator bietet, werden anhand des folgenden Beispiels verdeutlicht. F\"ur die Bankfilialen 1 bis 3 sollen die jeweils kleinsten Geh\"alter angezeigt werden.
        \begin{lstlisting}[language=ms_sql,caption={Die niedrigsten Geh\"alter in den Filialen 1 bis 3},label=sql06_22]
SELECT   Bankfiliale_ID, MIN(Gehalt)
FROM     Mitarbeiter
WHERE    Bankfiliale_ID IN (1, 2, 3)
GROUP BY Bankfiliale_ID;
        \end{lstlisting}
\clearpage
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{Bankfiliale\_ID}} &
              \multicolumn{1}{l}{\textbf{(Kein Spaltenname)}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{2}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{3 Zeilen ausgew\"ahlt}} \\
            }
            \begin{mssql}
              \begin{supertabular}{ll}
                1 & 2000 \\
                2 & 1000 \\
                3 & 1000 \\
              \end{supertabular}
            \end{mssql}
          \end{small}
        \end{center}
        In \beispiel{sql06_22} werden die gew\"unschten Zahlen ermittelt. Die Darstellung der Geh\"alter erfolgt zeilenweise. Sollen die gleichen Zahlen spaltenweise dargestellt werden, wird der \languageorasql{PIVOT}-Operator ben\"otigt. \beispiel{sql06_23} zeigt dessen Einsatz.
        \begin{lstlisting}[language=ms_sql,caption={Das Ergebnis als Pivottabelle},label=sql06_23]
SELECT *
FROM   (SELECT Gehalt, Bankfiliale_ID
        FROM   Mitarbeiter) AS Sourcetable
PIVOT  (MIN(Gehalt)
        FOR Bankfiliale_ID IN ([1], [2], [3])
        ) AS Pivottable;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{1}} &
              \multicolumn{1}{l}{\textbf{2}} &
              \multicolumn{1}{l}{\textbf{3}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{3}{l}{\textbf{1 Zeile ausgew\"ahlt}} \\
            }

            \begin{mssql}
              \begin{supertabular}{lll}
                2000 & 1000 & 1000 \\
              \end{supertabular}
            \end{mssql}
          \end{small}
        \end{center}
        \subsubsection{Die Syntax des PIVOT-Operators}
          Da das SQL-Statement aus \beispiel{sql06_23} auf den ersten Blick sehr komplex wirkt, ist es notwendig, es an dieser Stelle im Detail zu betrachten.

          F\"ur die Ausf\"uhrung des Pivotings wird in \beispiel{sql06_23} eine Inlineview verwendet.
          \begin{lstlisting}[language=ms_sql,caption={Die Inlineview},label=sql06_24]
(SELECT Gehalt, Bankfiliale_ID
 FROM   Mitarbeiter) AS Sourcetable
          \end{lstlisting}
          Diese Inlineview legt fest, welche Spalten im Endergebnis der Abfrage zu sehen sein werden. Sie kann beliebig komplex sein. Der \languageorasql{PIVOT}-Operator verarbeitet im zweiten Schritt die Spalten dieser View weiter.
          \begin{lstlisting}[language=ms_sql,caption={Der \languageorasql{PIVOT}-Operator},label=sql06_25]
PIVOT  (MIN(Gehalt) FOR Bankfiliale_ID IN ([1], [2], [3])) AS Pivottable;
          \end{lstlisting}
\clearpage
          Die Bedeutung dieses Operators ist:
          \begin{itemize}
            \item Gruppiere nach der Spalte \identifier{Bankfiliale\_ID}.
            \item Zeige \languagemssql{MIN(Gehalt)} f\"ur \languagemssql{Bankfiliale_ID = 1}.
            \item Zeige \languagemssql{MIN(Gehalt)} f\"ur \languagemssql{Bankfiliale_ID = 2}.
            \item Zeige \languagemssql{MIN(Gehalt)} f\"ur \languagemssql{Bankfiliale_ID = 3}.
          \end{itemize}
          F\"ur eine Pivotabfrage gelten in MS SQL Server folgende Syntaxregeln:
          \begin{itemize}
            \item F\"ur die Quell-View muss zwingend ein Aliasname vergeben werden. In \beispiel{sql06_23} ist dies \enquote{Sourcetable}
            \item F\"ur die Pivottabelle muss zwingend ein Aliasname vergeben
werden. In \beispiel{sql06_23} ist dies \enquote{Pivottable}
						\item Es d\"urfen in der Pivottabelle keine
Aliasnamen vergeben werden.
            \item Die Werte in der \languagemssql{FOR}-Klausel m\"ussen in eckigen Klammern stehen.
          \end{itemize}
        \subsubsection{Zus\"atzliche Spalten zum Pivoting}
          In einer Pivot-Abfrage k\"onnen noch weitere Spalten enthalten sein, die nicht aggregiert oder in der \languagemssql{FOR}-Klausel genutzt werden. Diese Spalten werden als zus\"atzliche Gruppierungsmerkmale genutzt.
          \begin{merke}
            MS SQL Server f\"uhrt eine implizite Gruppierung der Ergebnismenge durch. Diese basiert auf allen nicht gruppierten Spalten, inklusive der Spalten, die in der \languagemssql{FOR}-Klausel genutzt werden.
          \end{merke}
          In \beispiel{sql06_26} wird im ersten Schritt nach dem Geburtsjahr, von 1987 bis 1989 gruppiert. Da diese Spalte in der \languagemssql{FOR}-Klausel verwendet wird, wird diese Information in Spaltenform dargestellt.

          Die Spalte Ort hingegen, wird in Zeilenform angezeigt, da sie nicht in der \languagemssql{FOR}-Klausel angegeben wurde.
          \begin{merke}
            Ob eine Information in Spalten- oder Zeilenform dargestellt wird, h\"angt davon ab, ob die betreffende Spalte in der \languagemssql{FOR}-Klausel gelistet wurde oder nicht.
          \end{merke}
\clearpage
          \begin{lstlisting}[language=ms_sql,caption={Zus\"atzliche Gruppierungen in einer Pivot-Abfrage},label=sql06_26]
SELECT *
FROM   (SELECT Gehalt, DATEPART(YEAR, Geburtsdatum) AS Geburtsdatum, Ort
        FROM   Mitarbeiter) AS Sourcetable
PIVOT  (MIN(Gehalt)
        FOR Geburtsdatum IN ([1987], [1988], [1989])) AS Pivottable;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{l}{\textbf{Ort}} &
                \multicolumn{1}{l}{\textbf{1987}} &
                \multicolumn{1}{l}{\textbf{1988}} &
                \multicolumn{1}{l}{\textbf{1989}} \\
                \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{4}{l}{\textbf{25 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{4}{l}{\textbf{25 Zeilen ausgew\"ahlt}} \\
              }
              \begin{mssql}
                \begin{supertabular}{llll}
                  Calbe &  &  &  \\
                  Pl\"otzkau & 2500 &  &  \\
                  Nienburg &  &  &  \\
                  Bernburg &  &  &  \\
                  Dresden &  &  &  \\
                  Hecklingen &  &  & 3000 \\
                  Borne &  &  & 30000 \\
                  Sch\"onebeck &  &  &  \\
                  Giersleben &  &  &  \\
                  Gera &  &  & 3500 \\
                  M\"unchen &  &  &  \\
                  Egeln &  &  &  \\
                  G\"usten &  &  &  \\
                  Seeland &  &  & 2500 \\
                  Ilberstedt &  &  &  \\
                  B\"ordeaue &  &  &  \\
                  Hamburg & 12000 &  &  \\
                  Alsleben &  &  &  \\
                  Schwerin &  &  &  \\
                  Dessau & 2500 &  &  \\
                  K\"onnern &  &  &  \\
                  Cottbus &  &  &  \\
                  Potsdam & 3500 & 2000 & 2000 \\
                  Aschersleben & 12000 & 88000 & 2000 \\
                  Magdeburg &  &  & 3000 \\
                \end{supertabular}
              \end{mssql}
            \end{small}
          \end{center}
          Die vorangegangenen Beispiele stellen nur einen Einstieg in das Thema \enquote{Pivottabellen} dar. Tats\"achlich ist der \languageorasql{PIVOT}-Operator noch weitaus m\"achtiger.
