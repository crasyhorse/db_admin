  \chapter{Data Definition Language}
    \setcounter{page}{1}\kapitelnummer{chapter}
    \minitoc
\newpage
      Die Data definition language ist der Teil von SQL, der es erm\"oglicht, Objekte in der Datenbank zu erstellen und zu verwalten. DDL besteht im wesentlichen aus den vier Befehlen:
      \begin{itemize}
        \item \textbf{CREATE}: Erstellen von Objekten
        \item \textbf{ALTER}: \"Andern von Objekten
        \item \textbf{DROP}: Objekte l\"oschen
        \item \textbf{TRUNCATE}: Leeren von Tabellen.
      \end{itemize}
      Der Begriff des \enquote{Objekts} bezieht sich, je nach DBMS, auf die Unterschiedlichsten Dinge:
      \begin{itemize}
        \item Tabellen
        \item Views
        \item Indizes
        \item Sequenzen
        \item PL/SQL oder T-SQL Prozeduren und Funktionen
      \end{itemize}
      \dots und vieles mehr. Welche M\"oglichkeiten dem Anwender bei der Erstellung eines Objekts geboten werden, ist stark abh\"angig vom jeweiligen DBMS.
    \section{Tabellen erstellen und verwalten}
      \subsection{Namenskonventionen und Einschr\"ankungen}
        Bevor n\"aher auf die Namenskonventionen f\"ur Objekte eingegangen wird, m\"ussen an dieser Stelle zuerst einige Fachbegriffe gekl\"art werden.
        \begin{itemize}
          \item \textbf{Bezeichner}: Namen f\"ur Objekte (Tabellen, Spalten, Views, usw.) hei\ss{}en im Fachjargon Bezeichner.
          \item \textbf{Umschlossene Bezeichner}: Sind Bezeichner, die in Anf\"uhrungszeichen \char34{} eingeschlossen sind
          \item \textbf{Reservierte W\"orter}: Begriffe die in SQL eine bestimmte Bedeutung haben, z. B. \SELECT , \WHERE , usw.
          \item \textbf{Namensraum}: Logische Einteilung f\"ur Objektnamen. Bezeichner m\"ussen innerhalb eines Namensraumes eindeutig sein.
        \end{itemize}
        \tabelle{createtablerestrictions} listet die wichtigsten
        Einschr\"ankungen auf, die f\"ur Bezeichner in beiden DBMS gelten.
        \begin{center}
          \tablecaption{Einschr\"ankungen f\"ur Bezeichner}
          \label{createtablerestrictions}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{oracle_11g}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{ms_sql}}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Einschr\"ankung}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{oracle_11g}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{ms_sql}}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail{
              \hline
            }
            \begin{supertabular}{|l|p{5.5cm}|p{5.5cm}|}
              \textbf{Bezeichnerl\"ange} & 30 & 128\\
              \hline
              \textbf{Reservierte W\"orter} & Bezeichner k\"onnen keine reservierten W\"orter sein, es sei denn, sie sind in Anf\"uhrungszeichen \char34{} eingeschlossen. & Bezeichner k\"onnen keine reservierten W\"orter sein, es sei denn, sie sind in Anf\"uhrungszeichen \char34{} eingeschlossen. \\
              \hline
              \textbf{Namensgebung} & Wenn Bezeichner nicht in Anf\"uhrungszeichen (\char34{}) einschlossen sind, m\"ussen diese mit einem Buchstaben beginnen. F\"ur umschlossene Bezeichner gilt dies nicht. & Wenn Bezeichner nicht in Anf\"uhrungszeichen (\char34{}) oder ([]) einschlossen sind, m\"ussen diese mit einem Buchstaben, \_, @ oder \# beginnen. F\"ur umschlossene Bezeichner gilt dies nicht. \\
              \hline
              \textbf{G\"ultige Zeichen} & Nicht umschlossene Bezeichner k\"onnen nur aus den Buchstaben a-z und A-Z, den Ziffern 0-9, sowie \_, \$ und \# bestehen. F\"ur umschlossene Bezeichner gilt, dass dort alle Zeichen, auch Leerzeichen vorkommen k\"onnen. & Nicht umschlossene Bezeichner k\"onnen nur aus den Buchstaben a-z und A-Z, den Ziffern 0-9, sowie @, \$, \_ und \# bestehen. F\"ur umschlossene Bezeichner gilt, dass dort alle Zeichen, auch Leerzeichen vorkommen k\"onnen. \\
              \hline
              \textbf{Namensgleichheit} & Zwei Datenbankobjekte im gleichen Namensraum m\"ussen unterschiedliche Namen haben.  & Bezeichner m\"ussen innerhalb eines Schemas eindeutig sein.\\
              \hline
              \textbf{Casesensitivit\"at} & Nicht umschlossene Bezeichner sind nicht Casesensitiv. Bezeichner die mit (\char34{}) oder ([]) umschlossen sind, sind Casesensitiv. & Bezeichner die mit (\char34{}) oder ([]) umschlossen sind, sind nicht Casesensitiv. \\
            \end{supertabular}
          \end{small}
        \end{center}
        \begin{merke}
          Damit umschlossene Bezeichner in SQL Server 2008 R2 genutzt werden k\"onnen, muss die Option \textit{QUOTED\_IDENTIFIER} den Wert \textit{ON} haben. Dieser kann n\"otigenfalls mit \languagemssql{SET QUOTED_IDENTIFIER ON} gesetzt werden.
        \end{merke}
        Die folgenden Internetliteraturhinweise liefern weitere Informationen.
        \begin{literaturinternet}
          \item \cite{i27561}
          \item \cite{ms187879}
        \end{literaturinternet}
\clearpage
      \subsection{CREATE TABLE - Tabellen erstellen}
        Sowohl in Oracle als auch in SQL Server werden Tabellen mit Hilfe des
Kommandos \languageorasql{CREATE TABLE} erstellt. Die grundlegende,
SQL-Standardkonforme Syntax f\"ur \languageorasql{CREATE TABLE} lautet:
        \begin{lstlisting}[language=oracle_sql,caption={Die Syntax der CREATE TABLE-Anweisung},label=sql08_01]
CREATE TABLE <tabellen_name> (
  <spaltenbezeichner 1> <datentyp>,
  <spaltenbezeichner 2> <datentyp>,
  ...,
  <spaltenbezeichner n> <datentyp>
);
        \end{lstlisting}
        \begin{center}
          \tablecaption{Die CREATE TABLE-Anweisung}
          \label{createtablesyntax}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \begin{supertabular}{|l|p{9.45cm}|}
              CREATE TABLE <Tabellenname> & Diese Klausel leitet das Erstellen der Tabelle ein. F\"ur den Tabellennamen gelten die in \tabelle{createtablerestrictions} angegebenen Beschr\"ankungen. \\
              \hline
              <Spaltenbezeichner> <Datentyp> & Jede Tabellenspalte wird durch einen Bezeichner/Name und einen Datentyp repr\"asentiert. Mit Hilfe des Namens kann die Spalte sp\"ater angesprochen werden und der Datentyp legt den Wertebereich der Spalte fest. Je nach DBMS gelten auch hier unterschiedliche Einschr\"ankungen. \\
            \end{supertabular}
          \end{small}
        \end{center}
        \beispiel{sql08_02} zeigt ein einfaches \languageorasql{CREATE TABLE}-Statement.
        \begin{lstlisting}[language=oracle_sql,caption={Eine einfache CREATE TABLE-Anweisung in Oracle},label=sql08_02]
CREATE TABLE Aktie (
  Aktie_ID  NUMBER,
  Name      VARCHAR2(25),
  WKN       NUMBER,
  ISIN      VARCHAR2(12)
);
        \end{lstlisting}
        \begin{lstlisting}[language=ms_sql,caption={Das gleiche in MS SQL Server},label=sql08_03]
CREATE TABLE Aktie (
  Aktie_ID  NUMERIC,
  Name      VARCHAR(25),
  WKN       NUMERIC,
  ISIN      VARCHAR(12)
);
        \end{lstlisting}
        Es wird eine Tabelle namens \identifier{Aktie}, mit den Spalten \identifier{Aktie\_ID}, \identifier{Name}, \identifier{WKN} und \identifier{ISIN} angelegt.

        Zur besseren Umsetzung der Beispiele in den folgenden Abschnitten, werden nun einige Datens\"atze in die Tabelle \identifier{Aktie} eingef\"ugt.
        \begin{lstlisting}[language=oracle_sql,caption={Beispieldatens\"atze},label=sql08_04]
INSERT INTO Aktie
VALUES (1, 'Henker Co KG', 1236547, 'DE0006800002');

INSERT INTO Aktie
VALUES (2, 'AD and D', 43116589, 'DE0002300023');

COMMIT;
        \end{lstlisting}
      \subsection{CREATE TABLE AS... (CTAS)}
        Die Abk\"urzung \enquote{CTAS} steht f\"ur \languageorasql{CREATE TABLE AS} und meint ein \languageorasql{CREATE TABLE} mit Unterabfrage. Mit Hilfe von CTAS k\"onnen bestehende Tabellen teilweise oder ganz kopiert werden. \beispiel{sql08_05} zeigt, wie in Oracle eine vollst\"andige Kopie der Tabelle \identifier{Aktie} angefertigt wird.
        \begin{lstlisting}[language=oracle_sql,caption={Oracle - CREATE TABLE AS (CTAS)},label=sql08_05]
CREATE TABLE Aktie_Kopie
AS
  SELECT *
  FROM   Aktie;
        \end{lstlisting}
          Es wird eine Tabelle namens \identifier{Aktie\_Kopie} erstellt. Diese erh\"alt die komplette Struktur und den gesamten Inhalt der Tabelle \identifier{Aktie}.

          In Microsoft SQL Server kennt das \languagemssql{CREATE TABLE}-Statement keine M\"oglichkeit, eine Unterabfrage zu nutzen. Hier muss stattdessen das \languagemssql{SELECT INTO}-Statement genutzt werden.
        \begin{lstlisting}[language=ms_sql,caption={MS SQL Server - SELECT INTO},label=sql08_06]
SELECT *
INTO   Aktie_Kopie
FROM   Aktie;
        \end{lstlisting}
        Die Auswirkungen bleiben die gleichen, wie unter Oracle mit CTAS.
        \begin{merke}
          Microsoft SQL Server kennt das \languagemssql{CREATE TABLE AS}-Statement nicht. Es muss stattdessen das \languagemssql{SELECT INTO}-Statement genutzt werden. Die Auswirkungen von \languagemssql{CREATE TABLE AS} und \languagemssql{SELECT INTO} sind gleich.
        \end{merke}
      \subsection{ALTER TABLE - Tabellen ver\"andern}
        Mit Hilfe der \languageorasql{ALTER TABLE}-Anweisung k\"onnen bestehende Tabellendefinition ver\"andert werden. Dies betrifft z. B.:
        \begin{itemize}
          \item Das Hinzuf\"ugen neuer Spalten zu einer Tabelle.
          \item Das L\"oschen von Spalten.
          \item Das Umbenennen von Spalten.
          \item Das \"Andern des Datentyps einer Spalte.
          \item \"Andern der Gr\"o\ss e einer Spalte.
          \item Das Hinzuf\"ugen, \"andern und l\"oschen eines Standardwerts.
          \item Das Hinzuf\"ugen und L\"oschen von Constraints (siehe \abschnitt{constraints1})
        \end{itemize}
        \subsubsection{Eine neue Spalte an eine Tabelle anf\"ugen}
          In beiden DBMS gibt es, zum Hinzuf\"ugen einer Spalte zu einer Tabelle, die \lstinline{ADD}-Klausel des \languageorasql{ALTER TABLE}-Kommandos. In \beispiel{sql08_07}, wird der Tabelle \identifier{Aktie} eine neue Spalte namens \identifier{Herkunft} hinzugef\"ugt.
          \begin{lstlisting}[language=oracle_sql,caption={Oracle - Tabellenspalte hinzuf\"ugen},label=sql08_07]
ALTER TABLE Aktie
ADD Herkunft VARCHAR2(25);
          \end{lstlisting}
          In SQL Server unterscheidet sich dieses Statement nur durch den Datentyp.
          \begin{lstlisting}[language=ms_sql,caption={MS SQL Server - Tabellenspalte hinzuf\"ugen},label=sql08_08]
ALTER TABLE Aktie
ADD Herkunft VARCHAR(25);
          \end{lstlisting}
          \begin{merke}
            Wird eine neue Spalte an eine Tabelle angef\"ugt, haben alle Zellen dieser Spalte den Wert NULL, es sei den, es wird ein Standardwert f\"ur diese Spalte definert. In diesem Falle f\"ullt Oracle die Spalte mit dem Standardwert auf. SQL Server tut dies nicht.
          \end{merke}
           \beispiel{sql08_09} und \beispiel{sql08_10} zeigen, wie sich Oracle und MS SQL Server verhalten, wenn eine neue Spalte, mit einem Standardwert, hinzugef\"ugt wird. Die Spalte \identifier{Herkunft} wird mit dem Standardwert \enquote{Deutschland} an die Tabelle \identifier{Aktie} angef\"ugt. In Oracle werden dann automatisch alle bereits vorhandenen Zeilen mit dem neuen Standardwert aufgef\"ullt. In SQL Server wird dies nicht der Fall sein.
\clearpage
          \begin{lstlisting}[language=oracle_sql,caption={Tabellenspalte mit Standardwert hinzuf\"ugen in Oracle},label=sql08_09]
ALTER TABLE Aktie
ADD Herkunft VARCHAR2(25) DEFAULT 'Deutschland';

SELECT *
FROM   Aktie;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{r}{\textbf{AKTIE\_ID}} &
                \multicolumn{1}{l}{\textbf{NAME}} &
                \multicolumn{1}{l}{\textbf{WKN}} &
                \multicolumn{1}{l}{\textbf{ISIN}} &
                \multicolumn{1}{l}{\textbf{HERKUNFT}} \\
                \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}\cmidrule(l){5-5}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }
              \begin{oraclesql}
                \begin{supertabular}{rllll}
                  1 & Henker Co KG & 1236547 & DE0006800002 & Deutschland \\
                  2 & AD and D & 43116589 & DE0002300023 & Deutschland \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}

          Wird das gleiche Experiment in MS SQL Server durchgef\"uhrt, zeigt sich das die Spalte \identifier{Herkunft} nicht automatisch aufgef\"ullt wird.
          \begin{lstlisting}[language=ms_sql,caption={Tabellenspalte mit Standardwert hinzuf\"ugen in SQL Server},label=sql08_10]
ALTER TABLE Aktie
ADD Herkunft VARCHAR(25) DEFAULT 'Deutschland';

SELECT *
FROM   Aktie;
          \end{lstlisting}
          \begin{center}
            \begin{small}
              \changefont{pcr}{m}{n}
              \tablefirsthead {
                \multicolumn{1}{l}{\textbf{AKTIE\_ID}} &
                \multicolumn{1}{l}{\textbf{NAME}} &
                \multicolumn{1}{l}{\textbf{WKN}} &
                \multicolumn{1}{l}{\textbf{ISIN}} &
                \multicolumn{1}{l}{\textbf{HERKUNFT}} \\
                \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}\cmidrule(l){5-5}
              }
              \tablehead{}
              \tabletail {
                \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }
              \tablelasttail {
                \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
              }
              \begin{oraclesql}
                \begin{supertabular}{lllll}
                  1 & Henker Co KG & 1236547 & DE0006800002 &  NULL \\
                  2 & AD and D & 43116589 & DE0002300023 & NULL \\
                \end{supertabular}
              \end{oraclesql}
            \end{small}
          \end{center}
        \subsubsection{Spalten vergr\"o\ss{}ern und verkleinern}
          Es besteht die M\"oglichkeit, die Definition einer Spalte nachtr\"aglich zu ver\"andern. Dabei k\"onnen verschiedene Dinge, wie z. B. der Spaltendatentyp oder der Standardwert einer Spalte ge\"andert werden. Um eine solche \"Anderung durchzuf\"uhren, kennt das \languageorasql{ALTER TABLE}-Kommando unter Oracle die \languageorasql{MODIFY}-Klausel und unter SQL Server die \languagemssql{ALTER COLUMN}-Klausel. Hierzu einige Beispiele.

          In \beispiel{sql08_11} wird die Breite der Spalte \identifier{Herkunft} in der Tabelle \identifier{Aktie} ver\"andert.
          \begin{lstlisting}[language=oracle_sql,caption={Anpassen der Spaltenl\"ange in Oracle},label=sql08_11]
ALTER TABLE Aktie
MODIFY Herkunft VARCHAR2(30);
          \end{lstlisting}
\clearpage
          Eine Vergr\"o\ss erung stellt prinzipiell niemals ein Problem dar. Schwieriger wird es hingegen, wenn eine Spalte verkleinert werden muss. In Oracle geht das nur dann, wenn die Inhalte der Spalte kleiner sind als die neue Spaltengr\"o\ss{}e. Anderenfalls antwortet Oracle mit der in \beispiel{sql08_12} sichtbaren Fehlermeldung:
          \begin{lstlisting}[language=oracle_sql,caption={Fehlermeldung beim verkleinern einer Spalte in Oracle},label=sql08_12]
MODIFY Herkunft VARCHAR2(15)
       *
FEHLER in Zeile 2:
ORA-01441: Spaltenlaenge kann nicht vermindert werden, weil ein Wert zu gross
ist
          \end{lstlisting}
          \begin{merke}
            Eine Tabellenspalte kann in Oracle nur auf die Gr\"o\ss{}e des gr\"o\ss{}ten darin enthaltenden Werts verkleinert werden. In SQL Server kann eine Tabellenspalte auch mit Inhalt verkleinert werden.
          \end{merke}
          Bei SQL Server muss lediglich die \languageorasql{MODIFY}-Klausel durch die \languagemssql{ALTER COLUMN}-Klausel ersetzt werden.
          \begin{lstlisting}[language=ms_sql,caption={Anpassen der Spaltenl\"ange in SQL Server},label=sql08_13]
ALTER TABLE Aktie
ALTER COLUMN Herkunft VARCHAR(30);
          \end{lstlisting}
        \subsubsection{\"Andern des Datentyps}
          Mit Hilfe der \languageorasql{MODIFY}-Klausel kann nicht nur die Gr\"o\ss e einer Spalte ver\"andert werden, sondern auch der Datentyp. In \beispiel{sql08_14} wird der Datentyp der Spalte \identifier{WKN} von \languageorasql{NUMBER} auf \languageorasql{VARCHAR2}, bzw. von \languagemssql{NUMERIC} auf \languagemssql{VARCHAR} ge\"andert.
          \begin{lstlisting}[language=oracle_sql,caption={\"Andern des Datentyps},label=sql08_14]
ALTER TABLE Aktie
MODIFY WKN VARCHAR2(10);
          \end{lstlisting}
          In SQL Server sieht das \"Andern des Datentyps einer Spalte sehr \"ahnlich aus.
          \begin{lstlisting}[language=ms_sql,caption={\"Andern des Datentyps},label=sql08_15]
ALTER TABLE Aktie
ALTER COLUMN WKN VARCHAR(10);
          \end{lstlisting}
          \begin{merke}
            Eine Tabellenspalte muss in Oracle leer sein, damit ihr Datentyp ver\"andert werden kann. In SQL Server kann der Datentyp einer Spalte auch mit Inhalt ver\"andert werden.
          \end{merke}
\clearpage
        \subsubsection{Einen Defaultvalue hinzuf\"ugen}
          Eine weitere Aktion die mit \languageorasql{MODIFY} bzw. \languagemssql{ALTER COLUMN} m\"oglich ist, ist das Hinzuf\"ugen, \"andern oder entfernen eines Standardwertes bei einer Tabellenspalte. In \beispiel{sql08_16} wird in Oracle der Standardwert der Spalte \identifier{Herkunft} von \enquote{Deutschland} auf \enquote{USA} ge\"andert.
          \begin{lstlisting}[language=oracle_sql,caption={Einen Standardwert \"andern},label=sql08_16]
ALTER TABLE Aktie
MODIFY Herkunft DEFAULT 'USA';
          \end{lstlisting}
          Mit der gleichen Anweisung kann der Standardwert eine Spalte, unter Oracle, nicht nur ge\"andert sondern auch hinzugef\"ugt werden. Das L\"oschen des Standardwertes geschieht, indem NULL als Standardwert zugewiesen wird.
          \begin{lstlisting}[language=oracle_sql,caption={Standardwert hinzuf\"ugen},label=sql08_17]
ALTER TABLE Aktie
MODIFY Herkunft DEFAULT NULL;
          \end{lstlisting}
          Bei SQL Server ist das L\"oschen eines Standardwerts anders als bei
          Oracle. In SQL Server wird ein Standardwert als sogenanntes
          Constraint\footnote{constraint engl. = Einschr\"ankung} gehandhabt.
          Deshalb wird diese Aktion zu einem sp\"ateren Zeitpunkt in
          \abschnitt{sqlserverdefaultconstraint} behandelt.
          \begin{merke}
            Wird in Oracle mit Hilfe \languageorasql{ADD}-Klausel eine Spalte
            mit Standardwert hinzuge\"ugt, werden alle NULL-Werte in der
            gleichen Spalte mit dem Standardwert aufgef\"ullt. Wird die Spalte
            dagegen mit der \languageorasql{MODIFY}-Klausel, nachtr\"aglich mit
            einem Default-Wert ausgestattet, bleiben alle NULL-Werte erhalten!
          \end{merke}

				\subsubsection{Tabellenspalten umbenennen}
          Es ist m\"oglich, bestehende Spalten umzubenennen. Daf\"ur wird in
          Oracle die \languageorasql{RENAME COLUMN}-Klausel des
          \languageorasql{ALTER TABLE}-Kommandos verwendet. In Microsoft SQL
          Server gibt es hierf\"ur eine gespeicherte Hilfsprozedur, welche das
          Umbenennen \"ubernimmt. Der neue Spaltenname muss innerhalb der
          Tabelle eindeutig sein und es d\"urfen keine anderen Operationen
          zusammen mit dem Umbenennen geschehen.
          \begin{lstlisting}[language=oracle_sql,caption={Tabellenspalte umbenennen in Oracle},label=sql08_18]
ALTER TABLE Aktie
RENAME COLUMN Name TO Bezeichnung;
          \end{lstlisting}
          \begin{lstlisting}[language=ms_sql,caption={Tabellenspalte umbenennen in SQL Server},label=sql08_19, emphstyle={[9]\color{red}},emph={[9]sp_rename}]
EXEC sp_rename 'Aktie.Name', 'Bezeichnung', 'COLUMN'
          \end{lstlisting}
          \begin{merke}
            F\"ur das Umbenennen von Objekten ist in SQL Server die gespeicherte
            Hilfsprozedur \languagemssql{sp\_rename} zust\"andig.
          \end{merke}
          Zu beachten ist, dass das Umbenennen einer Spalte Auswirkungen auf
          abh\"angige Objekte wie z. B. Views oder Trigger haben kann und
          deshalb mit gr\"o\ss ter Vorsicht durchzuf\"uhren ist.
        \subsubsection{Tabellenspalten l\"oschen}
          Tabellenspalten, die nicht mehr ben\"otigt werden, k\"onnen jeder
          Zeit gel\"oscht werden. Auf diese einfache Art und Weise kann
          Speicherplatz zu weiteren Nutzung freigegeben werden. Allgemein gilt
          als Einschr\"ankung beim L\"oschen einer Tabellenspalte:
          \begin{itemize}
            \item Die letzte Spalte in einer Tabelle kann nicht gel\"oscht
            werden. Es muss dann die gesamte Tabelle gel\"oscht werden.
          \end{itemize}
          F\"ur Oracle gilt zus\"atzlich:
          \begin{itemize}
            \item Ein normaler Nutzer kann keine Spalten aus einer Tabelle
            l\"oschen, die dem Nutzer sys geh\"ort.
          \end{itemize}
          \beispiel{sql08_19} zeigt das L\"oschen einer Tabellenspalte in Oracle und SQL Server.
          \begin{lstlisting}[language=oracle_sql, caption={Tabellenspalte
          l\"oschen},label=sql08_20]
ALTER TABLE Aktie
DROP COLUMN WKN;
          \end{lstlisting}
      \subsection{DROP TABLE - Tabellen l\"oschen}
        Eine nicht mehr ben\"otigte Tabelle, wird in Oracle und SQL Server mit dem \languageorasql{DROP TABLE}-Kommando gel\"oscht.
        \begin{itemize}
          \item Alle verkn\"upften Indizes und Trigger werden mitgel\"oscht.
          \item Alle abh\"angigen Views bleiben bestehen und werden ung\"ultig.
        \end{itemize}
        Das folgende Beispiel l\"oscht die Tabelle \identifier{Aktie}.
        \begin{lstlisting}[language=oracle_sql,caption={Eine Tabelle l\"oschen},label=sql08_21]
DROP TABLE Aktie;
        \end{lstlisting}
      \subsection{TRUNCATE TABLE - Tabellen leeren}
        Eine Tabelle kann mit \languageorasql{TRUNCATE TABLE} geleert werden. Die Tabelle selbst bleibt dabei erhalten. Um eine Tabelle zu leeren, gibt es drei M\"oglichkeiten:
        \begin{itemize}
          \item Das DML-Statement \languageorasql{DELETE}
          \item Das L\"oschen der Tabelle mit \languageorasql{DROP TABLE} und neu erstellen mit \languageorasql{CREATE TABLE}
          \item Das DDL-Statement \languageorasql{TRUNCATE}
        \end{itemize}
        \subsubsection{Den Tabelleninhalt mit DELETE l\"oschen}
          Es k\"onnen alle Zeilen einer Tabelle mit dem DML-Kommando \languageorasql{DELETE} gel\"oscht werden.
          \begin{lstlisting}[language=oracle_sql,caption={Zeilen mit DELETE l\"oschen},label=sql08_22]
DELETE FROM Aktie;
          \end{lstlisting}
          Bei einer gro\ss en Tabelle werden hierf\"ur sehr viele
          Systemressourcen ben\"otigt (CPU, RAM, usw.). Des Weiteren kann es
          passieren, dass beim L\"oschen von Zeilen, Trigger ausgel\"ost werden.
          \begin{merke}
            Der Speicherplatz, der durch die Tabelle vor dem L\"oschen belegt
            wurde, bleibt bei der Verwendung von \languageorasql{DELETE} belegt.
          \end{merke}
          Einziger Vorteil ist, dass mit der \languageorasql{DELETE}-Klausel die
          Zeilen ausgew\"ahlt werden k\"onnen, die gel\"oscht werden sollen.
        \subsubsection{Die Tabelle l\"oschen und neu erstellen}
          \label{dropandrecreatetable}
          Eine Tabelle kann gel\"oscht und mit \languageorasql{CREATE TABLE} neu
          erstellt werden. Dabei gehen alle mit dieser Tabelle verbundenen
          Indizes, Integrit\"ats Constraints und Trigger verloren und alle von
          der Tabelle abh\"angigen Objekte werden ung\"ultig.
        \subsubsection{Eine Tabelle mit TRUNCATE leeren}
          Um alle Zeilen einer Tabelle zu l\"oschen kann das \languageorasql{TRUNCATE}-Statement verwendet werden.
          \begin{lstlisting}[language=oracle_sql, caption={Zeilen mit TRUNCATE
          abschneiden},label=sql08_23]
TRUNCATE TABLE Aktie;
          \end{lstlisting}
\clearpage
          \begin{merke}
            In Oracle produziert das \languageorasql{TRUNCATE}-Statement, wie
            alle DDL-Statements, automatisch ein \languageorasql{COMMIT}, d. h.
            es kann nicht r\"uckg\"angig gemacht werden. In SQL Server ist das
            Zur\"uckrollen eines \languagemssql{TRUNCATE}-Statements m\"oglich.
          \end{merke}

          \begin{merke}
            Der Speicherplatz, der durch die Tabelle vor dem L\"oschen belegt
            wurde, wird bei der Verwendung von \languageorasql{TRUNCATE},
            freigegeben.
          \end{merke}
    \section{Views erstellen verwalten}
      \subsection{Was sind Views?}
        Bei der t\"aglichen Arbeit mit einer Datenbank treten h\"aufig immer wiederkehrende \SELECT-Statements auf. Dies kann z. B. deshalb sein, weil ein Nutzer immer wieder die gleiche Sicht (gleiche Spalten, gleiche Filterbedingung) auf die Daten einer Tabelle ben\"otigt.
        \begin{merke}
          Eine View ist eine genau definierte Sicht auf eine bestimmte Datenmenge.
        \end{merke}
      \subsection{Views erstellen}
        Views werden mit dem \languageorasql{CREATE VIEW}-Kommando erstellt. Die Syntax f\"ur \languageorasql{CREATE VIEW} sieht wie folgt aus:
        \begin{lstlisting}[language=oracle_sql,caption={Die Syntax von CREATE VIEW},label=sql08_24]
CREATE VIEW <View_name>
(<Spalten_alias 1, Spalten_alias 2, ..., Spalten_alias n)
AS
  <Auswahlabfrage>;
        \end{lstlisting}
        \begin{center}
          \tablecaption{Die CREATE VIEW-Anweisung}
          \label{createviewsyntax}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Ausdruck}} &
              \multicolumn{1}{c}{\textbf{Bedeutung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail{
              \hline
            }
            \begin{supertabular}{|l|p{9.45cm}|}
              CREATE VIEW <View\_name> & Diese Klausel leitet das Erstellen der View ein. F\"ur den Viewname gelten die in \tabelle{createtablerestrictions} angegebenen Beschr\"ankungen. \\
              \hline
              <Spalten\_alias> & F\"ur jeden Spaltenbezeichner, der in der Auswahlabfrage genutzt wird, kann an dieser Stelle ein Aliasname festgelegt werden.\\
              \hline
              <Auswahlabfrage> & Dies ist das SELECT-Statement. \\
            \end{supertabular}
          \end{small}
        \end{center}
        Ein einfaches Beispiel f\"ur das Erstellen einer View ist in \beispiel{sql08_24} zu sehen.
        \begin{lstlisting}[language=oracle_sql,caption={Eine einfache View},label=sql08_25]
CREATE VIEW v_Kunde
AS
  SELECT Vorname, Nachname
  FROM   Kunde;
        \end{lstlisting}
        Was an dieser Stelle passiert ist, dass das DBMS das \SELECT-Statement verarbeitet und unter dem Namen \identifier{v\_Kunden} abspeichert. Anschlie\ss end kann, wie in \beispiel{sql08_26}, mit SQL auf die View zugegriffen werden.
        \begin{lstlisting}[language=oracle_sql,caption={Zugriff auf eine View},label=sql08_26]
SELECT Vorname, Nachname
FROM   v_Kunde;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{VORNAME}} &
              \multicolumn{1}{l}{\textbf{NACHNAME}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{2}{l}{\textbf{561 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{2}{l}{\textbf{561 Zeilen ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{ll}
                Niklas & Schneider \\
                Mia & Keller \\
                Lilli & Beck \\
                Emilia & Keller \\
                Finn & Junge \\
                Marie & Vogel \\
                Rudi & Roggatz \\
                Leni & Koch \\
                Chris & Zimmermann \\
                Justin & Gabriel \\
                Sebastian & Schr\"oder \\
              \end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
        Auch wenn in der \SELECT-Klausel der Auswahlabfrage der * verwendet wird, wird im Hintergrund folgendes Statement, als View gespeichert:
        \begin{lstlisting}[language=oracle_sql,caption={Was tats\"achlich gespeichert wird},label=sql08_27]
-- So wird die View erstellt
CREATE VIEW v_Kunde
AS
  SELECT *
  FROM   Kunde;

-- Das wird gespeichert
SELECT Kunden_ID, Vorname, Nachname
FROM   Kunde;
        \end{lstlisting}
\clearpage
        Diese Tatsache ist nicht ganz unwichtig, wie folgendes Szenario beweist:
        \begin{lstlisting}[language=oracle_sql,caption={Eine Szenario mit T\"ucke},label=sql08_28]
CREATE VIEW v_Aktie
AS
  SELECT *
  FROM   Aktie;

ALTER TABLE Aktie
ADD Herkunft VARCHAR2(30);

SELECT *
FROM   v_Aktie;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{r}{\textbf{AKTIE\_ID}} &
              \multicolumn{1}{l}{\textbf{NAME}} &
              \multicolumn{1}{l}{\textbf{WKN}} &
              \multicolumn{1}{l}{\textbf{ISIN}} \\
              \cmidrule(r){1-1}\cmidrule(l){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{5}{l}{\textbf{2 Zeilen ausgew\"ahlt}} \\
            }
            \begin{msoraclesql}
              \begin{supertabular}{rllll}
                1 & Henker Co KG & 1236547 & DE0006800002  \\
                2 & AD and D & 43116589 & DE0002300023  \\
              \end{supertabular}
            \end{msoraclesql}
          \end{small}
        \end{center}
        Da bei der Erstellung der View \identifier{v\_Aktie}, der *, in die einzelnen Spalten der Tabelle \identifier{Aktie} aufgel\"ost wurde, ist die neu hinzugef\"ugte Spalte \identifier{Herkunft}, in der View \identifier{v\_Aktie} noch nicht zu sehen. Hierzu m\"usste die Viewdefinition ge\"andert bzw. die View neu erstellt werden.
        \begin{merke}
          Wird in der Auswahlabfrage einer View das * Symbol verwendet, wird dieses interpretiert. D. h. es wird ersetzt durch die tats\"achliche Spaltenliste der Quelltabelle. \"Anderungen an der Struktur der Tabelle werden somit von der View nicht erkannt.
        \end{merke}
        Wie in \tabelle{createviewsyntax} bereits erkl\"art, kann bei der Erstellung einer View auch eine Liste mit Spaltenaliasnamen angegeben werden. Dies ist in den folgenden F\"allen immer notwendig:
        \begin{itemize}
          \item Wenn in der View ein berechneter Ausdruck vorhanden ist
          \item Wenn in der View mehrere Tabellen mit einem Join verbunden sind und Spalten mit gleichem Namen ausgegeben werden m\"ussen.
        \end{itemize}
        \beispiel{sql08_29} zeigt eine View mit Spaltenaliasliste.
\clearpage
        \begin{lstlisting}[language=oracle_sql,caption={Eine einfache View mit Spaltenaliasliste},label=sql08_29]
CREATE VIEW v_Kunde
(Vorname, Nachname, Lebensalter)
AS
SELECT k.Vorname, k.Nachname,
       ROUND(MONTHS_BETWEEN(SYSDATE, Geburtsdatum) / 12, 0)
FROM   Kunde k INNER JOIN Eigenkunde ek
       ON (k.Kunden_ID = ek.Kunden_ID);

SELECT *
FROM   v_Kunde;
        \end{lstlisting}
        \begin{center}
          \begin{small}
            \changefont{pcr}{m}{n}
            \tablefirsthead {
              \multicolumn{1}{l}{\textbf{VORNAME}} &
              \multicolumn{1}{l}{\textbf{NACHNAME}} &
              \multicolumn{1}{r}{\textbf{LEBENSALTER}} \\
              \cmidrule(l){1-1}\cmidrule(l){2-2}\cmidrule(r){3-3}
            }
            \tablehead{}
            \tabletail {
              \multicolumn{3}{l}{\textbf{400 Zeilen ausgew\"ahlt}} \\
            }
            \tablelasttail {
              \multicolumn{3}{l}{\textbf{400 Zeilen ausgew\"ahlt}} \\
            }

            \begin{oraclesql}
              \begin{supertabular}{llr}
                Mia & Keller & 41 \\
                Emilia & Keller & 23 \\
                Finn & Junge & 37 \\
                Marie & Vogel & 42 \\
                Rudi & Roggatz & 26 \\
                Leni & Koch & 38 \\
                Chris & Zimmermann & 23 \\
                Sebastian & Schr\"oder & 24 \\
                Justin & Zimmermann & 34 \\
                Petra & Krause & 34 \\
                Clara & Rollert & 23 \\
                Gustav & Witte & 23 \\
              \end{supertabular}
            \end{oraclesql}
          \end{small}
        \end{center}
        Wie gut zu erkennen ist, ersetzen die Spaltenaliase die tats\"achlichen Spaltennamen in \identifier{v\_Kunde}. Die gleiche Auswirkung w\"are auch mit dem folgenden Statement zu erreichen:
        \begin{lstlisting}[language=oracle_sql,caption={Eine einfache View mit Spaltenaliasen},label=sql08_30]
CREATE VIEW v_Kunde
AS
SELECT k.Vorname, k.Nachname,
       ROUND(MONTHS_BETWEEN(SYSDATE, Geburtsdatum) / 12, 0) AS Lebensalter
FROM   Kunde k INNER JOIN Eigenkunde ek
       ON (k.Kunden_ID = ek.Kunden_ID);
        \end{lstlisting}
        \begin{merke}
          Wird eine Spaltenaliasliste genutzt, muss diese genauso viele Aliasnamen umfassen, wie die \SELECT-Liste der Auswahlabfrage Spaltennamen zur\"uckgibt.
        \end{merke}
        Hierzu ein kleines Beispiel. Im folgenden \languageorasql{CREATE VIEW}-Statement werden zu wenige Spaltenaliase angegeben. Oracle und auch SQL Server antworten prompt mit einer Fehlermeldung.
        \begin{lstlisting}[language=oracle_sql,caption={Eine einfache View mit fehlerhafter Spaltenaliasliste in Oracle},label=sql08_31]
CREATE VIEW v_Kunde
(Vorname, Nachname)
AS
SELECT k.Vorname, k.Nachname,
       ROUND(MONTHS_BETWEEN(SYSDATE, Geburtsdatum) / 12, 0)
FROM   Kunde k INNER JOIN Eigenkunde ek
       ON (k.Kunden_ID = ek.Kunden_ID);

(Vorname, Nachname)
 *
FEHLER in Zeile 2:
ORA-01730: Ung&\"u&ltige Anzahl an Spaltennamen angegeben
        \end{lstlisting}
        SQL Server antwortet wie folgt:
        \begin{lstlisting}[language=ms_sql,caption={Eine einfache View mit fehlerhafter Spaltenaliasliste in SQL Server},label=sql08_32]
CREATE VIEW v_Kunde
(Vorname, Nachname)
AS
SELECT k.Vorname, k.Nachname, DATEDIFF(YEAR, getDate(), Geburtsdatum)
FROM   Kunde k INNER JOIN Eigenkunde ek
       ON (k.Kunden_ID = ek.Kunden_ID);

Meldung 8158, Ebene 16, Status 1, Prozedur v_Kunde, Zeile 4
'v_Kunde' besitzt mehr Spalten, als in der Spaltenliste angegeben sind.
        \end{lstlisting}
        Bereits weiter oben in diesem Abschnitt wurde erl\"autert, dass eine View, in der ein berechneter Ausdruck vorkommt, zwingend mit Spaltenaliasen versehen werden muss. \beispiel{sql08_33} beweist dies:
        \begin{lstlisting}[language=oracle_sql,caption={Eine View mit einer berechneten Spalte in Oracle},label=sql08_33]
CREATE VIEW v_Kunde
(Vorname, Nachname)
AS
SELECT k.Vorname, k.Nachname,
       ROUND(MONTHS_BETWEEN(SYSDATE, Geburtsdatum) / 12, 0)
FROM   Kunde k INNER JOIN Eigenkunde ek
       ON (k.Kunden_ID = ek.Kunden_ID);

SELECT k.Vorname, k.Nachname,
ROUND(MONTHS_BETWEEN(SYSDATE, Geburtsdatum) / 12, 0)
                                   *
FEHLER in Zeile 3:
ORA-00998: Dieser Ausdruck braucht einen Spalten-Alias
        \end{lstlisting}
\clearpage
        Auch SQL Server hat hiermit Probleme:
        \begin{lstlisting}[language=ms_sql,caption={Eine View mit einer berechneten Spalte in SQL Server},label=sql08_34]
CREATE VIEW v_Kunde (Vorname, Nachname)
AS
SELECT k.Vorname, k.Nachname, DATEDIFF(YEAR, getDate(), Geburtsdatum)
FROM   Kunde k INNER JOIN Eigenkunde ek ON (k.Kunden_ID = ek.Kunden_ID);

Meldung 4511, Ebene 16, Status 1, Prozedur v_Kunde, Zeile 3
Fehler beim Ausf&\"u&hren von CREATE VIEW oder CREATE FUNCTION, da
f&\"u&r die 3-Spalte kein Spaltenname angegeben wurde.
        \end{lstlisting}
        Dieses Problem kann durch eine Spaltenaliasliste oder durch die direkte Vergabe eines Spaltenalias gel\"ost werden.
        \begin{merke}
          Bei SQL Server gibt es noch die Einschr\"ankung, dass die Auswahlabfrage einer View keine \ORDERBY-Klausel enthalten darf.
        \end{merke}
      \subsection{Views und DML}
        Views k\"onnen  auch f\"ur die Ausf\"uhrung von DML-Statements verwendet werden. Dabei gibt es jedoch einige Einschr\"ankungen und Regeln die zu beachten sind.
        \begin{center}
          \tablecaption{Regeln f\"ur DML-Operationen auf Views}
          \label{rulesdmlviews}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{oracle_11g}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{ms_sql}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{oracle_11g}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{ms_sql}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{oracle_11g}}} &
              \multicolumn{1}{c}{\textbf{\includegraphics[scale=1]{ms_sql}}} \\
              \multicolumn{1}{c}{Einschr\"ankung} &
              \multicolumn{2}{c}{INSERT} &
              \multicolumn{2}{c}{UPDATE} &
              \multicolumn{2}{c}{DELETE} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail {
              \hline
            }
            \begin{supertabular}{|p{8.5cm}|c|c|c|c|c|c|}
              Es d\"urfen keine Aggregatfunktionen (COUNT, SUM, MAX, MIN, AVG) in der View genutzt werden. & X & X & X & X & X & X \\
              \hline
              Die View darf keine GROUP BY-Klausel enthalten. & X & X & X & X & X & X \\
              \hline
              Die View darf das DISTINCT-Schl\"usselwort nicht benutzen. & X & X & X & X & X & X\\
              \hline
              Die View darf keine berechneten Ausdr\"ucke aufweisen. & X & X & X & X & & \\
              \hline
              Die View darf keine Pseudospalten enthalten & X & & X & & X & \\
              \hline
              Die View darf keinen Join enthalten. & X & X & & & X & X \\
              \hline
              Alle mit NOT NULL markierten Spalten der Basistabelle m\"ussen im INSERT-Statement ber\"ucksichtigt werden. & X & X & & & & \\
              \hline
              Der Einf\"uge- bzw. \"Anderungsvorgang muss, falls eine CHECK-Option in der View vorhanden ist (siehe \abschnitt{CHECK}), den Vorgaben der WHERE-Klausel der Abfrage gen\"ugen. & X & X & X & X & & \\
              \hline
              Die View darf keine READ ONLY-Option (siehe \abschnitt{READONLY}) enthalten. & X & & X & & &\\
            \end{supertabular}
          \end{small}
        \end{center}
        \subsubsection{Die Einschr\"ankung WITH CHECK OPTION}
          \label{CHECK}
          Bei der Erstellung einer View kann eine zus\"atzliche Einschr\"ankung mit angegeben werden, die \languageorasql{CHECK OPTION}. Diese schr\"ankt den Nutzer dahingehend ein, dass nur noch solche Datens\"atze ge\"andert werden k\"onnen, die auch in der View zu sehen sind.
          \begin{lstlisting}[language=oracle_sql,caption={Ein Experiment mit den CHECK OPTION},label=sql08_35]
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
  WHERE  Bankfiliale_ID = 5;

INSERT INTO v_Mitarbeiter
VALUES (666, 'Florian', 'Weidinger', 12, 8,
        TO_DATE('01.03.1988', 'DD.MM.YYYY'),
        '38B546C1-CDF-36A7B97', 1500, 'Abendrot Gase',
        '13', '39444', 'Hecklingen', 20);

1 Zeile eingef&\"u&gt.

ROLLBACK;
          \end{lstlisting}
          Obwohl die \WHERE-Klausel der View \identifier{v\_Mitarbeiter} die Anzeige auf die Bankfiliale mit der ID f\"unf einschr\"ankt, kann trotzdem ein Datensatz in die Bankfiliale Nummer acht eingef\"ugt werden.

          Um die DML-M\"oglichkeiten der View \identifier{v\_Mitarbeiter} einzuschr\"anken, wird im n\"achsten Beispiel die \languageorasql{CHECK}-Option angewendet.
          \begin{lstlisting}[language=oracle_sql,caption={Ein Experiment mit der CHECK OPTION in Oracle},label=sql08_36]
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
  WHERE  Bankfiliale_ID = 5
WITH CHECK OPTION;

INSERT INTO v_Mitarbeiter
VALUES (666, 'Florian', 'Weidinger', 12, 8,
        TO_DATE('01.03.1988', 'DD.MM.YYYY'),
        '38B546C1-CDF-36A7B97', 1500, 'Abendrot Gase',
        '13', '39444', 'Hecklingen', 20);

INSERT INTO v_Mitarbeiter
         *
FEHLER in Zeile 1:
ORA-01402: Verletzung der where-Klausel einer View with check option
          \end{lstlisting}
          Da jetzt die \languageorasql{CHECK}-Option genutzt wurde, reagiert das DBMS mit einer Fehlermeldung auf DML-Statements, die sich auf \identifier{v\_Mitarbeiter} beziehen und nicht der \WHERE-Klausel der View entsprechen.
          \begin{lstlisting}[language=ms_sql,caption={Ein Experiment mit der CHECK OPTION in SQL Server},label=sql08_37]
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
  WHERE  Bankfiliale_ID = 5
WITH CHECK OPTION;

INSERT INTO v_Mitarbeiter
VALUES (666, 'Florian', 'Weidinger', 12, 8,
        CONVERT(DATETIME2, '01.03.1988', 104),
        '38B546C1-CDF-36A7B97', 1500, 'Abendrot Gase',
        '13', '39444', 'Hecklingen', 20);

Meldung 550, Ebene 16, Status 1, Zeile 1
Fehler beim Einf&\"u&gen oder Aktualisieren, da die Zielsicht WITH CHECK OPTION
angibt oder sich auf eine Sicht erstreckt, die WITH CHECK OPTION angibt,
und mindestens eine Ergebniszeile nicht der CHECK OPTION-Einschr&\"a&nkung
entsprach.
          \end{lstlisting}
        \subsubsection{Die Einschr\"ankung WITH READ ONLY - Oracle}
          \label{READONLY}
          Die \languageorasql{READ ONLY}-Option f\"ur Views erm\"oglicht es, einem Nutzer den Schreibzugriff auf eine View zu verbieten. Die View kann somit nur noch lesend genutzt werden.
          \begin{lstlisting}[language=oracle_sql,caption={Eine View mit mit READ ONLY Option erstellen},label=sql08_38]
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
WITH READ ONLY;
          \end{lstlisting}
          Versucht ein Nutzer trotzdem mit einem DML-Statement auf die View zuzugreifen, wird er mit einer Fehlermeldung abgewiesen.
\clearpage
          \begin{lstlisting}[language=oracle_sql,caption={Daten in eine READ ONLY View einf\"ugen schl\"agt fehl},label=sql08_39]
INSERT INTO v_Mitarbeiter
VALUES (666, 'Florian', 'Weidinger', 12, 8,
        TO_DATE('01.03.1988', 'DD.MM.YYYY'),
        '38B546C1-CDF-36A7B97', 1500, 'Abendrot Gase',
        '13', '39444', 'Hecklingen', 20);

INSERT INTO v_Mitarbeiter
*
FEHLER in Zeile 1:
ORA-42399: cannot perform a DML operation on a read-only view
          \end{lstlisting}
          Um diese Option wieder von der View zu nehmen, muss die View neu erstellt werden (siehe \abschnitt{alterview})
      \subsection{Views \"andern}
        \label{alterview}
        M\"ussen an einer View Ver\"anderungen vorgenommen werden, bedeutet dies immer, dass die View neu erstellt werden muss. Oracle und SQL Server kennen hierzu unterschiedliche Wege:
        \begin{itemize}
          \item In Oracle wird die \languageorasql{CREATE VIEW}-Klausel erweitert: \languageorasql{CREATE OR REPLACE VIEW}.
          \item SQL Server benutzt hierf\"ur die \languagemssql{ALTER VIEW}-Anweisung.
        \end{itemize}
        Die beiden Beispiele \beispiel{sql08_40} und \beispiel{sql08_41} zeigen, wie in Oracle und SQL Server eine Viewdefinition ge\"andert werden kann.
        \begin{lstlisting}[language=oracle_sql,caption={Eine View \"andern in Oracle},label=sql08_40]
-- Zuerst wird die View erstellt
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
WITH READ ONLY;

-- Dann wird sie geaendert
CREATE OR REPLACE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter;
        \end{lstlisting}
\clearpage
        Und nun SQL Server.
        \begin{lstlisting}[language=ms_sql,caption={Eine View \"andern in SQL
Server},label=sql08_41]
-- Zuerst wird die View erstellt
CREATE VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter;

-- Dann wird sie ge&\"a&ndert
ALTER VIEW v_Mitarbeiter
AS
  SELECT *
  FROM   Mitarbeiter
  WHERE  Bankfiliale_ID = 5;
        \end{lstlisting}
      \subsection{Views l\"oschen}
        Zum L\"oschen von Views gibt es das Kommando \languageorasql{DROP VIEW}.
        \begin{lstlisting}[language=ms_sql,caption={Eine View l\"oschen},label=sql08_42]
DROP VIEW viw_countries;
        \end{lstlisting}
