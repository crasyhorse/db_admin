  \chapter{Verwalten einer Oracle Instanz}
    \setcounter{page}{1}
    \kapitelnummer{chapter}
    \minitoc
\newpage
    Eine Oracle-Umgebung besteht immer aus zwei Teilen: Datenbank und Instanz.
    Beim Start-Up, dem \enquote{Hochfahren der Datenbank}, wird die Instanz als
    Shared-Memory-Block im Arbeitsspeicher erzeugt. Dieser wird in die SGA und
    die PGA unterteilt. Des Weiteren werden verschiedene Hintergrundprozesse
    gestartet, die die Arbeit in der SGA verrichten.
    \section{Das SQL*Plus-Tool}
      Das SQL*Plus-Tool (Aussprache: sequel plus) ist ein textbasiertes, interaktives Tool, welches haupts\"achlich f\"ur administrative Aufgaben gedacht ist. Es wird automatisch bei jedem Oracle-Datenbankserver mit installiert. Ebenso kann es mit Hilfe der Oracle Client Tools auf einem Rechner ohne Datenbankserver installiert werden.
      \bild{Das SQL*Plus-Tool}{sql_plus}{1}
      Das SQL*Plus-Tool kennt drei verschiedene Arten von Befehlen:
      \begin{itemize}
        \item SQL-Kommandos
        \item PL/SQL-Kommandos
        \item SQL*Plus-Befehle
      \end{itemize}
      W\"ahrend SQL- und PL/SQL-Befehle durch die Datenbank verarbeitet werden,
      bleiben SQL*Plus-Kommandos lokal. Sie dienen nur zur Formatierung der
      Anzeige in SQL*Plus.
      \subsection{Die erste Anmeldung}
        Das Anmelden an einer Datenbank mit Hilfe des SQL*Plus-Tools verl\"auft
        in drei Schritten:
        \begin{enumerate}
          \item \"Offnen eines Terminalfensters
          \item Ausw\"ahlen der gew\"unschten Instanz
          \item Starten von SQL*Plus
        \end{enumerate}
        Um eine Instanz ausw\"ahlen zu k\"onnen, liefert Oracle das Shell-Skript
        \oscommand{oraenv} aus.
        \bild{Das oraenv Shell-Skript}{oraenv}{1}
        \begin{merke}
          Beachten Sie den Punkt im Aufruf: \oscommand{. oraenv}
        \end{merke}
        Der Start des SQL*Plus-Tools erfolgt mittels der Kommandozeile: \oscommand{sqlplus / as sysdba}. Die Bedeutung des Zusatzes \oscommand{ / as sysdba} wird an sp\"aterer Stelle noch behandelt.
      \subsection{Die wichtigsten SQL*Plus-Befehle}
        \begin{center}
          \tablecaption{Die wichtigsten SQL*Plus-Befehle}
          \label{importantsqlpluscommands}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\textbf{Befehl}} &
              \multicolumn{1}{c}{\textbf{Beispiel}} &
              \multicolumn{1}{c}{\textbf{Erl\"auterung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\textbf{Befehl}} &
              \multicolumn{1}{c}{\textbf{Beispiel}} &
              \multicolumn{1}{c}{\textbf{Erl\"auterung}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail {
              \hline
            }
            \begin{supertabular}{|p{4.25cm}|p{4.25cm}|p{6.25cm}|}
              \oscommand{show user} & \oscommand{show user} & Zeigt den aktuellen Benutzernamen an. \\
              \hline
              \oscommand{conn[ect]} & \oscommand{conn hr/hr} & \"Offnet eine Session mit dem angegebenen Nutzernamen/Passwort. \\
              \hline
              \oscommand{disconn[ect]} & \oscommand{disconn} & Beendet die aktuelle Session. \\
              \hline
              \oscommand{exit} & \oscommand{exit} & Beendet die aktuelle Session und schlie\ss{}t das SQL*Plus-Tool. \\
              \hline
              \oscommand{ho[st]} & \oscommand{ho} & Verl\"asst SQL*Plus und wechselt in einen Terminal. Das SQL*Plus-Tool bleibt im Hintergrund ge\"offnet. Durch die Eingabe von \oscommand{exit} kann zur\"uckgewechselt werden. \\
              \hline
              \oscommand{desc[ribe]} & \oscommand{desc employees} & Zeigt die Definition einer Tabelle an. \\
              \hline
              \oscommand{ed[it]} & \oscommand{ed} & \"Offnet das letzte SQL-Statement in einem Editor. Das Statement kann ge\"andert und erneut ausgef\"uhrt werden. \\
              \hline
              \oscommand{col xx format  aNN} & \oscommand{col mail format a20} & Breite einer Tabellenspalte der Typen \identifier{CHAR}, \identifier{VARCHAR2} oder \identifier{DATE} begrenzen. \oscommand{xx} steht f\"ur einen Spaltenbezeichner und \oscommand{NN} steht f\"ur die Breite. \\
              \hline
              \oscommand{col xx format NN} & \oscommand{col salary 999999} & Begrenzt die Breite einer Spalte des Typs \identifier{NUMBER}. Jede \oscommand{9} steht f\"ur eine Stelle, d. h. \oscommand{999} erzeugt eine dreistellige Spalte. \\
              \hline
              \oscommand{set linesize NN} & \oscommand{set linesize 300} & Zeilenl\"ange auf \oscommand{NN} Zeichen begrenzen. \\
              \hline
              \oscommand{set long NN} & \oscommand{set long 4000} & Begrenzt die Breite einer Spalte des Typs \identifier{LONG} auf \oscommand{NN} Zeichen. \\
              \hline
              \oscommand{set pagesize NN} & \oscommand{set pagesize 50} & Seitenh\"ohe auf \oscommand{NN} Zeilen begrenzen. Die H\"ohe gibt an, nach wie vielen Zeilen die Spalten\"uberschriften wiederholt werden. \\
              \hline
              \oscommand{set serveroutput on\textbar{}off} & \oscommand{set serveroutput on} & F\"ur PL/SQL-Bl\"ocke wird die Bild\-schirm\-ausgabe ein- oder ausgeschaltet.\\
              \hline
              \oscommand{startup} & startup & Startet eine Oracle-Instanz. \\
              \hline
              \oscommand{shutdown} & shutdown & Schlie\ss{}t eine Oracle-Instanz. \\
              \hline
              \oscommand{[l]ist} & l & Letztes SQL-Kommando anzeigen. \\
              \hline
              \oscommand{[r]erun} & r & Letztes SQL-Kommando wiederholen. \\
           \end{supertabular}
          \end{small}
        \end{center}
    \section{Der Start-Up-Prozess}
      Unter dem Begriff Start-Up versteht Oracle das \enquote{Hochfahren der Datenbank}. Da die Datenbank jedoch nur eine Sammlung von Dateien ist, ist somit die Ausdrucksweise \enquote{Hochfahren der Datenbank} inkorrekt. Richtiger Weise muss es hei\ss{}en \enquote{Erstellen der Instanz}, da beim Start-Up eine Instanz erstellt und mit ihrer Datenbank verbunden wird.

      Der Start-Up-Prozess verl\"auft in drei Schritten, die Start-Up-Phasen genannt werden. Jede Phase hat einen eigenen Namen, einen bestimmten Zweck und ist f\"ur unterschiedliche, meist administrative T\"atigkeiten notwendig. Die Namen der Start-Up-Phasen lauten:
      \begin{itemize}
        \item NOMOUNT
        \item MOUNT
        \item OPEN
      \end{itemize}
      \subsection{Die NOMOUNT-Phase}
        Nach dem ersten Schritt des Start-Ups befindet sich die Datenbank in der NOMOUNT-Phase. Das bedeutet, dass die Instanz erstellt, aber noch nicht an die Datenbank angeschlossen wurde. Es existiert eine Instanz ohne Datenbank.
        \begin{merke}
          Um den Start-Up einer Instanz durchf\"uhren zu k\"onnen, m\"ussen die beiden Umgebungsvariablen \oscommand{ORACLE\_SID} und \oscommand{ORACLE\_HOME} gesetzt sein. Dies geschieht beim Ausf\"uhren des Shell-Skriptes: \oscommand{. oraenv}.
        \end{merke}
        Das Starten der Instanz geschieht mit dem SQL*Plus-Befehl \languagesqlplus{startup}. Diesem Kommando k\"onnen die Zus\"atze \languagesqlplus{nomount}, \languagesqlplus{mount} oder \languagesqlplus{open} mitgegeben werden, um die jeweils gew\"unschte Start-Up-Phase zu erreichen.
        \begin{lstlisting}[caption={Einen Start-Up bis zur NOMOUNT-Phase
        durchf\"uhren},label=admin01,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:20:29 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> startup nomount
ORACLE instance started.

Total System Global Area  643084288 bytes
Fixed Size                  2215984 bytes
Variable Size             222302160 bytes
Database Buffers          411041792 bytes
Redo Buffers                7524352 bytes
        \end{lstlisting}

        \bild{Die NOMOUNT-Phase}{startup_nomount}{1.75}

        Nach Erreichen der NOMOUNT-Phase sind drei Dinge geschehen:
        \begin{enumerate}
          \item Die Parameter-/Serverparameterdatei wurde gelesen
          \item Die SGA wurde mit den gelesenen Parametern erstellt
          \item Die Oracle-Hintergrundprozesse wurden gestartet
        \end{enumerate}
      \subsection{Die MOUNT-Phase}
        Der Begriff \enquote{mounten} bedeutet, dass eine Instanz mit ihrer Datenbank verbunden wird. Dieser Vorgang wird dadurch realisiert, dass die Instanz die Kontrolldatei der Datenbank liest, um ihr die Speicherorte der Daten- und der Redo Log Dateien zu entnehmen. Der Pfad zu den Kontrolldateien ist in der Parameterdatei, im Parameter \parameter{control\_files} festgelegt.
        \bild{Die MOUNT-Phase}{startup_mount}{1.8}

        In dieser Phase ist die Instanz exklusiv ge\"offnet, d. h. nur Administratoren haben Zugriff, normale Nutzer noch nicht. Die MOUNT-Phase ist f\"ur administrative T\"agtigkeiten, wie z. B. Recovery nach einem Datenverlust oder das Verschieben von Datenbankdateien vorgesehen.

        Wie eine Instanz die MOUNT-Phase erreichen kann, h\"angt davon ab, ob sie geschlossen ist oder ob sie sich in der NOMOUNT-Phase befindet. F\"ur eine geschlossene Datenbank wird mit Hilfe des Kommandos \languageorasql{startup mount} die Instanz bis in die MOUNT-Phase gebracht. Existiert die Instanz aber bereits in der NOMOUNT-Phase, muss sie mittels des Befehls \languageorasql{ALTER DATABASE MOUNT} in die MOUNT-Phase versetzt werden.
        \begin{merke}
          Eine Instanz die bereits mit \languageorasql{startup} gestartet wurde, kann nicht nochmal gestartet werden. Ihr Status muss stattdessen mit \languageorasql{ALTER DATABASE} ge\"andert werden.
        \end{merke}
        \beispiel{admin02} zeigt wie eine Instanz reagiert, wenn sie nach einen Start-Up erneut gestartet werden soll.
\clearpage
        \begin{lstlisting}[caption={ORACLE l\"auft noch. Erst
        stoppen.},label=admin02,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:23:58 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> startup mount
&\textbf{\textcolor{red}{ORA-01081: cannot start already-running ORACLE - shut it down first}}&
        \end{lstlisting}
        In \beispiel{admin01} ist zu sehen, dass das \languagesqlplus{startup nomount}-Kommando, die Instanz startet und in die NOMOUNT-Phase versetzt. Das zweite Kommando, \languagesqlplus{startup mount} quittiert Oracle mit der Fehlermeldung: \enquote{\oscommand{ORA-01081: cannot start already-running ORACLE - shut it down first}}. Dies geschieht, da die Instanz bereits gestartet worden war.
        \begin{merke}
          Eine Instanz muss erst heruntergefahren werden, bevor sie erneut gestartet werden kann.
        \end{merke}
        Im folgenden Beispiel wird die Instanz korrekt von der NOMOUNT-Phase in die MOUNT-Phase gehoben.
        \begin{lstlisting}[caption={Das Kommando ALTER DATABASE MOUNT},label=admin03,,language=oracle_sql]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:26:35 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> ALTER DATABASE MOUNT;

Database altered.
        \end{lstlisting}
    \subsection{Die OPEN-Phase}
      Eine Oracle-Datenbank zu \"offnen bedeutet, die Daten- und Redo Log Dateien zu \"offnen und sie den \enquote{normalen Nutzern} zug\"anglich zu machen. Das \"Offnen einer geschlossenen Datenbank geschieht mit dem Kommando \languagesqlplus{startup} oder wahlweise auch mit \languagesqlplus{startup open}.

      \bild{Die OPEN-Phase}{startup_open}{1.75}

      \begin{lstlisting}[caption={Starten der Instanz und \"offnen der
      Datenbank},label=admin04,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:36:12 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to an idle instance.

SQL> startup open
ORACLE instance started.

Total System Global Area  643084288 bytes
Fixed Size                  2215984 bytes
Variable Size             222302160 bytes
Database Buffers          411041792 bytes
Redo Buffers                7524352 bytes
Database mounted.
Database opened.
        \end{lstlisting}
        F\"ur den Wechsel zwischen MOUNT- und OPEN-Phase gilt das Gleiche, wie f\"ur den Wechsel zwischen NOMOUNT- und MOUNT-Phase, er muss mittels \languageorasql{ALTER DATABASE} erfolgen, da die Instanz bereits gestartet ist.
        \begin{lstlisting}[caption={Wechsel zwischen MOUNT- und OPEN-Phase},label=admin05,language=oracle_sql]
ORACLE instance started.

Total System Global Area  643084288 bytes
Fixed Size                  2215984 bytes
Variable Size             222302160 bytes
Database Buffers          411041792 bytes
Redo Buffers                7524352 bytes
Database mounted.
SQL> ALTER DATABASE OPEN;
Database altered.
        \end{lstlisting}
      \subsection{Das Hochfahren einer Instanz erzwingen}
        In einigen F\"allen kommt es vor, dass eine Instanz nicht auf normalem Wege gestartet werden kann. Sollte dies geschehen, muss \enquote{der Instanzstart erzwungen werden}. Sinnvoll ist ein solches Vorgehen aber nur in den folgenden Situationen:
        \begin{itemize}
          \item Wenn die Instanz nicht gestartet werden kann
          \item Wenn ein Herunterfahren der Instanz nicht m\"oglich ist
        \end{itemize}
        Mit dem Kommando \languagesqlplus{startup force} wird eine Instanz gezwungen, neu zu starten. Durch einen solchen \enquote{gewaltsamen} Neustart entsteht jedoch Datenverlust, weil die Instanz ohne vorherigen Checkpoint von ihrer Datenbank getrennt wird. Alle nicht abgeschlossenen Transaktionen der Nutzer und s\"amtliche Sessions werden abgebrochen.

        Zur Behebung des Datenverlusts, wird beim Neustart ein
        \enquote{Instance-} bzw. \enquote{Crash recovery} durchgef\"uhrt. Dies
        wird durch einen Eintrag im Alert-Log File belegt.
        \begin{lstlisting}[caption={Ein erzwungener Neustart der Instanz und
        seine Folgen - Der Eintrag im Alert Log
        File},label=admin07,language=terminal]
Mon Aug 26 08:59:27 2013 &ALTER DATABASE OPEN& 
&\textbf{\textcolor{red}{Beginning crash recovery of 1 threads}}&
 parallel recovery started with 2 processes
Started redo scan
Completed redo scan
 read 119 KB redo, 82 data blocks need recovery
Started redo application at
 Thread 1: logseq 4, block 277
Recovery of Online Redo Log: Thread 1 Group 1 Seq 4 Reading mem 0
  Mem# 0: /u02/oradata/orcl/redo01.log
Completed redo application of 0.11MB
&\textbf{\textcolor{red}{Completed crash recovery}}& at
 Thread 1: logseq 4, block 515, scn 1037873
 82 data blocks read, 82 data blocks written, 119 redo k-bytes read
        \end{lstlisting}
    \section{Der Shutdown-Vorgang}
      Als \enquote{Shutdown} wird der Vorgang des Herunterfahrens der Instanz bezeichnet. Welche Einzelschritte bei einem Shutdown geschehen, h\"angt davon ab, welche der vier Arten des Shutdowns gew\"ahlt wurde. Folgende Shutdown-Arten gibt es:
      \begin{itemize}
        \item Shutdown Normal
        \item Shutdown Transactional
        \item Shutdown Immediate
        \item Shutdown Abort
      \end{itemize}
      Ein Shutdown kann mit Hilfe eines Datenbank-Tools eingeleitet werden, z. B. SQL*Plus.
      \begin{merke}
        Nur Nutzer mit dem Privileg \privileg{SYSDBA} oder \privileg{SYSOPER} k\"onnen einen Shutdown durchf\"uhren.
      \end{merke}
      \subsection{Shutdown NORMAL}
        Der Shutdown NORMAL ist die gr\"undlichste Art des Shutdown. Er f\"uhrt folgende Einzelschritte durch:
        \begin{enumerate}
          \item Es werden keine neuen Connections zur Datenbank zugelassen
          \item Es wird gewartet, bis alle Transaktionen der Nutzer abgeschlossen sind
          \item Es wird gewartet, bis alle Nutzer ihre Session beendet haben
          \item Ein Checkpoint wird ausgel\"ost
        \end{enumerate}
        Durch das Ausl\"osen des Checkpoints werden alle ge\"anderten Daten aus dem Database Buffer Cache in die Datendateien zur\"uckgeschrieben. Daraus folgt, dass ein Shutdown NORMAL die Datenbank in einem konsistenten Zustand bel\"asst.

        Durchgef\"uhrt wird ein Shutdown NORMAL mit dem Kommando
       \languagesqlplus{shutdown normal} oder einfach nur \languagesqlplus{shutdown}.
        \begin{lstlisting}[caption={Durchf\"uhren eines Shutdown
        NORMAL},label=admin08,language=sqlplus]
SQL> shutdown normal
Database closed.
Database dismounted.
ORACLE instance shut down.
        \end{lstlisting}
         \begin{merke}
           Problematisch an einem Shutdown NORMAL ist, dass in einer Umgebung mit sehr vielen Nutzern, vermutlich nie alle Nutzer ihre Session beenden, was bedeutet, dass der Shutdown-Vorgang auch nie vollendet werden kann.
         \end{merke}
      \subsection{Shutdown TRANSACTIONAL}
        Der Shutdown TRANSACTIONAL ist eine Abstufung des Shutdown NORMAL. Er f\"uhrt folgende Einzelschritte durch:
        \begin{enumerate}
          \item Es werden keine neuen Connections zur Datenbank zugelassen
          \item Es wird gewartet, bis alle Transaktionen der Nutzer abgeschlossen sind
          \item Noch aktive Nutzersessions werden automatisch beendet
          \item Ein Checkpoint wird ausgel\"ost
        \end{enumerate}
        Hier wird also lediglich auf das Ende aller noch offnen Transaktionen gewartet, nicht aber darauf, dass sich alle Nutzer vom System abmelden. Dies kann einen Shutdown-Vorgang deutlich beschleunigen, bzw. es wird dadurch eine realistische Chance f\"ur die Vollendung des Shutdowns einger\"aumt.
        \begin{merke}
          Bei einem Shutdown TRANSACTIONAL ist es sinnvoll die Nutzer vorher zubenachrichtigen, da diese ab einem Zeitpunkt X, ihre Arbeit nicht mehr fortsetzen k\"onnen.
        \end{merke}
        \begin{lstlisting}[caption={Durchf\"uhren eines Shutdown
        TRANSACTIONAL},label=admin09,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:50:05 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.


Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> shutdown transactional
Database closed.
Database dismounted.
ORACLE instance shut down.
        \end{lstlisting}
        Der Unterschied zwischen einem Shutdown NORMAL und einem Shutdown TRANSACTIONAL ist im Alert Log File zu sehen.
        \begin{lstlisting}[caption={Der Shutdown TRANSACTIONAL im Alert
        Log},label=admin10,language=terminal]
&\textbf{\textcolor{red}{Shutting down instance (transactional)}}&
Shutting down instance: further logons disabled
Stopping background process CJQ0
Stopping background process QMNC
Stopping background process MMNL
Stopping background process MMON
&\textbf{\textcolor{red}{All transactions complete. Performing immediate shutdown}}&
License high water mark = 3
All dispatchers and shared servers &shutdown&
&ALTER DATABASE CLOSE NORMAL&
        \end{lstlisting}
        Der Eintrag \enquote{All transactions complete. Performing immediate shutdown} weisst darauf hin, dass nach dem Ende der letzten Transaktion sofort mit dem Shutdown begonnen wird. Bei einem Shutdown NORMAL fehlt diese Zeile, wie in \beispiel{admin11} zu sehen ist.
        \begin{lstlisting}[caption={Der Shutdown NORMAL im Alert Log},label=admin11,language=terminal]
&\textbf{\textcolor{red}{Shutting down instance (normal)}}&
Stopping background process SMCO
Shutting down instance: further logons disabled
Mon Aug 26 10:41:26 2013
Stopping background process CJQ0
Stopping background process QMNC
Stopping background process MMNL
Stopping background process MMON
License high water mark = 4
All dispatchers and shared servers &shutdown&
&ALTER DATABASE CLOSE NORMAL&
       \end{lstlisting}
       \begin{merke}
        Ein Shutdown TRANSACTIONAL \"uberf\"uhrt die Datenbank in einen konsistenten Zustand.
       \end{merke}
      \subsection{Shutdown IMMEDIATE}
        Der Shutdown IMMEDIATE ist genau das, was sein Name besagt. Die Datenbank wird sofort, ohne auf offene Transaktionen oder Nutzer zu warten heruntergefahren. Da diese Art des Shutdowns sehr radikal ist, sollten auf jeden Fall alle Nutzer informiert werden.

        Nur in den folgenden Situationen sollte ein Shutdown IMMEDIATE durchgef\"uhrt werden:
        \begin{itemize}
          \item Vor einem automatisierten Backup
          \item Um im Falle eines Stromausfalles die DB so schnell wie m\"oglich herunterzufahren
          \item Im Falle einer Datenbankfehlfunktion, wenn es nicht m\"oglich ist, alle Nutzer vorher zu benachrichtigen
        \end{itemize}
        Bei diesem Shutdown werden folgende Einzelschritte durchgef\"uhrt:
        \begin{itemize}
          \item Es werden keine neuen Connections zur Datenbank zugelassen
          \item Alle aktiven Transaktionen werden zur\"uckgerollt
          \item Noch aktive Nutzersessions werden automatisch beendet
          \item Es wird ein Checkpoint gesetzt
        \end{itemize}
        \begin{merke}
          Obwohl alle Transaktionen abgebrochen und alle Sessions geschlossen werden, wird die Datenbank in einem konsistenten Zustand hinterlassen.
        \end{merke}
        \begin{lstlisting}[caption={Durchf\"uhren eines Shutdown IMMEDIATE},label=admin12,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:52:09 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
        \end{lstlisting}
      \subsection{Shutdown ABORT}
        Der Shutdown ABORT ist die einzige Shutdown-Variante, bei der die
        Datenbank in einem inkonsistenten Zustand hinterlassen wird. Hier wird
        die Instanz einfach von der Datenbank getrennt, ohne dass vorher ein
        Checkpoint ausgel\"ost wird. Aus diesem Grund sollte ein Shutdown ABORT
        nur dann eingesetzt werden, wenn es notwendig ist.

        Folgende Einzelschritte werden bei einem Shutdown ABORT ausgef\"uhrt:
        \begin{itemize}
          \item Es werden keine neuen Connections zur Datenbank zugelassen
          \item Alle aktiven Transaktionen werden nicht zur\"uckgerollt, sondern sofort abgebrochen (Inkonsistenz!)
          \item Noch aktive Nutzersessions werden abgebrochen
        \end{itemize}
        \begin{lstlisting}[caption={Durchf\"uhren eines Shutdown ABORT},label=admin13,language=sqlplus]
[oracle@FEA11-119SRV ~]$ sqlplus / as sysdba

&SQL&*Plus: Release 11.2.0.1.0 Production &on& Tue Aug 27 10:52:09 2013

Copyright (c) 1982, 2009, Oracle.  All rights reserved.

Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> shutdown abort
ORACLE instance shut down.
        \end{lstlisting}
        \begin{merke}
          Ein Neustart der Datenbank nach einem \languagesqlplus{shutdown abort} erfordert ein Instance recovery.
        \end{merke}
        \begin{literaturinternet}
          \item \cite{i1006091}
        \end{literaturinternet}
    \section{Verwalten der Parameterdatei}
      Die Parameterdatei bzw. Serverparameterdatei ist die erste Datei, die ben\"otigt wird, um eine Instanz hochfahren zu k\"onnen. Sie enth\"alt eine Liste mit Konfigurationsparametern, den sogenannten \enquote{Init\-iali\-sierungs\-pa\-ra\-me\-tern}.

      Oracle sucht seine Parameterdatei/Serverparameterdatei beim Hochfahren der Instanz in einem betriebssystemabh\"angigen Standardverzeichnis. Dieses ist:
      \begin{itemize}
        \item \textbf{Windows}: \oscommand{\%ORACLE\_HOME\%\textbackslash database}
        \item \textbf{UNIX}: \oscommand{\$ORACLE\_HOME/dbs}
      \end{itemize}
      Beim Durchsuchen des entsprechenden Standardpfades wird nach drei verschiedenen Dateinamen gesucht:
      \begin{itemize}
        \item \oscommand{spfile\$ORACLE\_SID.ora} (z. B. \oscommand{spfileorcl.ora})
        \item \oscommand{spfile.ora}
        \item \oscommand{init\$ORACLE\_SID.ora} (z. B. \oscommand{initorcl.ora})
      \end{itemize}
      Bei den ersten beiden Dateinamen handelt es sich um Serverparameterdateien, beim Dritten um eine Parameterdatei.
      \begin{merke}
        Kann Oracle keine dieser Dateien finden, wird der Startvorgang
        abgebrochen.
      \end{merke}

      \begin{literaturinternet}
        \item \cite{i1124822}
      \end{literaturinternet}
      \subsection{Initialisierungsparameter administrieren}
        Initialisierungsparameter haben unterschiedliche Aufgaben:
        \begin{itemize}
          \item Benennen von Objekten wie z. B. Kontrolldateien oder Betriebssystemverzeichnissen
          \item Beeinflussen von Kapazit\"aten, wie z. B. der Gr\"o\ss e der SGA
        \end{itemize}
        Es kann aus unterschiedlichen Gr\"unden notwendig sein, die Werte von Initialisierungsparametern zu ver\"andern. Welche Auswirkungen diese \"Anderungen haben, h\"angt von den Charakteristiken der Datenbank und anderen Faktoren ab.
        \subsubsection{Statische und dynamische Parameter}
          Initialisierungsparameter werden in zwei Gruppen eingeteilt:
          \begin{itemize}
            \item \textbf{Statische Parameter}: Die \"Anderung an einem solchen Parameter wird erst nach einem Instanzneustart wirksam.
            \item \textbf{Dynamische Parameter}: \"Anderungen an dynamischen Parametern werden sofort wirksam.
          \end{itemize}
          Die View \identifier{v\$system\_parameter} gibt Aufschluss dar\"uber, ob ein Parameter statisch oder dynamisch ist.
          \begin{lstlisting}[caption={Unterscheiden zwischen dynamischen und statischen Parametern},label=admin14,language=oracle_sql,alsolanguage=sqlplus]
SQL> col name format a30

SQL> SELECT name, issys_modifiable
  2  FROM   v$system_parameter;
          \end{lstlisting}
          In der Spalte \identifier{issys\_modifiable} k\"onnen drei verschiedene Werte vorkommen:
          \begin{itemize}
            \item \textbf{IMMEDIATE}: Es handelt sich um einen \textbf{dynamischen} Parameter.
            \item \textbf{FALSE}: Der Parameter ist \textbf{statisch}.
            \item \textbf{DEFERRED}: \"Anderungen an einem so markierten Parameter haben nur auf neue Sessions, die nach der \"Anderung erstellt wurden eine Auswirkung.
          \end{itemize}
        \subsubsection{Initialisierungsparameter \"andern}
          Initialisierungsparameter k\"onnen per \languageorasql{ALTER SYSTEM}-SQL-Kommando oder im Enterprise Manager ge\"andert werden. \beispiel{admin15} zeigt wie der Parameter \identifier{license\_max\_sessions} von 0 auf 50 ge\"andert wird.
          \begin{merke}
            Der Parameter \identifier{license\_max\_sessions} legt fest, wie viele gleichzeitige Verbindungen zur Datenbank m\"oglich sind. Ist der Schwellenwert von \identifier{license\_max\_sessions} erreicht, k\"onnen sich nur noch Nutzer an der Datenbank anmelden, die das Privileg \privileg{restricted\_session} haben.
          \end{merke}
          \begin{lstlisting}[caption={\parameter{license\_max\_sessions} wird ge\"andert},label=admin15,language=oracle_sql,alsolanguage=sqlplus]
SQL> show parameter license_max_sessions

NAME                                 &TYPE&        VALUE
------------------------------------ ----------- ------------------------------
license_max_sessions                 integer     0

SQL> ALTER SYSTEM
  2  SET license_max_sessions = 50 SCOPE=both;

System altered.
          \end{lstlisting}
          Das \languageorasql{ALTER SYSTEM}-Kommando hat in \beispiel{admin15} zwei Klauseln:
          \begin{itemize}
            \item \languageorasql{SET <parameter> = wert}: Gibt den zu ver\"andernden Parameter und den neuen Wert an. Welche Werte zul\"assig sind, h\"angt vom jeweiligen Parameter ab.
            \item \languageorasql{SCOPE = <scope>}: Mit der \languageorasql{SCOPE}-Klausel wird geregelt, wo die \"Anderung vollzogen wird.
          \end{itemize}
          Die \languageorasql{SCOPE}-Klausel kennt drei Werte f\"ur \languageorasql{<scope>}:
          \begin{itemize}
            \item \languageorasql{SCOPE=both}: Die \"Anderung erfolgt in der SGA und im SPFILE.
            \item \languageorasql{SCOPE=memory}: Die \"Anderung erfolgt nur in der SGA.
            \item \languageorasql{SCOPE=spfile}: Die \"Anderung  erfolgt nur im SPFile. Damit der neue Wert wirksam wird, muss die Instanz neu gestartet werden.
          \end{itemize}
          \begin{merke}
            \languageorasql{SCOPE=both} ist die Standardeinstellung und kann deshalb entfallen.
          \end{merke}

          \begin{literaturinternet}
            \item \cite{i2053602}
          \end{literaturinternet}
      \subsection{Sessionparameter}
        Im Gegensatz zu Initialisierungsparametern, die systemweite G\"ultigkeit haben, sind Sessionparameter nur innerhalb der Session eines Nutzers g\"ultig. Beispielsweise kann der Sessionparameter \parameter{nls\_language} von jedem Nutzer, der das \privileg{ALTER SESSION} besitzt, ge\"andert werden. D. h. w\"ahrend Nutzer A mit deutschen Spracheinstellungen arbeitet, kann Nutzer B zur gleichen Zeit in englischer Sprache arbeiten.
        \subsubsection{Sessionparameter \"andern}
          \"Anderungen an Sessionparametern werden mit dem SQL-Kommando \languageorasql{ALTER SESSION} durchgef\"uhrt, dessen Syntax dem \languageorasql{ALTER SYSTEM}-Kommando sehr \"ahnlich ist.

          Ge\"andert werden k\"onnen einige dynamische Initialisierungsparameter, sowie alle Sessionparameter. Welche Initialisierungsparameter betroffen sind, kann wiederum mit Hilfe der View \identifier{v\$system\_parameter} und der Spalte \identifier{isses\_modifiable} ermittelt werden. Eine Liste der Sessionparameter kann aus der Oracle-Onlinedokumentation entnommen werden.
          \begin{lstlisting}[caption={Sessionmodifiable
          Initialisierungsparameter},label=admin16,language=oracle_sql,alsolanguage=sqlplus]
 SQL> col name format a30

SQL> SELECT name, isses_modifiable
  2  FROM   v$system_parameter;
          \end{lstlisting}
          \begin{literaturinternet}
            \item \cite{autoId0}
            \item \cite{sthref3228}
          \end{literaturinternet}
          \begin{lstlisting}[caption={Beispiel f\"ur ALTER SESSION},label=admin17,language=oracle_sql,alsolanguage=sqlplus]
SQL>show parameter nls_language

NAME                                 &TYPE&        VALUE
------------------------------------ ----------- ------------------------------
nls_language                         string      GERMAN

SQL>ALTER SESSION
  2 SET nls_language = 'AMERICAN';

Session altered.
          \end{lstlisting}
\clearpage
          Das Ergebnis des \languageorasql{ALTER SESSION}-Statements aus \beispiel{admin17} kann nicht mit Hilfe des SQL*Plus-Kommandos \languagesqlplus{show parameter} gepr\"uft werden, da dieses nur Systemparameter anzeigt, aber keine Sessionparameter. Die Werte aller NLS-Sessionparameter k\"onnen mit Hilfe der View \identifier{v\$nls\_parameters} angezeigt werden.
          \begin{lstlisting}[caption={Sessionparameter mit Hilfe von \identifier{v\$nls\_parameters} ermitteln},label=admin17a,language=oracle_sql,alsolanguage=sqlplus]
SQL> col parameter format a30
SQL> col value format a30

SQL> SELECT *
  2  FROM   v$nls_parameters
  3  WHERE  parameter LIKE 'NLS_LANGUAGE';

PARAMETER                         VALUE
--------------------------------- ---------------------------------
NLS_LANGUAGE                      AMERICAN
          \end{lstlisting}
      \subsection{SPFiles/PFiles generieren}
        Oracle bietet verschiedene M\"oglichkeiten, um ein PFile bzw. ein SPFile zu erzeugen:
        \begin{itemize}
          \item SPFile aus einem PFile
          \item SPFile aus den aktuellen Initialisierungsparametern der Instanz
          \item PFile aus einem SPFile
          \item PFile aus den aktuellen Initialisierungsparametern der Instanz
        \end{itemize}
        \subsubsection{Ein SPFile generieren}
          Da ein SPFile eine Bin\"ardatei ist, kann es nicht von Hand erstellt werden. Oracle stellt das Kommando \languageorasql{CREATE SPFILE} zur Verf\"ugung, um ein SPFile aus einem PFile  zu generieren.

          \beispiel{admin18} zeigt die Syntax des \languageorasql{CREATE SPFILE}-Kommandos. Angaben in eckigen Klammern sind optional.
          \begin{lstlisting}[caption={\languageorasql{CREATE SPFILE}},label=admin18,language=oracle_sql]
CREATE SPFILE = [pfad/dateiname.ora]
FROM   PFILE  = [pfad/dateiname.ora];
          \end{lstlisting}
          Die \languageorasql{SPFILE}-Klausel kann wahlweise den Dateinamen der Zieldatei annehmen. Wird kein Dateinamen angegeben, wird die Datei \oscommand{ORACLE\_HOME/dbs/spfile<SID>.ora} angelegt. Dies funktioniert jedoch nur, wenn die Instanz heruntergefahren ist, da Oracle sonst den Speicherort der Datei \oscommand{ORACLE\_HOME/dbs/spfile<SID>.ora} sch\"utzt, so dass diese nicht \"uberschrieben werden kann.
          \begin{merke}
            Ist die Instanz gestartet, muss f\"ur die \languageorasql{SPFILE}-Klausel ein Dateiname angegeben werden, da Oracle sonst die Fehlermeldung \enquote{\oscommand{ORA-32002: cannot create SPFILE already being used by the instance}} anzeigt.
          \end{merke}

          Dient ein PFile als Quelle kann  hier optional der Name der Quelldatei angegeben werden. Ohne Dateiname wird die Datei \oscommand{ORACLE\_HOME/dbs/init<SID>.ora} als Quelle genutzt. Ist diese Datei nicht vorhanden, antwortet Oracle mit der Fehlermeldung:

          \oscommand{ORA-01078: failure in processing system parameters}\\
          \oscommand{LRM-00109: could not open parameter file}\\
          \oscommand{'/u01/app/oracle/product/11.2.0/ORCL/dbs/initorcl.ora'}

          Durch die Angabe von MEMORY, statt PFILE, kann ein SPFile mit den Werten der aktuellen Initialisierungsparameter erzeugt werden.\beispiel{admin19} zeigt verschiedene Varianten des \languageorasql{CREATE SPFILE}-Kommandos.
          \begin{lstlisting}[caption={Beispiele f\"ur \languageorasql{CREATE SPFILE}},label=admin19,language=oracle_sql]
SQL> CREATE SPFILE
  2  FROM   PFILE;

File created.

SQL> CREATE SPFILE = '/home/oracle/spfileorcl.ora'
  2  FROM   PFILE;

File created.

SQL> CREATE SPFILE = '/home/oracle/spfileorcl.ora'
  2  FROM  PFILE   = '?/dbs/initorcl.ora'

File created.

SQL> CREATE SPFILE = '/home/oracle/spfileorcl.ora'
  2  FROM  MEMORY;

File created.
          \end{lstlisting}
          \begin{merke}
            Das \oscommand{?} in einer Pfadangabe dient als Synonym f\"ur die Umgebungsvariable \oscommand{ORACLE\_HOME}.
          \end{merke}

          \begin{merke}
            Wird kein Quell-SPFile angegeben, wird der Wert des Initialisierungsparameters \parameter{spfile} benutzt, um das aktuelle SPFile zu ermitteln. Wird kein Dateiname f\"ur das PFile angegeben, wird im Verzeichnis \oscommand{ORACLE\_HOME/dbs} die Datei \oscommand{init<SID>.ora} angelegt.
          \end{merke}
        \subsubsection{Ein PFile generieren}
          Analog zum Kommando \languageorasql{CREATE SPFILE} existiert das \languageorasql{CREATE PFILE}-Statement.
          \begin{lstlisting}[caption={Beispiele f\"ur \languageorasql{CREATE PFILE}},label=admin20,language=oracle_sql]
SQL> CREATE PFILE
  2  FROM   SPFILE;

SQL> CREATE PFILE = '/home/oracle/initorcl.ora'
  2  FROM   SPFILE;

SQL> CREATE PFILE = '/home/oracle/initorcl.ora'
  2  FROM  SPFILE   = '?/dbs/initorcl.ora'

SQL> CREATE PFILE = '/home/oracle/initorcl.ora'
  2  FROM  MEMORY;
          \end{lstlisting}
      \subsection{Hochfahren einer Instanz mit alternativer Parameterdatei}
        Soll beim Hochfahren der Instanz eine alternative Parameterdatei genutzt werden.          Das Schl\"usselwort \languagesqlplus{pfile} dient dazu, den Namen der alternativen Parameterdatei anzugeben. Es kann nur eine Parameterdatei verarbeiten, keine Serverparameterdatei!
        \begin{lstlisting}[caption={Start mit alternativer Parameterdatei},label=admin21,language=sqlplus]
SQL> startup pfile='/home/oracle/initorcl.ora';
ORACLE instance started.

Total System Global Area  643084288 bytes
Fixed Size                  2215984 bytes
Variable Size             222302160 bytes
Database Buffers          411041792 bytes
Redo Buffers                7524352 bytes
Database mounted.
Database opened.
        \end{lstlisting}
        \begin{literaturinternet}
          \item \cite{i1006091}
        \end{literaturinternet}

    \section{Memory Management}
      Wie in \abschnitt{memorymanagement} bereits beschrieben, kennt Oracle drei verschiedene Arten des Memory Managements: Manual Shared Memory Management, Automatic Shared Memory Management und seit Oracle 11g auch Automatic Memory Management. Die Konfiguration dieser Memory Management Modi funktioniert mit Hilfe von Initialisierungsparametern.
      \subsection{Manual Shared Memory Management}
        Beim Manual Shared Memory Management m\"ussen alle Komponenten der SGA bzw. der PGAs einzeln definiert werden. F\"ur die SGA-Komponenten existieren die folgenden Initialisierungsparameter:
        \begin{itemize}
          \item \parameter{db\_cache\_size}: Legt die Gr\"o\ss{}e des Database Buffer Caches fest.
          \item \parameter{shared\_pool\_size}: Dimensioniert den Shared Pool.
          \item \parameter{large\_pool\_size}: Gibt die Gr\"o\ss{}e des Large Pool an.
          \item \parameter{java\_pool\_size}: Definiert die Gr\"o\ss{}e des Java Pools.
          \item \parameter{streams\_pool\_size}: Legt die Gr\"o\ss{}e des Streams Pools fest.
          \item \parameter{log\_buffer}: Gibt die Gr\"o\ss{}e des Redo Log Buffers an.
        \end{itemize}
        \begin{merke}
          Auf einige Komponenten der SGA, wie z. B. den Large Pool oder den Streams Pool wird in dieser Unterlage nicht n\"aher eingegangen! Zudem existieren noch weitere Parameter, die \"uber den Horizont dieses Skriptes hinausgehen.
        \end{merke}
        Die aktuellen Werte dieser Parameter k\"onnen mit der View \identifier{v\$sgainfo} abgefragt werden.
        \begin{lstlisting}[caption={Gr\"o\ss{}e der SGA-Komponenten ermitteln},label=admin22,language=oracle_sql]
SQL> SELECT name, bytes
  2  FROM   v$sgainfo;

NAME                                  BYTES
-------------------------------- ----------
Fixed SGA Size                      2217264
Redo Buffers                        6926336
Buffer Cache Size                 260046848
Shared Pool Size                  121634816
Large Pool Size                     4194304
Java Pool Size                      4194304
Streams Pool Size                         0
Shared IO Pool Size                       0
Granule Size                        4194304
Maximum SGA Size                  764121088
Startup overhead in Shared Pool    71303168
Free SGA Memory Available         364904448
        \end{lstlisting}
      \subsection{Automatic Shared Memory Management (ASMM)}
        Mit dem Automatic Shared Memory Management kamen in Oracle 10g zwei neue Initialisierungsparameter: \parameter{sga\_target} und \parameter{pga\_aggregate\_target}.

        Um ASMM zu aktivieren, m\"ussen folgende Voraussetzungen gegeben sein:
        \begin{itemize}
          \item Der Parameter \parameter{sga\_target} muss einen Wert gr\"o\ss{}er 0 haben.
          \item Es muss ein SPFile benutzt werden.
          \item Der Parameter \parameter{statistics\_level} muss einen der beiden Werte \enquote{typical} oder \enquote{all} haben.
          \item Der Parameter \parameter{shared\_pool\_size} muss einen Wert gr\"o\ss{}er 0 haben.
        \end{itemize}
        Mit dem \parameter{sga\_target} wird die Speichergesamtmenge f\"ur alle Komponenten der SGA gesetzt. Er ist dynamisch und kann somit jederzeit ge\"andert werden. Seine maximale Gr\"o\ss{}e wird durch den statischen Parameter \parameter{sga\_max\_size} begrenzt (Hardlimit).

        Damit die Einstellungen f\"ur die SGA-Komponenten auch nach einem Neustart der Instanz erhalten bleiben, werden in der Parameterdatei zus\"atzliche Initialisierungsparameter gef\"uhrt: \parameter{\_\_db\_cache\_size}, \parameter{\_\_shared\_pool\_size}, \parameter{\_\_large\_pool\_size}, \parameter{\_\_java\_pool\_size} und \parameter{\_\_streams\_pool\_size}. Diese Parameter, die an dem doppelten Unterstrich vor ihrem Namen zu erkennen sind, dienen als Zwischenspeicher bis zum n\"achsten Instanzstart.

        Zus\"atzlich zu \parameter{sga\_target} kann der DBA Parameter, wie \parameter{db\_cache\_size}, \parameter{shared\_pool\_size} oder \parameter{large\_pool\_size} dazu benutzen, um Mindestgr\"o\ss{}en f\"ur diese Speicherbereiche zu setzen. Hierzu ein Beispiel:
        \begin{lstlisting}[caption={Ein Rechenbeispiel},label=admin23,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET sga_target = 600M;

System altered.

SQL> ALTER SYSTEM
  2  SET shared_pool_size = 50M;

System altered.

SQL> ALTER SYSTEM
  2  SET db_cache_size = 200M;
        \end{lstlisting}
        Wird eine Instanz, wie in \beispiel{admin23} konfiguriert, entfallen mindestens 50 Megabyte auf den Shared Pool, mindestens 200 Megabyte auf den Database Buffer Cache und 350 Megabyte k\"onnen auf alle anderen Komponenten der SGA verteilt werden.
\clearpage
        Zur Verwaltung der PGAs gibt es \parameter{pga\_aggregate\_target}. Dieser Parameter legt die gesamte Speichermenge fest, die f\"ur alle PGAs zur Verf\"ugung steht. Statt einer fixen PGA-Gr\"o\ss{}e, die der DBA selbst festlegen muss, kann die Datenbank nun selbst entscheiden, wie gro\ss{} jede einzelne PGA werden kann. Serverprozesse die eine gr\"o\ss{}ere PGA ben\"otigen k\"onnen somit mehr Speicherplatz erhalten, als andere.

        Problematisch an dieser Form der Speicherverwaltung ist, dass wenn ein zu kleiner Wert f\"ur \parameter{sga\_target} und ein zu gro\ss{}er f\"ur \parameter{pga\_aggregate\_target} gesetzt wird, die Datenbank keinen automatischen Ausgleich schaffen kann, falls die SGA mehr Memory ben\"otigt. Hier muss dann der DBA eingreifen und selbstst\"andig die Werte anpassen.
      \subsection{Automatic Memory Management}
        Das mit Oracle 11g neu eingef\"uhrte Automatic Memory Management vereinfacht die Situation des DBAs erneut. Es kommen zwei neue Parameter hinzu:
        \begin{itemize}
          \item \parameter{memory\_target}: Dieser dynamische Parameter definiert die Gr\"o\ss{}e aller Speicherkomponenten der Instanz (SGA + PGA).
          \item \parameter{memory\_max\_target}: Dies ist ein statischer Parameter, der als hartes Limit f\"ur \parameter{memory\_target} fungiert.
        \end{itemize}
        Der Vorteil dieser neuen Methode ist, dass die Datenbank automatisch einen Ausgleich zwischen SGA und PGA schaffen kann, falls eine der beiden Seiten zu wenig Speicher hat. F\"ur das Automatic Memory Management gelten folgende Regeln:
        \begin{center}
          \tablecaption{Regeln f\"ur das Automatic Memory Management}
          \label{rulesforautomaticmemorymanagement}
          \begin{small}
            \tablefirsthead{
              \multicolumn{1}{c}{\parameter{memory\_target}} &
              \multicolumn{1}{c}{\parameter{sga\_target}} &
              \multicolumn{1}{c}{\parameter{pga\_aggregate\_target}} &
              \multicolumn{1}{c}{\parameter{sga\_max\_size}} &
              \multicolumn{1}{c}{\textbf{Auswirkung}} \\
              \hline
            }
            \tablehead{
              \multicolumn{1}{c}{\parameter{memory\_target}} &
              \multicolumn{1}{c}{\parameter{sga\_target}} &
              \multicolumn{1}{c}{\parameter{pga\_aggregate\_target}} &
              \multicolumn{1}{c}{\parameter{sga\_max\_size}} \\
              \hline
            }
            \tabletail{
              \hline
            }
            \tablelasttail {
              \hline
            }
            \begin{supertabular}{|c|c|c|c|p{4.41cm}|}
              $x \neq 0$ & $x \neq 0$ & $x \neq 0$ & - & Die 2 Parameter \parameter{sga\_target} sowie \parameter{pga\_aggregate\_target} sind Min\-dest\-werte. \\
              \hline
              $x \neq 0$ & $x \neq 0$ & n. a. & - & \parameter{memory\_target} - \parameter{sga\_target} = \parameter{pga\_aggregate\_target}\\
              \hline
              $x \neq 0$ & n. a. & n. a. & - & \parameter{memory\_target} - Wert von  \parameter{pga\_aggregate\_target} ergibt \parameter{sga\_target} \\
              \hline
              $x \neq 0$ & 0 & 0 & 0 & \parameter{pga\_aggregate\_target}: 40 \% und \parameter{sga\_target}: 60 \% von \parameter{memory\_target}\\
            \end{supertabular}
          \end{small}
        \end{center}
\clearpage
        \begin{lstlisting}[caption={Auszug aus einer Parameterdatei},label=admin24,language=terminal]
orcl.__db_cache_size=260046848
orcl.__java_pool_size=4194304
orcl.__large_pool_size=4194304
orcl.__pga_aggregate_target=268435456
orcl.__sga_target=402653184
orcl.__shared_pool_size=121634816
orcl.__streams_pool_size=0
*.compatible='11.2.0.0.0'
*.db_block_size=8192
*.db_domain='local'
*.db_name='orcl'
*.memory_max_target=730M
*.memory_target=640M
        \end{lstlisting}
    \section{Verwaltung von Kontrolldateien}
      Eine Kontrolldatei ist eine Bin\"ardatei, welche die Struktur einer Oracle-Datenbank aufzeichnet. Jede Oracle-Datenbank ben\"otigt eine Kontrolldatei. Sie beinhaltet folgende Informationen:
      \begin{itemize}
        \item Globaler Datenbankname
        \item Dateinamen und Speicherorte der Daten- und Redo Log Dateien
        \item Zeitstempel der Datenbankerstellung
        \item Die aktuelle Log Sequence Number
        \item Checkpoint-Informationen
      \end{itemize}
      Um eine Datenbank \"offnen zu k\"onnen, muss der Schreibzugriff auf die Kontrolldateien m\"oglich sein. Generiert werden diese Dateien w\"ahrend der Datenbankerstellung. Standardm\"a\ss ig wird immer nur eine erstellt, der Administrator sollte jedoch daf\"ur sorgen, dass mehrere Sicherheitskopien der Kontrolldatei auf mehreren Speichermedien (Spiegelung) zur Verf\"ugung stehen.
      \subsection{Namensgebung f\"ur Kontrolldateien}
        Welche Kontrolldateien die Datenbank benutzt, wird durch den Initialisierungsparameter \parameter{control\_files} in der Serverparameterdatei festgelegt. Er kann eine Liste von Dateinamen enthalten, wie das folgende Beispiel zeigt.
\clearpage
				\begin{lstlisting}[caption={Der Parameter \parameter{control\_files}},label=admin25,language=terminal]
...
CONTROL_FILES='/u02/oradata/orcl/control01.ctl',
              '/u05/fast_recovery_area/orcl/control02.ctl'
...
        \end{lstlisting}
        \begin{merke}
          Es werden alle angegebenen Kontrolldateien ge\"offnet und parallel in diese geschrieben.
        \end{merke}
      \subsection{Multiplexing der Kontrolldateien}
        Jede Oracle-Datenbank sollte mindestens zwei Kopien einer Kontrolldatei
        haben, die auf verschiedenen Datentr\"agern gespeichert sind.
        Wurde eine Kontrolldateikopie w\"ahrend des laufenden Betriebs
        besch\"adigt, st\"urzt die Instanz meist sofort ab.

        Nach der Behebung des Medienfehlers kann die kaputte Kontrolldatei durch eine funktionsf\"ahige Kopie erneuert werden.

        Die Datenbank verwendet ihre Kontrolldateien wie folgt:
        \begin{itemize}
          \item Es wird gleichzeitig in alle Kontrolldateien geschrieben.
          \item Nur die erste aufgelistete Kontrolldatei wird gelesen
          \item Wird eine Kopie besch\"adigt, st\"urzt die Instanz meistens ab.
        \end{itemize}
        Eine Variante Kontrolldateien zu spiegeln ist, sie auf allen Datentr\"agern, die eine Redo Log Datei enthalten zu verteilen, da auch die Redo Logs gespiegelt werden sollten.
      \subsection{Hinzuf\"ugen und l\"oschen von Kontrolldateikopien}
        \subsubsection{Hinzuf\"ugen einer weiteren Kontrolldateikopie}
          Die zum Hinzuf\"ugen einer Kontrolldateikopie notwendigen Schritte sind:
        \begin{enumerate}
          \item Instanz herunterfahren und in die NOMOUNT-Phase bringen
            \begin{lstlisting}[caption={Hinzuf\"ugen von Kontrolldateikopien 1},label=admin26,language=sqlplus]
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

SQL> startup nomount
ORACLE instance started.
            \end{lstlisting}
          \item Kopieren einer funktionsf\"ahigen Kontrolldateikopie an den neuen Speicherort
            \begin{lstlisting}[caption={L\"oschen von Kontrolldateikopien 3},label=admin26a,language=sqlplus]
SQL> host cp /u02/oradata/orcl/control01.ctl /u03/oradata/orcl/control03.ctl
            \end{lstlisting}
          \item Den Parameter \parameter{control\_files} mit \languageorasql{ALTER SYSTEM} bearbeiten.
            \begin{lstlisting}[caption={Hinzuf\"ugen von Kontrolldateikopien 2},label=admin27,language=oracle_sql,alsolanguage=sqlplus]
SQL> show parameter control_files

NAME                                 &TYPE&     VALUE
------------------------------------ -------- ------------------------------
control_files                        string   /u02/oradata/orcl/control01.ct
                                              l, /u05/fast_recovery_area/orc
                                              l/control02.ctl
SQL> ALTER SYSTEM
  2  SET control_files='/u02/oradata/orcl/control01.ctl',
                       '/u05/fast_recovery_area/orcl/control02.ctl',
                       '/u03/oradata/orcl/control03.ctl'
  3  SCOPE=spfile;
            \end{lstlisting}
          \item Neustart der Instanz
        \end{enumerate}

        \subsubsection{L\"oschen von Kontrolldateikopien}
        Zum L\"oschen einer Kontrolldateikopie sind drei Schritte notwendig:
        \begin{enumerate}
          \item Instanz herunterfahren und in die NOMOUNT-Phase bringen
            \begin{lstlisting}[caption={L\"oschen von Kontrolldateikopien 1},label=admin28,language=sqlplus]
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

SQL> startup nomount
ORACLE instance started.
            \end{lstlisting}
          \item Den Parameter \parameter{control\_files} mit \languageorasql{ALTER SYSTEM} bearbeiten.
            \begin{lstlisting}[caption={L\"oschen von Kontrolldateikopien 2a},label=admin29,language=sqlplus]
SQL> show parameter control_files

NAME                                 &TYPE&     VALUE
------------------------------------ -------- ------------------------------
control_files                        string   /u02/oradata/orcl/control01.ct
                                              l, /u05/fast_recovery_area/orc
                                              l/control02.ctl
						\end{lstlisting}
\clearpage
						\begin{lstlisting}[caption={L\"oschen von Kontrolldateikopien
						2b},language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET control_files='/u02/oradata/orcl/control01.ctl'
  3  SCOPE=spfile;
            \end{lstlisting}
          \item L\"oschen der Kontrolldateikopie mit Hilfe des Betriebssystems
            \begin{lstlisting}[caption={L\"oschen von Kontrolldateikopien 3},label=admin29a,language=sqlplus]
SQL> host rm -f /u05/fast_recovery_area/orcl/control02.ctl
            \end{lstlisting}
          \item Neustart der Instanz
        \end{enumerate}

        \begin{literaturinternet}
          \item \cite{i1006088}
        \end{literaturinternet}

    \section{Verwalten der Redo Logs}
      F\"ur den Betrieb einer Oracle-Datenbank wird ein Set aus \enquote{Redo Log Gruppen}, umgangssprachlich als \enquote{Redo Logs} bezeichnet, ben\"otigt. Eine Redo Log Gruppe besteht aus einer oder mehreren Redo Log Dateien, die auch als Redo Log Member bezeichnet werden. Die prim\"are Funktion der Redo Logs ist das Aufzeichnen aller \"Anderungen, die an den Daten vorgenommen wurden (Nutz- und Metadaten).
      \subsection{Redo Log Gruppen und Member erstellen}
        Obwohl die Konfiguration der Redo Log Gruppen bereits vor der Installation einer Datenbank erdacht werden sollte, kann es notwendig werden, weitere Redo Log Gruppen oder neue Member zu erstellen. F\"ur die Erstellung von Redo Log Gruppen und Membern muss der Nutzer das Privileg \privileg{ALTER DATABASE} besitzen.

        Das Erzeugen einer neuen Redo Log Gruppe geschieht mit \languageorasql{ALTER DATABASE ADD LOGFILE}.
          \begin{lstlisting}[caption={Erzeugen einer Redo Log Gruppe},label=admin30,language=oracle_sql]
SQL> ALTER DATABASE
  2  ADD LOGFILE '/u02/oradata/orcl/redo04a.log'
  3  SIZE 50M;
          \end{lstlisting}
          \begin{merke}
            Es sollte immer eine vollst\"andige Pfadangabe f\"ur die Member verwendet werden, da diese sonst im Verzeichnis \oscommand{ORACLE\_HOME/dbs} erstellt werden.
          \end{merke}
          Das obige Statement kann durch die Angabe der Redo Log Gruppen Nummer erweitert werden:
          \begin{lstlisting}[caption={Erzeugen einer Redo Log Gruppe mit Angabe der Gruppennummer},label=admin31,language=oracle_sql]
SQL> ALTER DATABASE
  2  ADD LOGFILE GROUP 5
  3  ('/u02/oradata/orcl/redo05a.log',
  4   '/u03/oradata/orcl/redo05b.log')
  5  SIZE 50M;
          \end{lstlisting}
          Die Angabe von \languageorasql{GROUP 5} sorgt daf\"ur, das die Datenbank versucht, die neue Redo Log Gruppe mit der Nummer 5 zu erstellen. Dies kann aber nur funktionieren, wenn diese Nummer noch nicht belegt ist. Die beiden neu erstellten Gruppen k\"onnen durch die View \identifier{v\$log} sichtbar gemacht werden.
          \begin{lstlisting}[caption={Die View \identifier{v\$log}},label=admin32,language=oracle_sql]
SQL> SELECT   group&\#&, members,
  2           bytes / POWER(1024, 2) AS Megabytes
  3  FROM     v$log
  4  ORDER BY group&\#&;

    &GROUP\#&     MEMBERS  MEGABYTES
---------- ---------- ----------
         1          1         50
         2          1         50
         3          1         50
         4          1         50
         5          2         50
          \end{lstlisting}
          Die Spalte \identifier{members} zeigt, dass die Gruppen 1 bis 4 mit jeweils nur einem Member angelegt wurden, was eine sehr gef\"ahrliche Konfiguration darstellt. Wird dieser eine Member besch\"adigt, ist folglich die gesamte Gruppe besch\"adigt. Dies f\"uhrt zu Problemen bei einem Datenbank-Recovery-Vorgang, wenn der Memberausfall nicht rechtzeitig bemerkt wird.
        \subsubsection{Redo Log Member einer Gruppe hinzuf\"ugen}
          Um einer Redo Log Gruppe einen neuen Member hinzuzuf\"ugen, wird das SQL-Kommando \languageorasql{ALTER DATABASE ADD LOGFILE MEMBER}, zusammen mit dem Dateinamen des Members, sowie der Nummer der betroffenen Redo Log Gruppe verwendet.
          \begin{lstlisting}[caption={Hinzuf\"ugen eines Members zu einer Redo Log Gruppe},label=admin33,language=oracle_sql]
SQL> ALTER DATABASE
  2  ADD LOGFILE MEMBER '/u03/oradata/orcl/redo01b.log'
  3  TO GROUP 1;
          \end{lstlisting}
          Passend zur View \identifier{v\$log}, die Informationen zu allen Log Gruppen anzeigt, gibt es auch die View \identifier{v\$logfile}. Dies befasst sich mit den Redo Log Members.
\clearpage
          \begin{lstlisting}[caption={Informationen \"uber Redo Log Member sammeln},label=admin34,language=oracle_sql,alsolanguage=sqlplus]
SQL> col member format a50
SQL> SELECT group&\#&, member
  2  FROM   v$logfile;

    GROUP&\#& MEMBER
---------- --------------------------------------------------
         3 /u02/oradata/orcl/redo03.log
         2 /u02/oradata/orcl/redo02.log
         1 /u02/oradata/orcl/redo01.log
         1 /u03/oradata/orcl/redo01b.log
         4 /u02/oradata/orcl/redo04a.log
         5 /u02/oradata/orcl/redo05a.log
         5 /u03/oradata/orcl/redo05b.log
          \end{lstlisting}
      \subsection{Redo Logs verschieben/umbenennen}
        Es gibt Situationen, die es notwendig machen, Redo Log Member an einen anderen Speicherort zu verschieben. Dies ist beispielsweise dann der Fall, wenn ein Datentr\"ager aus dem System entfernt werden soll oder wenn ein Datentr\"ager eine zu hohe Auslastung hat, weil sich zu viele Redo Log Dateien, Datendateien und Kontrolldateien darauf befinden.

        Das Verschieben/Umbenennen besteht im Wesentlichen aus zwei Schritten:
        \begin{enumerate}
          \item Verschieben/Umbenennen der Redo Log Datei mit Betriebssystemmitteln
          \item \"Andern des Dateipfades in der Datenbank
        \end{enumerate}
        F\"ur diesen Vorgang muss der Nutzer das Privileg \privileg{ALTER DATABASE} auf Seiten der Datenbank und entsprechende Rechte im Betriebssytem haben.
        \begin{enumerate}
          \item Abfragen von \identifier{v\$logfile}
            \begin{lstlisting}[caption={Speicherorte der Member ermitteln},label=admin35,language=oracle_sql,alsolanguage=sqlplus]
SQL> col member format a50
SQL> SELECT group&\#&, member
  2  FROM   v$logfile;

    GROUP&\#& MEMBER
---------- --------------------------------------------------
         3 /u02/oradata/orcl/redo03.log
         2 /u02/oradata/orcl/redo02.log
         1 /u02/oradata/orcl/redo01.log
         1 /u03/oradata/orcl/redo01b.log
         4 /u02/oradata/orcl/redo04a.log
         5 /u02/oradata/orcl/redo05a.log
         5 /u03/oradata/orcl/redo05b.log
             \end{lstlisting}
          \item Instanz herunterfahren
            \begin{lstlisting}[caption={Instanz herunterfahren},label=admin36,language=sqlplus]
SQL> shutdown immediate
            \end{lstlisting}
          \item Verschieben der Datei \oscommand{/u02/oradata/orcl/redo01.log} mit Betriebssystemmitteln nach \oscommand{/u02/oradata/orcl/redo01a.log}
            \begin{lstlisting}[caption={Verschieben der Redo Log Datei mit BS Mitteln},label=admin36a,language=sqlplus]
SQL> host mv /u02/oradata/orcl/redo01.log /u02/oradata/orcl/redo01a.log
            \end{lstlisting}
          \item Datenbank in die MOUNT-Phase bringen
            \begin{lstlisting}[caption={Datenbank MOUNTen},label=admin37,language=sqlplus]
SQL> startup mount
            \end{lstlisting}
          \item \"Andern des Dateipfades in der Datenbank
                  \begin{lstlisting}[caption={Redo Log Datei umbenennen},label=admin38,language=oracle_sql]
SQL> ALTER DATABASE
  2  RENAME FILE '/u02/oradata/orcl/redo01.log'
              TO '/u02/oradata/orcl/redo01a.log';
            \end{lstlisting}
          \item Datenbank \"offnen
            \begin{lstlisting}[caption={Datenbank \"offnen},label=admin39,language=oracle_sql]
SQL> ALTER DATABASE OPEN;
            \end{lstlisting}
        \end{enumerate}
      \subsection{L\"oschen von Redo Log Gruppen und Membern}
        \subsubsection{Eine Redo Log Gruppe l\"oschen}
          Sollte eine Redo Log Gruppe nicht mehr von N\"oten sein, kann diese gel\"oscht werden. Hierf\"ur ben\"otigt der Nutzer wiederrum das \privileg{ALTER DATABASE}-Privileg. Au\ss erdem sollten vor dem L\"oschen die folgenden Punkte bedacht werden:
          \begin{itemize}
            \item Jede Instanz ben\"otigt mindestens zwei Redo Log Gruppen mit einer beliebigen Anzahl von Membern.
            \item Nur eine Redo Log Gruppe, die den Status Inactive oder Unused hat, kann gel\"oscht werden.
            \item Falls die Archivierung f\"ur Redo Logs aktiviert ist, sollte vorher gepr\"uft werden, ob die zu l\"oschende Gruppe bereits archiviert wurde.
          \end{itemize}
\clearpage
            \begin{enumerate}
              \item Pr\"ufen, ob die Redo Log Gruppe inaktiv ist und evtl. bereits archiviert wurde
                \begin{lstlisting}[caption={Status der Redo Logs pr\"ufen},label=admin40,language=oracle_sql]
SQL> SELECT group&\#&, archived, status
  2  FROM   v$log;
                \end{lstlisting}
              \item Durchf\"uhren eines Log Switches und eines Checkpoints, damit die Gruppe in den Status \enquote{inactive} wechselt.
                \begin{lstlisting}[caption={Log Switch + Checkpoint durchf\"uhren},label=admin41,language=oracle_sql]
SQL> ALTER SYSTEM SWITCH LOGFILE;

SQL> ALTER SYSTEM CHECKPOINT;
                \end{lstlisting}
              \item Redo Log Gruppe l\"oschen
              \begin{lstlisting}[caption={Log Gruppe l\"oschen},label=admin42,language=oracle_sql]
SQL> ALTER DATABASE DROP LOGFILE GROUP 5;
                \end{lstlisting}
              \item L\"oschen aller Memberdateien der Redo Log Gruppe mit Betriebssystemmitteln.
              \begin{lstlisting}[caption={Log Gruppe l\"oschen},label=admin42a,language=sqlplus]
SQL> host rm /u02/oradata/orcl/redo05a.log /u03/oradata/orcl/redo05b.log
                \end{lstlisting}
            \end{enumerate}
        \subsubsection{Redo Log Member l\"oschen}
          Um einen Member aus einer Redo Log Gruppe l\"oschen zu k\"onnen, ben\"otigt der Nutzer das Privileg \privileg{ALTER DATABASE}. Au\ss erdem sollten vor dem L\"oschen die folgenden Punkte bedacht werden:
          \begin{itemize}
            \item Beim L\"oschen eines Members aus einer Redo Log Gruppe wird die Redo Log Konfiguration kurzzeitig asymetrisch. Dieser Zustand sollte so schnell wie m\"oglich bereinigt werden.
            \item Nur in einer Redo Log Gruppe, die den Status Inactive oder Unused hat, k\"onnen Member gel\"oscht werden.
            \item Falls die Archivierung f\"ur Redo Logs aktiviert ist, sollte vorher gepr\"uft werden, ob die zu l\"oschende Gruppe bereits archiviert wurde.
            \item Der letzte Member einer Redo Log Gruppe kann nicht gel\"oscht werden. Es muss dann die ganze Gruppe gel\"oscht werden.
          \end{itemize}
\clearpage
          \begin{enumerate}
            \item Pr\"ufen, ob die Redo Log Gruppe inaktiv ist und evtl. bereits archiviert wurde
              \begin{lstlisting}[caption={Status der Redo Logs pr\"ufen},label=admin43,language=oracle_sql]
SQL> SELECT group&\#&, archived, status
  2  FROM   v$log;
              \end{lstlisting}
            \item Durchf\"uhren eines Log Switches und eines Checkpoints, damit die Gruppe in den Status \enquote{inactive} wechselt.
              \begin{lstlisting}[caption={Log Switch + Checkpoint durchf\"uhren},label=admin44,language=oracle_sql]
SQL> ALTER SYSTEM SWITCH LOGFILE;

SQL> ALTER SYSTEM CHECKPOINT;
              \end{lstlisting}
            \item Redo Log Member l\"oschen
            \begin{lstlisting}[caption={Log Member l\"oschen},label=admin45,language=oracle_sql]
SQL> ALTER DATABASE
  2  DROP LOGFILE MEMBER '/u03/oradata/orcl/redo01b.log';
            \end{lstlisting}
            \begin{lstlisting}[caption={Log Member l\"oschen},label=admin45a,language=sqlplus]
SQL> host rm -f /u03/oradata/orcl/redo01b.log
            \end{lstlisting}
          \end{enumerate}
          Zuletzt muss die betreffende Datei noch betriebssystemseitig gel\"oscht werden.
      \subsection{Defekte Member bearbeiten}
        \subsubsection{Status von Redo Log Membern}
          Wird ein Redo Member besch\"adigt, erh\"alt er einen Fehlerstatus. Dieser kann in der View \identifier{v\$logfile} aus der Spalte \identifier{status} ersehen werden. Es gibt folgende Stati:
          \begin{itemize}
          \item \textbf{NULL} (Kein Wert): Ist die Statusspalte leer, ist der Redo Log Member voll funktionsf\"ahig.
          \item \textbf{INVALID}: Aus einem nicht n\"aher definierten Grund, kann auf die Datei nicht zugegriffen werden.
          \item \textbf{STALE}: Der Inhalt der Redo Log Member Datei ist nicht vollst\"andig. Dies kann entstehen, wenn w\"ahrend der Nutzung einer Redo Log Gruppe die Instanz abst\"urzt.
          \item \textbf{DELETED}: Dieser Status zeigt an, dass die Datei gel\"oscht wurde.
        \end{itemize}
\clearpage
        \subsubsection{Leeren einer Redo Log Gruppe}
          Wenn im laufenden Betrieb der Datenbank eine Redo Log Gruppe zerst\"ort wird und damit die Archivierung unm\"oglich geworden ist, muss die besch\"adigte Gruppe geleert werden. Der Vorteil dieser Methode ist, dass die Datenbank hierzu nicht heruntergefahren werden muss. Weiterhin gibt es zwei F\"alle, in denen das Leeren einer Redo Log Gruppe die einzige M\"oglichkeit darstellt, das Problem zu l\"osen:
          \begin{itemize}
            \item Wenn es nur zwei Redo Log Gruppen gibt
            \item Wenn in der Redo Log Gruppe mit dem Status Current eine Redo Log Datei defekt ist
          \end{itemize}
          Um eine Redo Log Gruppe zu leeren, die gerade in der Archivierung befindlich ist, wird folgendes Kommando verwendet:
          \begin{lstlisting}[caption={Redo Log Gruppe leeren},label=admin46,language=oracle_sql]
SQL> ALTER DATABASE
  2  CLEAR LOGFILE GROUP 3;
        \end{lstlisting}
        Zum Leeren einer noch nicht archivierten Redo Log Gruppe, muss das SQL-Schl\"usselwort \languageorasql{UNARCHIVED} hinzugef\"ugt werden.
        \begin{lstlisting}[caption={Eine nicht archivierte Redo Log Gruppe leeren},label=admin47,language=oracle_sql]
SQL> ALTER DATABASE
  2  CLEAR UNARCHIVED LOGFILE GROUP 3;
        \end{lstlisting}
        Dieses Statement verhindert, dass die betreffende Redo Log Gruppe jemals archiviert wird.
        \begin{merke}
          Zu beachten ist: Wird eine Redo Log Gruppe geleert, die zum Recovery der Datenbank ben\"otigt wird, sind alle Backups, die dieses Redo Log ben\"otigen nutzlos und es sollte sofort ein neues Backup der Datenbank angefertigt werden. In der Alert Log Datei werden die ung\"ultigen Datenbankbackups aufgelistet (nur mit RMAN erstellte Backups).
        \end{merke}
      \subsection{Informationen \"uber Redo Log Gruppen/Member sammeln}
        \begin{literaturinternet}
          \item \cite{i1007497}
        \end{literaturinternet}
    \section{Verwalten der archivierten Redo Logs}
    \label{administeringarchivelogs}
      \subsection{Was sind archivierte Redo Logs}
        Es ist m\"oglich, die gef\"ullten Redo Log Gruppen einer Oracle-Datenbank an einem oder mehreren anderen Speicherorten zu sichern. Diese gesicherten Redo Logs werden als \enquote{Archived Redo Logs} oder einfach als \enquote{Archive Logs} bezeichnet. Der Prozess des Sicherns der Redo Logs hei\ss{}t \enquote{Archiving}\footnote{archiving = engl. Archivierung, Sicherung}.
        \begin{merke}
          Wird eine Redo Log Gruppe durch multiplexing auf mehrere Speicherorte verteilt, archiviert der Archiver-Prozess immer nur eine der identischen Kopien der Redo Log Dateien.
        \end{merke}
        Damit die Redo Logs einer Oracle-Datenbank archiviert werden, muss die Datenbank in den \enquote{Archivelog-Modus} versetzt werden. Das Gegenst\"uck zum Archivelog-Modus ist der \enquote{Noarchivelog-Modus}. Im Noarchivelog-Modus findet keine Archivierung statt.
        Welcher der beiden Modi f\"ur die Datenbank verwendet werden sollte, h\"angt davon ab, ob Datenverlust akzeptabel ist oder nicht.

        \bild{Archivierung der Redo Logs}{archiving}{3}
      \subsection{F\"ur die Archivierung notwendige Initialisierungsparameter}
        \subsubsection{Anzahl der Archiver-Prozesse festlegen}
          Der Initialisierungsparameter \parameter{log\_archive\_max\_processes} legt die Anzahl der zu startenden Archiver-Prozesse fest (Standardwert ist 4). Eine Ver\"anderung dieses Standardwertes ist normalerweise nicht notwendig, da die Datenbank selbstst\"andig zus\"atzliche Archiver-Prozesse startet, wenn dies erforderlich erscheint.
\clearpage
					Ein m\"oglicher Grund f\"ur eine \"Anderung dieses Parameters ist z. B., dass es  performanter ist, gleich die richtige Anzahl Archiver-Prozesse zu starten. Es k\"onnen bis zu 30 Archiver-Prozesse gleichzeitig gestartet werden.

        \subsubsection{Speicherorte der Archiver-Prozesse festlegen}
         Zust\"andig f\"ur die Festlegung der Speicherorte der Archive Logs sind die Initialisierungsparameter \parameter{log\_archive\_dest\_1} bis \parameter{log\_archive\_dest\_31}. Um beispielsweise die beiden Speicherorte \oscommand{/u02/backup/archive\_logs} und \oscommand{/u03/backup/archive\_logs} festzulegen, m\"ussen die beiden Initialisierungsparameter \parameter{log\_archive\_dest\_1} und \parameter{log\_archive\_dest\_2} wie folgt angepasst werden:
          \begin{lstlisting}[caption={log\_archive\_dest-Parameter setzen},label=admin48,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET log_archive_dest_1='LOCATION=/u02/backup/archive_logs';
SQL> ALTER SYSTEM
  2  SET log_archive_dest_2='LOCATION=/u03/backup/archive_logs';
          \end{lstlisting}
        \subsubsection{Dateinamen der Archive Logs konfigurieren}
          Um das Format des Dateinamens f\"ur die Archive Logs zu setzen wird der Parameter \parameter{log\_archive\_format} verwendet. Der komplette Name eines Archive Logs setzt sich dann aus den Parameter \parameter{log\_archive\_dest\_n} + \parameter{log\_archive\_format} zusammen.
          \begin{lstlisting}[caption={\parameter{log\_archive\_format}-Parameter
          setzen},label=admin49,language=oracle_sql,alsolanguage=sqlplus]
SQL> ALTER SYSTEM
  2  SET log_archive_format='arch_%s_%r_%t.log'
  3  SCOPE=spfile;
          \end{lstlisting}
          \begin{merke}
            Hat der Initialisierungsparameter \parameter{compatible} einen Wert gr\"o\ss er oder gleich 10.0, m\"ussen im Parameter \parameter{log\_archive\_format} die Platzhalter \%r, \%s und \%t zwingend verwendet werden. Falls nicht wird die Fehlermeldung \enquote{\oscommand{ORA-19905: log\_archive\_format must contain \%s, \%t and \%r}} ausgel\"ost.
          \end{merke}
          Die Konfiguration der Archive Log Destination kann mittels der View \identifier{v\$archive\_dest} abgefragt werden.
          \begin{lstlisting}[caption={Die Konfiguration der Archive Log Destination abfragen},label=admin50,language=sqlplus]
SQL> col dest_name format a20
SQL> col destination format a30
SQL> col error format a40
SQL> set linesize 300
					\end{lstlisting}
\clearpage
\begin{lstlisting}[caption={Die Konfiguration der Archive Log Destination abfragen - Fortsetzung},label=admin50a,language=oracle_sql]
SQL> SELECT dest_name, status, destination, error
  2  FROM   v$archive_dest
  3  WHERE  dest_id < 3;

DEST_NAME            STATUS    &DESTINATION&               ERROR
------------------- --------- -------------------------- -------------------
LOG_ARCHIVE_DEST_1  VALID     /u02/backup/archive_logs
LOG_ARCHIVE_DEST_2  VALID     /u03/backup/archive_logs
          \end{lstlisting}
        \subsubsection{Status der Speicherorte}
          Jede Archive Log Destination ist immer mit einem Status versehen, der etwas \"uber ihre Funktionsf\"ahigkeit und ihre Nutzung aussagt.
        \begin{itemize}
          \item \textbf{Valid/Invalid}: Es wurde ein g\"ultiger bzw. ein ung\"ultiger Speicherort angegeben. G\"ultig hei\ss t, dass der Speicherort existieren muss.
          \item \textbf{Enabled/Disabled}: Ist der Speicherort aktiviert (wird genutzt) oder deaktiviert (wird nicht genutzt)?
          \item \textbf{Active/Inactive}: Ist der Speicherort zug\"anglich oder aufgrund eines Fehlers unzug\"anglich?
        \end{itemize}
        Tabelle \tabelle{redofehlerstatus} zeigt verschiedene Kombinantionen
        dies Stati.
        \begin{center}
          \tablecaption{M\"ogliche Zust\"ande der LOG\_ARCHIVE\_DEST\_n-Speicherorte}
          \tablefirsthead{%
            \hline
            \multicolumn{1}{|c|}{ } &
            \multicolumn{3}{|c|}{\textbf{Eigenschaften}} &
            \multicolumn{1}{|l|}{ }
            \\
            \cline{2-4}
            \multicolumn{1}{|c|}{\textbf{Status}} &
            \multicolumn{1}{c|}{\textbf{Valid}} &
            \multicolumn{1}{c|}{\textbf{Enabled}} &
            \multicolumn{1}{c|}{\textbf{Active}} &
            \multicolumn{1}{l|}{\textbf{Bedeutung}}
            \\
            \hline
          }
          \tablehead {%
          }
          \tabletail{%
            \hline
          }
          \begin{supertabular}[h]{|l|c|c|c|p{6.2cm}|}
            \label{redofehlerstatus}
            \multirow{2}{3cm}{VALID} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Ja} & \footnotesize Es wurde ein g\"ultiger Speicherort angegeben, der auch erreichbar ist. \\
            \hline
            INACTIVE & \multirow{1}{1.5cm}{Nein} & -- & -- & \footnotesize Es wurde kein Speicherort angegeben. \\
            \hline
            \multirow{2}{3cm}{ERROR} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Nein} & \footnotesize Es trat ein Fehler auf, als versucht wurde, am angegebenen Speicherort eine Datei zu erstellen. \\
            \hline
            FULL & \multirow{1}{1.5cm}{Ja} & \multirow{1}{1.5cm}{Ja} & \multirow{1}{1.5cm}{Nein} & \footnotesize Kein freier Speicher am Speicherort verf\"ugbar. \\
            \hline
            \multirow{2}{3cm}{DEFERRED} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Nein} & \multirow{2}{1.5cm}{Ja} & \footnotesize Der Speicherort wurde durch den Nutzer zeitweilig deaktiviert. \\
            \hline
            \multirow{2}{3cm}{DISABLED} & \multirow{2}{1.5cm}{Ja} & \multirow{2}{1.5cm}{Nein} & \multirow{2}{1.5cm}{Nein} & \footnotesize Der Speicherort musste aufgrund eines Zugriffsfehlers zeitweilig deaktiviert werden. \\
            \hline
            \multirow{3}{3cm}{BAD PARAM} & \multirow{3}{1.5cm}{--} & \multirow{3}{1.5cm}{--} & \multirow{3}{1.5cm}{--} & \footnotesize Ein nicht n\"aher definierbarer Fehler ist aufgetreten (z. B. wurde ein ung\"ultiger Wert f\"ur einen Parameter angegeben).\\
          \end{supertabular}
        \end{center}
        \subsubsection{Probleme mit fehlerhaften Speicherorten}
          Es kann vorkommen, dass die Speicherung eines Archive Logs an einem der angegebenen Speicherorte fehlschl\"agt. Oracle stellt verschiedene M\"oglichkeiten bereit, wie auf solche Ausf\"alle reagiert werden kann. Eine M\"oglichkeit besteht darin, mit dem Parameter \parameter{log\_archive\_min\_succeed\_dest} anzugeben, auf wie vielen Speicherorten die Archivierung als erfolgreich gelten muss, ehe die zu archivierende Redo Log Gruppe wieder verwendet werden kann. Standardwert f\"ur diesen Parameter ist 1. Der Maximalwert ist 10.

          In Kombination dazu kann mit jedem \parameter{log\_archive\_dest\_n}-Parameter ein Speicherort als \textit{optional} (Standardwert) oder als \textit{mandatory} \footnote{mandatory = engl. obligatorisch, zwingend} deklariert werden. Je nachdem, wie der Parameter \parameter{log\_archive\_min\_succeed\_dest} eingestellt ist, muss die Archivierung mindestens an allen als mandatory deklarierten Speicherorten erfolgreich gewesen sein, bevor der Log Writer-Prozess die betreffende Redo Log Gruppe wieder verwenden kann.

          Die folgende Tabelle soll das Verhalten der Datenbank verdeutlichen:
          \begin{itemize}
            \item Es wurden 4 Speicherorte deklariert, 2 als optional und 2 als mandatory
            \item \parameter{log\_archive\_min\_succeed\_dest} wird auf die Werte 1 bis 5 eingestellt. Die Spalte Wert zeigt an, auf welchen Wert dieser Parameter gesetzt wurde. Die Spalte Auswirkungen beschreibt welche Auswirkungen diese Einstellung hat.
          \end{itemize}
          \begin{center}
            \tablecaption{Auswirkungen des Parameters log\_archive\_min\_succeed\_dest}
            \tablefirsthead{%
              \hline
              \multicolumn{1}{|c}{\textbf{Wert}}&
              \multicolumn{1}{|l|}{\textbf{Auswirkungen}}
              \\
              \hline
            }
            \tablehead{%
              \hline
              \multicolumn{1}{|c}{\textbf{Wert}}&
              \multicolumn{1}{|l|}{\textbf{Auswirkungen}}
              \\
              \hline
            }
            \tabletail{
              \hline
            }
            \begin{supertabular}[h]{|c|p{13cm}|}
              \multirow{2}{1.5cm}{1} & \footnotesize Die Datenbank ignoriert den f\"ur \parameter{log\_archive\_min\_succeed\_dest} eingestellten Wert und nimmt stattdessen die Anzahl der als mandatory deklarierten Speicherorte. \\
              \hline
              \multirow{3}{1.5cm}{2} & \footnotesize Die Archivierung gilt als erfolgreich, wenn an beiden als mandatory deklarierten Speicherorten die Speicherung erfolgreich war. Die als optional deklarierten Speicherorte werden bei der \"Uberpr\"ufung ignoriert. \\
              \hline
              \multirow{2}{1.5cm}{3} & \footnotesize Es m\"ussen beide als mandatory und mindestens einer der als optional deklarierten Speicherorte erfolgreich gewesen sein, bevor die Archivierung als erfolgreich gilt. \\
              \hline
              \multirow{2}{1.5cm}{4} & \footnotesize Die Archivierung ist erst dann erfolgreich, wenn an allen Speicherorten die Archived Logs gespeichert werden konnten. \\
              \hline
              \multirow{2}{1.5cm}{5} & \footnotesize Es tritt ein Fehler auf, da die Anzahl der Speicherorte geringer ist, als der Wert f\"ur \parameter{log\_archive\_min\_succeed\_dest}. \\
            \end{supertabular}
          \end{center}
          F\"ur das Zusammenspiel zwischen den beiden als mandatory deklarierten Speicherorten und dem Parameter \parameter{log\_archive\_min\_succeed\_dest} gelten die folgenden Regeln:
          \begin{itemize}
            \item Wird ein Speicherort nicht explizit als mandatory deklariert, wird er als optional angesehen.
            \item Wird f\"ur den Parameter \parameter{log\_archive\_min\_succeed\_dest} ein Wert angegeben, wird mindestens ein Speicherort als mandatory betrachtet.
            \item Der Wert f\"ur \parameter{log\_archive\_min\_succeed\_dest} kann nicht gr\"o\ss er sein, als die Anzahl der konfigurierten Speicherorte.
          \end{itemize}
          Das folgende Beispiel zeigt, wie ein Speicherort als mandatory deklariert wird:
          \begin{lstlisting}[caption={\parameter{log\_archive\_dest\_n} als mandatory deklarieren},label=admin51,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET log_archive_dest_1='LOCATION=/u02/backup/archive_logs MANDATORY';
SQL> ALTER SYSTEM
  2  SET log_archive_dest_2='LOCATION=/u03/backup/archive_logs OPTIONAL';
          \end{lstlisting}
      \subsection{Eine Datenbank in den Archivelog-Modus versetzen}
        Eine Datenbank kann bereits bei ihrer Erstellung oder auch nachtr\"aglich in den Archivelog-Modus versetzet werden. Dazu sind folgende Schritte notwendig:
        \begin{enumerate}
          \item Anpassen der Intialisierungsparameter, die f\"ur das Archiving notwendig sind
          \item Instanz konsistent herunterfahren
          \item Die Datenbank in die MOUNT-Phase versetzen.
          \item Den Archivierungsmodus einschalten.
          \item Datenbank \"offnen
          \item (Herunterfahren der Datenbank und durchf\"uhren eines Backups)
          \item (Datenbank hochfahren)
        \end{enumerate}
        \begin{lstlisting}[caption={Archivelog-Modus
        aktivieren},label=admin52,language=oracle_sql,alsolanguage=sqlplus] Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
				\end{lstlisting}
\clearpage
\begin{lstlisting}[caption={Archivelog-Modus aktivieren -
Fortsetzung},label=admin52a,language=oracle_sql,alsolanguage=sqlplus]
SQL> startup mount 
ORACLE instance started.

Total System Global Area  764121088 bytes
Fixed Size                  2217264 bytes
Variable Size             503319248 bytes
Database Buffers          251658240 bytes
Redo Buffers                6926336 bytes
Database mounted.
SQL> ALTER DATABASE ARCHIVELOG;

Database altered.

SQL> ALTER DATABASE OPEN;

Database altered.
        \end{lstlisting}
    \section{Das Data Dictionary}
      Der wichtigste Teile einer Oracle-Datenbank ist das \enquote{Data
      Dictionary}. Es besteht aus einer Menge von Tabellen mit wichtigen
      Metainformationen, auf die alle Nutzer Lesezugriff haben.
      Darunter fallen:
      \begin{itemize}
        \item Die Definitionen aller Schemaobjekte der Datenbank (Tabellen, Views, Indizes, usw.)
        \item Wie viel Speicherplatz f\"ur Schemaobjekte reserviert und aktuell
        genutzt wird
        \item Standardwerte f\"ur Tabellenspalten
        \item Integrit\"ats Constraints
        \item Benutzernamen aller Oracle-Nutzer
        \item Privilegien und Rollen mit Zuordnung zu den Nutzern
        \item Auditing Informationen
        \item Weitere generelle Metainformationen
      \end{itemize}
      Die Tabellen des Data Dictionary sind auf die gleiche Art und Weise organisiert, wie andere Tabellen auch. Sie sind jedoch im \identifier{System}-Tablespace gespeichert und geh\"oren dem Nutzer \identifier{SYS}.

      Nicht nur, dass das Data Dictionary ein zentraler Punkt in der Datebank ist, es stellt auch ein wichtiges Hilfsmittel f\"ur alle Nutzer, vom Endnutzer bis zum Administrator dar. Es kann mit Hilfe von SQL-Befehlen abgefragt, nicht aber ge\"andert werden.

      Der Oracle Nutzer \identifier{SYS} ist Eigent\"umer der Basistabellen und Nutzer-Views des Data Dictionary. Kein anderer Oracle Nutzer au\ss er ihm sollte Zugriff auf diese Tabellen haben, da dies die Datenbankintegrit\"at verletzen k\"onnte.
      \subsection{Benutzung und Struktur des Data Dictionary}
        Das Data Dictionary wird auf drei unterschiedliche Arten genutzt:
        \begin{itemize}
          \item Oracle selbst greift lesend auf das Data Dictionary zu, um Informationen \"uber Nutzer, Privilegien und Schemaobjekte zu erhalten.
          \item Immer wenn ein DDL-Statement abgesetzt wird, wird das Data Dictionary durch Oracle modifiziert
          \item Jeder Oracle Nutzer kann das Data Dictionary als Nachschlagewerk nutzen.
        \end{itemize}
        Das Data Dictionary besteht aus den folgenden Bestandteilen:
        \subsubsection{Dynamic Performance Views (X\$-Views)}
          Oracle verwaltet eine Menge von Pseudo-Views, die als Dynamic Performance Views bezeichnet werden. Es handelt sich hierbei nicht um echte Views. Sie zeigen Informationen \"uber die Instanz und die Datenbank an und werden dynamisch im laufenden Betrieb durch den Kern von Oracle selbst aktualisiert.

          Diese View tragen das Pr\"afix \enquote{x\$} in ihrem Namen. Sie werden bei der Erstellung der Datenbank automatisch mit erstellt. Um den Inhalt der \identifier{x\$}-Views f\"ur Administratoren nutzbar zu machen, hat Oracle zus\"atzlich sogenannte \identifier{v\$}-Views geschaffen.
        \subsubsection{Dynamic Performance Views (V\$-Views)}
          \identifier{v\$}-Views benutzen als Informationsgrundlage die eben beschriebenen \identifier{x\$-Views}. W\"ahrend die Namensgebung bei \identifier{x\$}-Views sehr undurchschaubar ist (z. B. \identifier{x\$ksmfs}, \identifier{x\$ksmss} oder \identifier{x\$kcbwait}) ist die der \identifier{v\$}-Views klar verst\"andlich (z. B. \identifier{v\$session}, \identifier{v\$log} oder \identifier{v\$logfile}). Auch die Struktur der \identifier{v\$}-Views ist f\"ur Administratoren besser zu durchschauen, au\ss{}erdem sind \identifier{v\$}-Views dokumentiert, im Gegensatz zu den \identifier{x\$}-Views.
\clearpage
        \subsubsection{Basis Tabellen}
          Dies sind die zugrundeliegenden Tabellen, die die Metainformationen enthalten. Sie werden nur von der Datenbank selbst genutzt, da sie durch Normalisierung und kryptischen Inhalt f\"ur normale Nutzer wenig durchschaubar sind. Einige Beispiele f\"ur Basistabellen sind \identifier{user\$}, \identifier{tab\$}, \identifier{obj\$} oder \identifier{aud\$}.
        \subsubsection{Nutzer-Views}
          Diese Views stellen eine Zusammenfassung des Inhalts der Basistabellen dar. Sie dekodieren den un\"ubersichtlichen Inhalt der Basistabellen und machen ihn f\"ur Nutzer lesbar. Nicht jeder Nutzer hat auf alle Views Zugriff.
      \subsection{View-Klassen im Data Dictionary}
        Es gibt unterschiedliche Arten von Views im Data Dictionary. Einige sind f\"ur alle Nutzer zug\"anglich, andere nur f\"ur Administratoren. Die einzelnen Klassen k\"onnen an dem Pr\"afix in ihrem Namen erkannt werden. Folgende Klassen gibt es:
        \begin{itemize}
          \item \textbf{USER}: User-Views zeigen, welche Objekte im Schema des Nutzers existieren
          \item \textbf{ALL}: Erweiterte User-Views zeigen, auf welche Objekte der Nutzer Zugriff hat
          \item \textbf{DBA}: Administrative Views zeigen den gesamten Datenbankinhalt
        \end{itemize}
        \begin{merke}
          Nicht von allen Views existieren immer alle drei Klassen, z. B. \identifier{DBA\_LOCKS}.
        \end{merke}
        \subsubsection{Views mit dem Pr\"afix USER}
          Diese Views sind die Interesantesten f\"ur normale Nutzer. Sie haben folgende Eigenschaften:
          \begin{itemize}
            \item Sie zeigen das private Umfeld eines Nutzers, mit all seinen Objekten in der Datenbank.
            \item Sie zeigen nur Tabellenspalten die f\"ur den Nutzer relevant sind.
            \item Sie sind eine Untermenge der Views mit dem Pr\"afix ALL.
					\end{itemize}
\clearpage
					\subsubsection{Views mit dem Pr\"afix ALL}
          ALL-Views zeigen das f\"ur den Nutzer sichtbare Umfeld in der Datenbank. Sie liefern Informationen \"uber alle Datenbankobjekte, auf die der Nutzer Zugriff hat, inklusive der Informationen die durch USER-Views angezeigt werden. Im Gegensatz zu den USER-Views haben die ALL-Views eine Spalte \identifier{OWNER}, die den Eigent\"umer eines Objekts anzeigt.
        \subsubsection{Views mit dem Pr\"afix DBA}
          Views mit dem Pr\"afix DBA zeigen eine umfassende Ansicht der Datenbank mit allen Objekten, Privilegien und Nutzern. Auf diese Views hat nur administratives Personal Zugriff.
        \subsubsection{Die Tabelle DUAL}
          Die Tabelle \identifier{dual} ist eine Tabelle des Data Dictionary mit einer einzigen Spalte names \identifier{dummy}, die den Wert \enquote{X} enth\"alt. Sie ist f\"ur die Durchf\"uhrung von Berechnungen gedacht, wie das folgende Beispiel zeigt.
        \begin{lstlisting}[caption={Die Tabelle DUAL},label=admin53,language=oracle_sql]
SQL> SELECT SYSDATE AS Datum
  2  FROM   dual;

  DATUM
---------
29.08.13
        \end{lstlisting}

        \begin{literaturinternet}
          \item \cite{i125539}
          \item \cite{i2112}
        \end{literaturinternet}
\clearpage
    \section{Informationen}
      \subsection{Verzeichnis der relevanten Initialisierungsparameter}
        \begin{literaturinternet}
          \item \cite{REFRN10019}
          \item \cite{REFRN10021}
          \item \cite{REFRN10033}
          \item \cite{REFRN10075}
          \item \cite{REFRN10079}
          \item \cite{REFRN10086}
          \item \cite{REFRN10089}
          \item \cite{REFRN10090}
          \item \cite{REFRN10091}
          \item \cite{REFRN10094}
          \item \cite{REFRN10284}
          \item \cite{REFRN10285}
          \item \cite{REFRN10123}
          \item \cite{REFRN10165}
          \item \cite{REFRN10202}
          \item \cite{REFRN10198}
          \item \cite{REFRN10256}
          \item \cite{REFRN10243}
          \item \cite{REFRN10214}
        \end{literaturinternet}
\clearpage
      \subsection{Verzeichnis der relevanten Data Dictionary Views}
        \begin{literaturinternet}
          \item \cite{REFRN29014}
          \item \cite{REFRN30007}
          \item \cite{sthref3187}
          \item \cite{REFRN30089}
          \item \cite{sthref3267}
          \item \cite{sthref3423}
          \item \cite{REFRN30129}
          \item \cite{REFRN30128}
          \item \cite{REFRN30159}
          \item \cite{REFRN30314}
          \item \cite{REFRN30275}
        \end{literaturinternet}
\clearpage
