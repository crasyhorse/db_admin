  \chapter{Recovery mit dem RMAN}
  \label{recoverywithrman}
    \setcounter{page}{1}\kapitelnummer{chapter}
    \minitoc
\newpage
    Obwohl der RMAN das Recovery einer Oracle-Datenbank wesentlich vereinfacht, sind im Vorfeld trotzdem noch einige Planungsarbeiten notwendig. Welche dies sind, ist im Wesentlichen von der Art des Datenverlustes abh\"angig.
    \section{Ein Recovery planen und vorbereiten}
      Die Durchf\"uhrung eines Restore und Recovery Prozesses besteht aus 5 Schritten.
      \begin{enumerate}
        \item Ermitteln welche Datenbankdateien wiederhergestellt werden m\"ussen und welche Backups daf\"ur herangezogen werden k\"onnen. Dies kann auch Archive Logs, dass SPFile und die Kontrolldatei einschlie\ss{}en.
        \item Die Datenbank in den ben\"otigten Zustand versetzen. F\"ur ein vollst\"andiges Restore and Recovery der ganzen Datenbank ist dies meist der MOUNT-Status. M\"ussen nur ein einzelner Tabelspace oder einzelne Datendateien wiederhergestellt werden, gen\"ugt es, den betreffenden Tablespace in den Offline-Status zu versetzen.
        \item Durchf\"uhren der Restore-Phase. Hierbei kann es notwendig sein, die Datenbankdateien an einem neuen Speicherort wiederherzustellen, weil der Alte nicht mehr verf\"ugbar ist. Eventuelle Anpassungen am SPFile d\"urfen dabei nicht vergessen werden.
        \item Durchf\"uhren der Recovery-Phase.
        \item Durchf\"uhren von T\"atigkeiten, die zum weiteren Betrieb der Datenbank notwendig sind, z. B. \"offnen der Datenbank.
      \end{enumerate}
      Nicht jeder Recovery-Prozess ben\"otigt immer alle 5 Schritte. Muss beispielsweise nur das SPFile aus einem Backup wiederhergestellt werden, ist ein Recovery der Datenbank nicht notwendig.
    \section{Pflege- und Erhaltungsma\ss{}nahen}
      \subsection{Datenbankdateien auf Fehler pr\"ufen}
        Mit dem \languagerman{VALIDATE}-Kommando k\"onnen Datenbankdateien vor einem Backup auf Funktionsf\"ahigkeit gepr\"uft werden. Dabei wird getestet, ob die Datenbankdateien existieren, ob sie sich am richtigen Speicherort befinden und ob sie physische bzw. logische Besch\"adigungen aufweisen. RMAN verf\"ahrt dabei genauso wie bei einem Backup, nur wird beim Validieren kein Backup Set erzeugt.
\clearpage
        \begin{lstlisting}[caption={Eine Datendatei validieren},label=admin1400,language=rman]
RMAN> VALIDATE datafile 1;

Starting validate at 29-OCT-13
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=25 device type=&DISK&
allocated channel: ORA_DISK_2
channel ORA_DISK_2: SID=145 device type=&DISK&
channel ORA_DISK_1: starting validation of datafile
channel ORA_DISK_1: specifying datafile(s) for validation
input datafile file number=00001 name=/u01/app/oracle/oradata/orcl/system01.dbf
channel ORA_DISK_2: starting validation of datafile
channel ORA_DISK_2: specifying datafile(s) for validation
including current &SPFILE& in backup set
channel ORA_DISK_2: validation complete, elapsed time: 00:00:01
List of Control File and &SPFILE&
===============================
File Type    Status Blocks Failing Blocks Examined
------------ ------ -------------- ---------------
&SPFILE&        OK     0              2
channel ORA_DISK_2: starting validation of datafile
channel ORA_DISK_2: specifying datafile(s) for validation
including current control file for validation
channel ORA_DISK_2: validation complete, elapsed time: 00:00:01
List of Control File and &SPFILE&
===============================
File Type    Status Blocks Failing Blocks Examined
------------ ------ -------------- ---------------
Control File OK     0              594
channel ORA_DISK_1: validation complete, elapsed time: 00:00:48
List of Datafiles
=================
File Status Marked Corrupt Empty Blocks Blocks Examined High &SCN&
---- ------ -------------- ------------ --------------- ----------
1    OK     0              13310        92201           2086674
  File Name: /u01/app/oracle/oradata/orcl/system01.dbf
  Block Type Blocks Failing Blocks Processed
  ---------- -------------- ----------------
  Data       0              59907
  Index      0              12711
  Other      0              6232

Finished validate at 29-OCT-13
        \end{lstlisting}
        Die Syntax des \languagerman{VALIDATE}-Befehls ist der des \languagerman{BACKUP}-Kommandos sehr \"ahnlich. Es k\"onnen Archive Logs, Kontrolldateien, SPFiles, Datendateien, Tablespaces oder auch die gesamte Datenbank gepr\"uft werden.
\clearpage
        \begin{lstlisting}[caption={Eine ganze Datenbank validieren},label=admin1401,language=rman]
RMAN> VALIDATE database;
        \end{lstlisting}
        \begin{lstlisting}[caption={Validieren der Archive Logs},label=admin1402,language=rman]
RMAN> VALIDATE archivelog all;
Starting validate at 29-OCT-13
released channel: ORA_SBT_TAPE_1
using channel ORA_DISK_1
using channel ORA_DISK_2
channel ORA_DISK_1: starting validation of archived log
channel ORA_DISK_1: specifying archived log(s) for validation
input archived log thread=1 sequence=56 RECID=89 STAMP=830101540
channel ORA_DISK_1: validation complete, elapsed time: 00:00:01
List of Archived Logs
=====================
Thrd Seq     Status Blocks Failing Blocks Examined Name
---- ------- ------ -------------- --------------- ---------------
1    56      OK     0              130             /u02/backup/archive_logs/1...
Finished validate at 29-OCT-13
        \end{lstlisting}
        Wird w\"ahrend der Validierung ein Fehler in einer Datenbankdatei entdeckt, wird die View \identifier{v\$database\_block\_corruption} mit Informationen gef\"ullt. Diese Fehler k\"onnen dann evtl. durch ein Block-Media Recovery behoben werden.
      \subsection{Funktionsf\"ahigkeit eines Backup Sets ermitteln}
        Das Kommando \languagerman{VALIDATE BACKUPSET} erm\"oglicht die Validierung eines Backup Sets. Dabei wird das Backup Set auf logische und physikalische Fehler \"uberpr\"uft.
        \begin{lstlisting}[caption={Ein Backup Set validieren},label=admin1403,language=rman]
RMAN> VALIDATE backupset 4711;

Starting validate at 29-OCT-13
using channel ORA_DISK_1
using channel ORA_DISK_2
using channel ORA_SBT_TAPE_1
channel ORA_SBT_TAPE_1: starting validation of datafile backup set
channel ORA_SBT_TAPE_1: reading from backup piece 06on9l7u_1_1
channel ORA_SBT_TAPE_1: piece handle=06on9l7u_1_1 tag=TAG20131025T112446
channel ORA_SBT_TAPE_1: restored backup piece 1
channel ORA_SBT_TAPE_1: validation complete, elapsed time: 00:00:04
Finished validate at 29-OCT-13
        \end{lstlisting}
      \subsection{Wiederherstellbarkeit einer Datenbankdatei pr\"ufen}
        Neben den M\"oglichkeiten Datenbankdateien und Backups auf Fehlerfreiheit zu pr\"ufen, kann noch ein weiterer Pr\"ufschritt unternommen werden. Mit \languagerman{RESTORE VALIDATE} kann festgestellt werden, ob eine Datenbankdatei, mit Hilfe der bestehenden Backups wiederhergestellt werden kann.
        \begin{lstlisting}[caption={Kann der Tablespace \identifier{bank} wiederhergestellt werden?},label=admin1404,language=rman]
RMAN> RESTORE VALIDATE tablespace bank;

Starting restore at 29-OCT-13
using channel ORA_DISK_1
using channel ORA_DISK_2
allocated channel: ORA_SBT_TAPE_1
channel ORA_SBT_TAPE_1: SID=21 device type=SBT_TAPE
channel ORA_SBT_TAPE_1: WARNING: Oracle Test Disk API

channel ORA_DISK_1: starting validation of datafile backup set
channel ORA_DISK_2: starting validation of datafile backup set
channel ORA_DISK_1: reading from backup piece /u05/fast_recovery_area/ORCL/...
channel ORA_DISK_2: reading from backup piece /u05/fast_recovery_area/ORCL/...
channel ORA_DISK_2: piece handle=/u05/fast_recovery_area/ORCL/...
channel ORA_DISK_2: restored backup piece 1
channel ORA_DISK_2: validation complete, elapsed time: 00:00:03
channel ORA_DISK_1: piece handle=/u05/fast_recovery_area/ORCL/backupset/...
channel ORA_DISK_1: restored backup piece 1
channel ORA_DISK_1: validation complete, elapsed time: 00:00:15
Finished restore at 29-OCT-13
        \end{lstlisting}
        In \beispiel{admin1404} wird der Restore-Prozess f\"ur den Tablespace bank validiert. Dabei wird gepr\"uft, ob alle notwendigen Backup Sets, Image Copies und Archive Logs vorhanden und funktionsf\"ahig sind.
      \subsection{Der Paramter DB\_Ultra\_Safe}
        Der Initialisierungsparameter \parameter{db\_ultra\_safe} wurde mit Oracle 11g neu eingef\"uhrt. Er soll helfen, Besch\"adigungen an Datenbl\"ocken zu vermeiden. Er selbst stellt keine neuen Mechanismen zur Verf\"ugung, sondern beeinflusst drei andere Initialisierungsparameter, die teilweise bereits seit Oracle 8i vorhanden sind. Dies sind:
        \begin{itemize}
          \item \parameter{db\_block\_checking}
          \item \parameter{db\_lost\_write\_protect}
          \item \parameter{db\_block\_checksum}
        \end{itemize}
        \subsubsection{DB\_Block\_Checking}
          Der Parameter \parameter{db\_block\_checking} legt fest, ob Oraclebl\"ocke einer semantischen Pr\"ufung unterzogen werden. Unter einer semantischen Pr\"ufung versteht man den Abgleich der Blockstruktur mit seinem Inhalt. Wenn beispielsweise eine Spalte den Wert \enquote{Florian Weidinger} enth\"alt, aber den Datentyp \identifier{DATE} aufweist, muss dies ein Fehler sein. Ein anderes Beispiel sind Spalten des Typs \identifier{VARCHAR2}. Diese k\"onnen in Oracle maximal 4.000 Byte lang sein. Taucht pl\"otzlich eine Spalte auf, die gr\"o\ss{}er als 4.000 Byte ist, so muss auch dies ein Fehler sein. Diese Art von Fehlern wird zumeist durch fehlerhafte Speichermedien hervorgerufen.

          \parameter{db\_block\_checking} kennt folgende Werte:
          \begin{itemize}
            \item \textbf{OFF}: Das Blockchecking wird lediglich im \identifier{system}-Tablespace durchgef\"uhrt.
            \item \textbf{FALSE}: Dieser Wert hat die gleiche Bedeutung wie \enquote{OFF} und wird nur aus Kompatibilit\"atsgr\"unden bereitgestellt.
            \item \textbf{LOW}: Es findet eine semantische \"Uberpr\"ufung der Blockheader, in allen Tablespaces statt.
            \item \textbf{MEDIUM}: Es findet eine vollst\"andige semantische Pr\"ufung der Oraclebl\"ocke, in allen Tablespaces statt. Ausgenommen sind Indexstrukturen.
            \item \textbf{FULL}: Es findet eine vollst\"andige semantische Pr\"ufung der Oraclebl\"ocke, in allen Tablespaces statt. Auch Indexstrukturen werden gepr\"uft.
            \item \textbf{TRUE}: Dieser Wert hat die gleiche Bedeutung wie \enquote{FULL} und wird nur aus Kompatibilit\"atsgr\"unden bereitgestellt.
          \end{itemize}
        \subsubsection{DB\_Lost\_Write\_Protect}
          Dieser Parameter ist nur in einer Oracle Data Guard Umgebung sinnvoll und hilft dort, Datenverlust durch Fehlfunktionen von Datentr\"agern zu vermeiden. Er kennt die Werte \enquote{NONE}, \enquote{TYPICAL} und \enquote{FULL}.
        \subsubsection{DB\_Block\_Checksum}
          Mit Hilfe von \parameter{db\_block\_checksum} kann die Datenbank dazu veranlasst werden, jedem Block, der in eine Datendatei geschrieben wird, eine Checksumme zu geben. Mit Hilfe dieser Checksumme kann beim Lesen des Blockes sichergestellt werden, dass der Inhalt gelesen wird, der vorher geschrieben wurde (dass der Block unver\"andert geblieben ist).
\clearpage
          Anders als mit \parameter{db\_block\_checking} kann mit diesem Parameter nicht verhindert werden, dass ein fehlerhafter Block gelesen wird. Wird ein Block beim Schreiben auf den Datentr\"ager besch\"adigt, wird von diesem besch\"adigten Block eine Checksumme gebildet. Beim erneuten Lesen des Blockes wird nur die Checksumme gepr\"uft und es wird festgestellt, dass der Block unver\"andert (fehlerhaft) geblieben ist.

          \parameter{db\_block\_checksum} kennt folgende Werte:
          \begin{itemize}
            \item \textbf{OFF}: Nur im \identifier{system}-Tablespace werden Blockchecksummen gebildet.
            \item \textbf{FALSE}: Dieser Wert hat die gleiche Bedeutung wie \enquote{OFF} und wird nur aus Kompatibilit\"atsgr\"unden bereitgestellt.
            \item \textbf{TYPICAL}: In allen Tablespaces werden Blockchecksummen gebildet und vor jedem Lesevorgang verglichen.
            \item \textbf{FULL}: Wie \enquote{TYPICAL}, aber zus\"atzlich wird vor jedem \languageorasql{UPDATE} oder \languageorasql{DELETE}, dass auf einen Block angewandt wird, die Checksumme \"uberpr\"uft und direkt nach der \"Anderung neu berechnet, nicht erst, wenn der Block auf den Datentr\"ager geschrieben wird.
            \item \textbf{TRUE}: Dieser Wert hat die gleiche Bedeutung wie \enquote{TYPICAL} und wird nur aus Kompatibilit\"atsgr\"unden bereitgestellt.
          \end{itemize}
          \bild{Der Unter\-schied zwischen TYPICAL und FULL}{db_block_checksum_typical_and_full}{1.3}
        \subsubsection{Werte f\"ur DB\_Ultra\_Safe}
          Der Parameter \parameter{db\_ultra\_safe} kann folgende Werte annehmen:
          \begin{itemize}
            \item \textbf{OFF}: Es gelten die Einstellungen der Initialisierungsparameter \parameter{db\_block\_checking}, \parameter{db\_lost\_write\_protect} und \parameter{db\_block\_checksum}.
            \item \textbf{DATA\_ONLY}: Die Einstellung der Parameter werden ver\"andert:
              \begin{itemize}
                \item \parameter{db\_block\_checking}: MEDIUM
                \item \parameter{db\_lost\_write\_protect}: TYPICAL
                \item \parameter{db\_block\_checksum}: FULL
              \end{itemize}
            \item \textbf{DATA\_AND\_INDEX}: Die Einstellung der Parameter werden ver\"andert:
              \begin{itemize}
                \item \parameter{db\_block\_checking}: FULL
                \item \parameter{db\_lost\_write\_protect}: TYPICAL
                \item \parameter{db\_block\_checksum}: FULL
              \end{itemize}
          \end{itemize}
          Es wird von Seiten Oracle empfohlen, \parameter{db\_ultra\_safe} auf den Wert \enquote{DATA\_ONLY} oder h\"oher einzustellen. Da dies kein dynamischer Parameter ist, muss ein Neustart der Datenbank erfolgen.
    \section{Recovery unkritischer Verluste}
      Bei unkritischen Verlusten handelt es sich um Sch\"aden, welche die Datenbank nicht unmittelbar zum Stillstand bringen. Die Datenbank kann trotz Besch\"adigung weiterarbeiten, m\"oglicherweise auch nur f\"ur begrenzte Zeit. Beispielsweise wird der Verlust eines SPFiles die Datenbank nicht beeintr\"achtigen, solange kein Neustart erfolgen soll. Auch eine Passwortdatei ist unkritisch f\"ur den Betrieb der Datenbank. Lediglich die Anmeldung der DBAs wird dadurch beeintr\"achtigt.
      \subsection{Verlust eines SPFile beheben (mit Recovery Katalog)}
        \subsubsection{Wiederherstellung aus einem Controlfile Autobackup}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank und am Recovery Katalog anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank und am Recovery Katalog anmelden},label=admin1405,language=rman]
[oracle@FEA11-119SRV ~]$ rman target / catalog catowner/catpass@CATDB
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1406,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des SPFiles aus dem Controlfile Autobackup. Dieser Schritt unterscheidet sich, je nachdem, ob die Instanz in der NOMOUNT-Phase oder ge\"offnet ist.
              \begin{itemize}
                \item \textbf{NOMOUNT-Phase}
                  \begin{lstlisting}[caption={Wiederherstellen des SPFiles aus dem Controlfile Autobackup},label=admin1407,language=rman]
RMAN> RESTORE spfile FROM AUTOBACKUP;
                  \end{lstlisting}
                \item \textbf{MOUNT-Phase oder ge\"offnete Instanz}

                Bei ge\"offneter oder gemounteter Instanz muss im Anschluss an diesen Arbeits\-schritt, dass wiederhergestellte SPFile in das \oscommand{\$ORACLE\_HOME/dbs}-Verzeichnis verschoben werden. Dies ist notwendig, da Oracle das (vermeindlich noch vorhandene) SPFile mit einer Schreibsperre, im Dateisystem belegt.
								\begin{lstlisting}[caption={Wiederherstellen des SPFiles aus dem Controlfile Autobackup},label=admin1408,language=rman]
RMAN> RESTORE spfile
2>    TO '/u01/app/oracle/product/11.2.0/ORCL/spfileorcl.ora'
3>    FROM AUTOBACKUP;
                  \end{lstlisting}
              \end{itemize}
            \item Durchstarten der Instanz
              \begin{lstlisting}[caption={Neustart der Instanz},label=admin1409,language=rman,alsolanguage=sqlplus]
RMAN> startup force
              \end{lstlisting}
              Nach dem Neustart werden die Initialisierungsparameter gem\"a\ss{} dem wiederhergestellten SPFile gesetzt und m\"ussen auf ihre Aktualit\"at \"uberpr\"uft werden.
          \end{enumerate}
        \subsubsection{Wiederherstellung aus einem Backup Set}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank und am Recovery Katalog anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank und am Recovery Katalog anmelden},label=admin1410,language=rman]
[oracle@FEA11-119SRV ~]$ rman target / catalog catowner/catpass@CATDB
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1411,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des SPFiles. Dieser Schritt unterscheidet sich, je nachdem, ob die Instanz in der NOMOUNT-Phase oder ge\"offnet ist.
              \begin{itemize}
                \item \textbf{NOMOUNT-Phase}
                  \begin{lstlisting}[caption={Wiederherstellen des SPFiles in der NOMOUNT-Phase},label=admin1412,language=rman]
RMAN> RESTORE spfile;
                  \end{lstlisting}
                \item \textbf{MOUNT-Phase oder ge\"offnete Instanz}

                Bei ge\"offneter oder gemounteter Instanz muss im Anschluss an diesen Arbeitsschritt das wiederhergestellte SPFile in das \oscommand{\$ORACLE\_HOME/dbs}-Verzeichnis verschoben werden. Dies ist notwendig, da Oracle das (vermeindlich noch vorhandene) SPFile mit einer Schreibsperre, im Dateisystem belegt.
								\begin{lstlisting}[caption={Wiederherstellen des SPFiles in der MOUNT-Phase},label=admin1413,language=rman]
RMAN> RESTORE spfile
2>    TO '/u01/app/oracle/product/11.2.0/spfileorcl.ora';
                  \end{lstlisting}
              \end{itemize}
            \item Durchstarten der Instanz
              \begin{lstlisting}[caption={Neustart der Instanz},label=admin1414,language=rman,alsolanguage=sqlplus]
RMAN> startup force
              \end{lstlisting}
              Nach dem Neustart werden die Initialisierungsparameter gem\"a\ss{} dem wiederhergestellten SPFile gesetzt und m\"ussen auf ihre Aktualit\"at \"uberpr\"uft werden.
          \end{enumerate}
\clearpage
      \subsection{Verlust eines SPFiles beheben (ohne Recovery Katalog)}
        \subsubsection{Die Datenbank-ID (DBID)}
          Jede Oracle-Datenbank wird anhand einer zehnstelligen ID, der Datenbank-ID (DBID) identifiziert. Diese ist in der Kontrolldatei gespeichert und wird vom RMAN ben\"otigt, damit dieser erkennen kann, welche Backup Sets zu welcher Datenbank geh\"oren. Ist die Instanz nicht gemountet oder ge\"offnet, kann der RMAN die DBID nicht selbstst\"andig ermitteln.

          Es gibt drei M\"oglichkeiten, an die DBID zu gelangen:
            \begin{enumerate}
              \item Abfragen der View \identifier{v\$database}
                \begin{lstlisting}[caption={Abfragen von \identifier{v\$database}},label=admin1415,language=oracle_sql]
SQL> SELECT dbid
  2  FROM   v$database;

      DBID
----------
1351916467
                \end{lstlisting}
              \item Starten des RMAN: Beim Starten des RMAN wird die DBID der Zieldatenbank rechts unten in der Startmeldung angezeigt, sofern die Instanz hochgefahren ist.
                \begin{lstlisting}[caption={Startmeldung des RMAN},label=admin1416,language=terminal]
Recovery Manager: Release 11.2.0.1.0 - Production &on& Tue Oct 29 17:34:34 2013

Copyright (c) 1982, 2009, Oracle and/or its affiliates.  All rights reserved.

connected to target database: ORCL &\textcolor{red}{(DBID=1351916467)}&
                \end{lstlisting}
              \item Durchsuchen eines unkomprimierten Backups, welches die Datendatei Nummer 1 beinhaltet.
                \begin{lstlisting}[caption={Die DBID in einem Backup Set suchen},label=admin1417,language=terminal]
[oracle@FEA11-119SRV ~]$ strings /u02/backup/ORCL_29-10-2013_4aklgp2d.bkp \
> | grep &MAXVALUE&,

&\textcolor{red}{1351916467}, MAXVALUE,&
                \end{lstlisting}
                Das Linux-Kommando \oscommand{strings} durchsucht eine Bin\"ardatei nach \enquote{lesbaren} Zeichenketten. In einem unkomprimierten und unverschl\"usselten Backup Set kann so die DBID sichtbar gemacht werden.
              \end{enumerate}
        \subsubsection{Wiederherstellung aus einem Controlfile Autobackup}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1418,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle
              \end{lstlisting}
            \item Setzen der DBID
              \begin{lstlisting}[caption={Setzen der DBID},label=admin1419,language=rman]
RMAN> SET DBID 1351916467;
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1420,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des SPFiles aus dem Controlfile Autobackup. Dieser Schritt unterscheidet sich, je nachdem, ob die Instanz in der NOMOUNT-Phase oder ge\"offnet ist.
              \begin{itemize}
                \item \textbf{NOMOUNT-Phase}
                  \begin{lstlisting}[caption={Wiederherstellen des SPFiles aus dem Controlfile Autobackup},label=admin1421,language=rman]
RMAN> RESTORE spfile FROM AUTOBACKUP
2>    RECOVERY AREA '/u05/fast_recovery_area'
3>    DB_NAME       'orcl';
                  \end{lstlisting}
                  \begin{merke}
                    Wenn die Instanz nicht gemountet oder ge\"offnet ist, ist es dem RMAN unm\"oglich, den Speicherort der Controlfile Autobackups zu ermitteln. Mit Hilfe der beiden Parameter \languagerman{RECOVERY AREA} und \languagerman{DB_NAME} wird der Speicherort, die Fast Recovery Area, dem RMAN mitgeteilt.
                  \end{merke}
                \item \textbf{MOUNT-Phase oder ge\"offnete Instanz}
                  \begin{lstlisting}[caption={Wiederherstellen des SPFiles aus dem Controlfile Autobackup},label=admin1422,language=rman]
RMAN> RESTORE spfile
2>    TO '/u01/app/oracle/product/11.2.0/ORCL/spfileorcl.ora'
3>    FROM AUTOBACKUP;
                  \end{lstlisting}
              \end{itemize}
              Bei ge\"offneter oder gemounteter Instanz muss im Anschluss an diesen Arbeitsschritt das wiederhergestellte SPFile in das \oscommand{\$ORACLE\_HOME/dbs}-Verzeichnis verschoben werden. Dies ist notwendig, da Oracle das (vermeindlich noch vorhandene) SPFile mit einer Schreibsperre, im Dateisystem belegt.
            \item Durchstarten der Instanz
              \begin{lstlisting}[caption={Neustart der Instanz},label=admin1423,language=rman,alsolanguage=sqlplus]
RMAN> startup force
              \end{lstlisting}
              Nach dem Neustart werden die Initialisierungsparameter gem\"a\ss{} dem wiederhergestellten SPFile gesetzt und m\"ussen auf ihre Aktualit\"at \"uberpr\"uft werden.
            \end{enumerate}
        \subsubsection{Wiederherstellung aus einem Backup Set}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden und diee DBID setzen.
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden und die DBID setzen},label=admin1424,language=rman]
[oracle@FEA11-119SRV ~]$ rman target /

RMAN> SET DBID 1351916467;
                  \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1425,language=rman]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des SPFiles. Dieser Schritt unterscheidet sich, je nachdem, ob die Instanz in der NOMOUNT-Phase oder ge\"offnet ist.
              \begin{itemize}
                \item \textbf{NOMOUNT-Phase}
                  \begin{lstlisting}[caption={Wiederherstellen des SPFiles in der NOMOUNT-Phase},label=admin1426,language=rman]
RMAN> RESTORE spfile
2>    FROM '/u02/backup/3ukkpd6p.bkp';
                  \end{lstlisting}
\clearpage
                \item \textbf{MOUNT-Phase oder ge\"offnete Instanz}

								Bei ge\"offneter oder gemounteter Instanz muss im Anschluss an diesen Arbeitsschritt das wiederhergestellte SPFile in das \oscommand{\$ORACLE\_HOME/dbs}-Verzeichnis verschoben werden. Dies ist notwendig, da Oracle das (vermeindlich noch vorhandene) SPFile mit einer Schreibsperre, im Dateisystem belegt.
								\begin{lstlisting}[caption={Wiederherstellen des SPFiles in der MOUNT-Phase},label=admin1427,language=rman]
RMAN> RESTORE spfile
2>    TO '/u01/app/oracle/product/11.2.0/spfileorcl.ora'
3>    FROM '/u02/backup/3ukkpd6p.bkp';
                  \end{lstlisting}
              \end{itemize}
            \item Durchstarten der Instanz
              \begin{lstlisting}[caption={Neustart der Instanz},label=admin1428,language=rman,alsolanguage=sqlplus]
RMAN> startup force
              \end{lstlisting}
              Nach dem Neustart werden die Initialisierungsparameter gem\"a\ss{} dem wiederhergestellten SPFile gesetzt und m\"ussen auf ihre Aktualit\"at \"uberpr\"uft werden.
            \end{enumerate}
        \subsubsection{Wiederherstellen eines PFiles}
          Da ein PFile nicht automatisch durch den Datenbankserver verwaltet wird, gibt es auch keinen datenbankeigenen Backupmechanismus. F\"ur die Sicherung und Wiederherstellung eines PFiles muss manuell gesorgt werden. Es empfiehlt sich daher, bei Benutzung eines PFiles, dieses durch Betriebssystemmittel vor Verlust zu sch\"utzen.
          \begin{merke}
            Schon seit Oracle 9i wird davon abgeraten, ein PFile zu benutzen.
          \end{merke}
      \subsection{Verlust einer Passwortdatei beheben}
        Die Passwortdatei geh\"ort zu den Dateien, die nicht durch RMAN gesichert werden k\"onnen. Daher sollte auch diese auf anderem Wege gesichert werden. Geht die Passwortdatei verloren und es existiert kein Backup, muss sie wie neu erstellt werden.
      \subsection{Verlust von Konfigurationsdateien beheben}
        F\"ur Konfigurationsdateien wie, z. B. die \oscommand{tnsnames.ora}, \oscommand{listener.ora} oder die Datei \oscommand{sqlnet.ora} gilt Gleiches, wie f\"ur die Passwortdatei. Bei einem Verlust m\"ussen sie neu angelegt werden und sollten daher auf jeden Fall gesichert werden.
      \subsection{Verlust eines Tempfiles beheben}
        Geht im laufenden Betrieb der Datenbank ein Tempfile verloren, kann bei der Ausf\"uhrung eines SQL-Statements folgende Fehlermeldung auftreten:
        \begin{lstlisting}[caption={Verlust eines Tempfiles},label=admin1429,language=oracle_sql]
ORA-01565: error in identifying file
'/u02/oradata/ORCL/temp01.dbf'
ORA-27037: unable to obtain file status
Linux Error: 2: No such file or directory
        \end{lstlisting}
        Es gibt zwei M\"oglichkeiten auf diese Situation zu reagieren:
        \begin{itemize}
          \item Neustarten der Instanz. Hierbei wird das Tempfile automatisch neu erstellt. In der Alert Log Datei wird eine Meldung ausgegeben, \"ahnlich dieser:
          \begin{lstlisting}[caption={Automatisches Neuerstellen eines Tempfiles},label=admin1430,language=oracle_sql]
Recreating tempfile
'/u02/oradata/ORCL/temp01.dbf'
          \end{lstlisting}
          \item Erstellen eines neuen Tempfiles und l\"oschen der verlorenen Datei aus dem Data Dictionary.
            \begin{enumerate}
              \item Ermitteln zu welchem Temp-Tablespace die besch\"adigte Datei geh\"ort.
                \begin{lstlisting}[caption={Ermitteln des richtigen Temp-Tablespace},label=admin1431,language=oracle_sql]
SQL> SELECT tablespace_name
  2  FROM   dba_temp_files
  3  WHERE  file_name LIKE '/u02/oradata/ORCL/temp01.dbf'

TABLESPACE_NAME
------------------------------
TEMP
                \end{lstlisting}
              \item Neues Tempfile erstellen
              \begin{lstlisting}[caption={Neues Tempfile erstellen},label=admin1432,language=oracle_sql]
SQL> ALTER TABLESPACE temp
  2  ADD TEMPFILE '/u02/oradata/ORCL/temp02.dbf'
  3  SIZE 20 M AUTOEXTEND ON MAXSIZE 500M;
              \end{lstlisting}
              \item Das besch\"adigte Tempfile l\"oschen.
              \begin{lstlisting}[caption={Besch\"adigtes Tempfile l\"oschen},label=admin1433,language=oracle_sql]
SQL> ALTER TABLESPACE temp
  2  DROP TEMPFILE '/u02/oradata/ORCL/temp01.dbf';
              \end{lstlisting}
            \end{enumerate}
        \end{itemize}
    \section{Datafile Media Recovery}
      Ein Media Recovery k\"ummert sich immer um die Behebung von Datenbankfehlern, die durch den Verlust einer der folgenden Dateiarten zustande gekommen sind:
      \begin{itemize}
        \item Datendateien
        \item Kontrolldatei
        \item Archive Log Dateien
      \end{itemize}
      Archive Log Dateien bilden dabei eine Ausnahme, da sie meist nur tempor\"ar f\"ur ein Recovery ben\"otigt werden, m\"ussen sie nicht zwingend sofort wiederhergestellt werden, sondern es gen\"ugt eine funktionsf\"ahige Kopie dieser Dateien zu besitzen.
      \subsection{Identifizieren besch\"adigter Dateien}
        \label{identifyfiles}
        Um zu analysieren welche Dateien ein Recovery brauchen, ist Folgendes notwendig:
        \begin{enumerate}
          \item Starten von SQL*Plus
          \item Status der Instanz abfragen
          \begin{lstlisting}[caption={Status der Instanz abfragen},label=admin1434,language=oracle_sql]
SQL> SELECT status FROM v$instance;

STATUS
------------
&OPEN&
          \end{lstlisting}
          Auch wenn der Status \enquote{OPEN} angezeigt wird, ist es m\"oglich,
          dass Teile der Datenbank ein Recovery ben\"otigen.
          \item Damit die folgenden Abfragen sinnvolle Ergebnisse liefern, muss zuerst ein Checkpoint stattfinden, da erst dann der Status der Datendateien aktualisiert wird.
          \begin{lstlisting}[caption={Einen Checkpoint absetzen},label=admin1435,language=oracle_sql]
SQL> ALTER SYSTEM CHECKPOINT;
          \end{lstlisting}
          \item Den Dateistatus abfragen. Hierf\"ur gibt es mehrere M\"og\-lich\-kei\-ten:
          \begin{enumerate}
            \item Abfragen der View \identifier{v\$datafile\_header}

						Jede zur\"uckgegebene Zeile steht stellvertretend f\"ur eine Datendatei. Die Spalte \identifier{recover} zeigt an, ob eine Datendatei ein Recovery ben\"otigt oder nicht. In der Spalte \identifier{error} wird angezeigt, ob ein Problem mit der Datendatei vorliegt (z. B. ob der Datendateiheader nicht gelesen werden konnte).
						\begin{lstlisting}[caption={Status der Datendateien abfragen mit	V\$DATAFILE\_HEADER},label=admin1436,language=oracle_sql,alsolanguage=sqlplus,emph={[9]FILE,OFFLINE,TABLESPACE, NOT},emphstyle={[9]\color{black}}]
SQL> col file# format 999
SQL> col status format A7
SQL> col error format A10
SQL> col tablespace_name format A10
SQL> col name format A30
SQL> SELECT file#, status, error, recover, tablespace_name, name
  2  FROM   v$datafile_header
  3  WHERE  recover = 'YES'
  4    OR   (recover IS NULL
  5    AND  error IS NOT NULL);

&\textcolor{black}{FILE\#}&  STATUS  ERROR           REC &\textcolor{black}{TABLESPACE}&   NAME
----- ------- --------------- --- ---------- ----------------
6     &\textcolor{black}{OFFLINE}&   &\textcolor{black}{FILE}& &\textcolor{black}{NOT}& FOUND
              \end{lstlisting}

              Zeigt die Spalte \identifier{error} einen Wert an, sollte zuerst nach Hardware- oder Betriebssystemproblemen gesucht werden. Liegen keine derartigen Probleme vor, muss die betreffende Datendatei wiederhergestellt werden.

              Zeigt die Spalte \identifier{recover} den Wert YES und die Spalte \identifier{error} ist leer, so ist meist nur ein Recovery der Datendatei notwendig. Da diese View aber nur die Header der Datendateien liest, kann sie nicht alle Probleme anzeigen, die ein Recovery der Datendatei notwendig machen!
              \begin{merke}
                Die Anzeige defekter Datendateien funktioniert nur dann
                zuverl\"assig, wenn der Parameter
                \parameter{filesystemio\_options} den Wert \textit{directIO}
                hat. Diese Einstellung sorgt daf\"ur, dass Informationen direkt
                auf den Datentr\"ager geschrieben und Caching-Mechanismen des
                Dateisystems umgangen werden.
              \end{merke}
            \item Abfragen der View \identifier{v\$recover\_file}
              \begin{lstlisting}[texcl=true, caption={Status der Datendateien abfragen mit V\$RECOVER\_FILE},label=admin1437,language=oracle_sql,emph={[10]FILE,OFFLINE,CHANGE, TIME, NOT},emphstyle={[10]\color{black}}]
SQL> SELECT file#, error, online_status, change#, time 
  2  FROM   v$recover_file;

&\textcolor{black}{FILE\#}& ERROR         ONLINE_ &\textcolor{black}{CHANGE\#}& &\textcolor{black}{TIME}& 
----- ------------------------------- ----------------- ------------------- -------
6    &\textcolor{black}{FILE}& &\textcolor{black}{NOT}& FOUND &\textcolor{black}{OFFLINE}&         0
              \end{lstlisting}
              Zus\"atzlich zu \identifier{v\$datafile\_header} zeigt sie an, dass eine Datendatei defekte Bl\"ocke enth\"alt. Im Gegensatz zu \identifier{v\$datafile\_header} kann sie nur dann verwendet werden, wenn die Kontrolldatei nicht wiederhergestellt werden musste.
\clearpage
            \item Abfragen der Views \identifier{v\$datafile} und \identifier{v\$tablespace}
              \begin{lstlisting}[caption={Status der Datendateien abfragen},label=admin1438,language=oracle_sql,alsolanguage=sqlplus,emph={[9]FILE,OFFLINE,CHANGE, TIME, NOT},emphstyle={[9]\color{black}}]
col df#       format 999
col df_name   format A35
col tbsp_name format A7
col status    format A7
col error     format A10
col change#   format 99999999
SELECT r.file# AS df#, d.name AS df_name, t.name AS tbsp_name,
      d.status, r.error
FROM   v$recover_file r, v$datafile d, v$tablespace t
WHERE  t.ts# = d.ts#
  AND  d.file# = r.file#;

 DF# DF_NAME                             TBSP_NA STATUS  ERROR       
---- ----------------------------------- ------- ------- ----------
   6 /u02/oradata/ORCL/example01.dbf     EXAMPLE RECOVER &\textcolor{black}{FILE}& &\textcolor{black}{NOT}&
                                                         FOUND
              \end{lstlisting}
          \end{enumerate}
        \end{enumerate}
    \subsection{Ermitteln der ben\"otigten Backups}
      RMAN bietet mit dem Kommando \languagerman{RESTORE PREVIEW} die M\"oglichkeit festzustellen, welche Backups f\"ur einen Restore-Prozess ben\"otigt werden. Dies ist gerade dann wichtig, wenn Backup Sets auf SBT-Tapes liegen und erst wieder in die FRA zur\"uckgeholt werden m\"ussen. Im folgenden Beispiel wird angenommen, dass der Tablespace \identifier{bank} vollst\"andig wiederhergestellt werden muss.
      \begin{lstlisting}[caption={Vorschau auf ein Restore},label=admin1439,language=rman]
RMAN> RESTORE PREVIEW tablespace bank;

Starting restore at 30-OCT-13
using channel ORA_DISK_1
using channel ORA_DISK_2
using channel ORA_SBT_TAPE_1


List of Backup Sets
===================


BS Key  Type LV Size
------- ---- -- ----------
16      Full    26.34M
					\end{lstlisting}
\clearpage
					\begin{lstlisting}[language=rman]
  List of Datafiles in backup set 16
  File LV Type Ckp &SCN&    Ckp Time  Name
  ---- -- ---- ---------- --------- ----
  6       Full 2084386    29-OCT-13 /u01/app/oracle/oradata/orcl/bank01.dbf

...

BS Key  Size       Device Type Elapsed Time Completion Time
------- ---------- ----------- ------------ ---------------
30      240.25M    SBT_TAPE    00:00:03     30-OCT-13
        BP Key: 48   Status: &AVAILABLE&  Compressed: NO  Tag: TAG20131030T111928
        Handle: 18onmqq1_1_1   Media: /u04,18onmqq1_1_1

  List of Archived Logs in backup set 30
  Thrd Seq     Low &SCN&    Low Time  Next &SCN&   Next Time
  ---- ------- ---------- --------- ---------- ---------
  1    56      2085711    29-OCT-13 2086381    29-OCT-13
  1    57      2086381    29-OCT-13 2111298    30-OCT-13
  1    58      2111298    30-OCT-13 2111915    30-OCT-13
  1    59      2111915    30-OCT-13 2112126    30-OCT-13
validation succeeded for backup piece
Media recovery start &SCN& is 2084386
Recovery must be done beyond &SCN& 2084393 to clear datafile fuzziness
validation succeeded for backup piece
Finished restore at 30-OCT-13
            \end{lstlisting}
      Die Ausgabe des \languagerman{RESTORE PREVIEW}-Befehls zeigt eine komplette Auflistung aller Backup Sets und Copies, die der RMAN f\"ur den angegebenen Restore-Prozess heranziehen w\"urde. Besonderes Augenmerk muss auf die Backup Sets gelegt werden, die auf SBT-Tapes gespeichert sind, wie hier z. B. Backup Set Nummer 30. Dessen Inhalt sollte vor dem Restore des Tablespaces in die FRA zur\"uckgeholt werden.
    \subsection{Wiedherstellen der gesamten Datenbank}
      \begin{merke}
        Sollte die Datenbank eines oder mehrere verschl\"usselte Elemente (Tabellenspalten, Tablespaces, o. \"a.) enthalten, muss vor dem Recovery das Encryption Wallet ge\"offnet werden. \ref{recoverencryptedts} zeigt wie ein verschl\"usselter Tablespace recovered wird.
      \end{merke}
\clearpage
      \subsubsection{Alle ben\"otigten Dateien befinden sich in der FRA}
        Das Wiederherstellen der gesamten Datenbank ist der mit Sicherheit zeitaufwendigste Recovery-Fall der entstehen kann. Ob und wann die gesamte Datenbank wiederherzustellen ist, kann von verschiedenen Faktoren abgeleitet werden. Die folgende Liste zeigt nur einige dieser Gr\"unde:
        \begin{itemize}
          \item Es wurden mehr als 70 \% aller Datendateien zerst\"ort.
          \item Die Datenbank muss auf einen anderen Server umgezogen werden.
        \end{itemize}
        Im Folgenden wird ein einfaches vollst\"andiges Restore and Recovery einer ganzen Datenbank, ohne Recovery Katalog durchgef\"uhrt. Die Kontrolldatei, dass SPFile und mindestens eine gespiegelte Kopie der Redo Logs der Datenbank sind noch erhalten. Des Weiteren befinden sich alle ben\"otigten Archive Logs in der FRA.
        \begin{enumerate}
          \item Mit dem RMAN an der Zieldatenbank anmelden
            \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1440,language=rman]
[oracle@FEA11-119SRV ~]$ rman target /
            \end{lstlisting}
          \item Die Datenbank in den Mount-Status bringen
            \begin{lstlisting}[caption={Datenbank mounten},label=admin1441,language=rman,alsolanguage=sqlplus]
RMAN> startup force mount
          \end{lstlisting}
          \item Das Restore durchf\"uhren
            \begin{lstlisting}[caption={Restore der Datendateien},label=admin1442,language=rman]
RMAN> RESTORE database;
            \end{lstlisting}
          \item Recovern der Datenbank
            \begin{lstlisting}[caption={Recovery der Datenbank},label=admin1443,language=rman]
RMAN> RECOVER database;
            \end{lstlisting}
          \item \"Offnen der Datenbank
            \begin{lstlisting}[caption={\"Offnen der Datenbank nach dem Recovery},label=admin1444,language=rman,emph={[10]ALTER,DATABASE,OPEN},emphstyle={[10]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN';
            \end{lstlisting}
        \end{enumerate}
        \begin{merke}
          Da in diesem Fall die Kontrolldatei der Zieldatenbank erhalten blieb,
          gibt es keinen Unterschied zwischen einem Recovery mit Hilfe eines
          Recovery Katalogs und einem Recovery ohne Nutzung des Recovery
          Katalogs.
        \end{merke}
        \subsubsection{Archive Logs  m\"ussen von SBT zur\"uckgeholt werden}
          Das vorangegangene Beispiel wird nun dahingehend abgewandelt, dass nicht alle ben\"otigten Archive Logs in der FRA vorliegen.
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1445,language=rman]
[oracle@FEA11-119SRV ~]$ rman target /
              \end{lstlisting}
            \item Die Datenbank in den Mount-Status bringen
              \begin{lstlisting}[caption={Datenbank mounten},label=admin1446,language=rman,alsolanguage=sqlplus]
RMAN> startup force mount
            \end{lstlisting}
            \item Ermitteln welche Backup Sets auf SBT-Tape liegen.
              \begin{lstlisting}[caption={Ermitteln der ben\"otigten Dateien},label=admin1447,language=rman]
RMAN> RESTORE PREVIEW database;
              \end{lstlisting}
            \item Zur\"uckholen der ben\"otigten Archive Logs.
              \begin{lstlisting}[caption={Restore der Archive Logs von SBT in die FRA},label=admin1448,language=rman]
RMAN> RESTORE archive log UNTIL SEQUENCE 60;
              \end{lstlisting}
            \item Das Restore der Datenbank durchf\"uhren
              \begin{lstlisting}[caption={Restore der Datendateien},label=admin1449,language=rman]
RMAN> RESTORE database;
              \end{lstlisting}
            \item Recovern der Datenbank
              \begin{lstlisting}[caption={Recovery der Datenbank},label=admin1450,language=rman]
RMAN> RECOVER database;
              \end{lstlisting}
            \item \"Offnen der Datenbank
              \begin{lstlisting}[caption={\"Offnen der Datenbank nach dem Recovery},label=admin1451,language=rman,emph={[10]ALTER,DATABASE,OPEN},emphstyle={[10]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN';
              \end{lstlisting}
            \item L\"oschen der nicht mehr ben\"otigten Archive Logs.
              \begin{lstlisting}[caption={L\"oschen der Archive Logs, die bereits auf SBT-Tape gesichert wurden},label=admin1452,language=rman]
RMAN> DELETE archivelog all BACKED UP 1 TIMES
2>    TO DEVICE TYPE sbt;
              \end{lstlisting}
              \begin{lstlisting}[caption={L\"oschen der Archive Logs, die bereits auf Disk gesichert wurden},label=admin1453,language=rman]
RMAN> DELETE archivelog all BACKED UP 1 TIMES
2>    TO DEVICE TYPE disk;
              \end{lstlisting}
          \end{enumerate}
          Durch die Klausel \languagerman{BACKUPED UP 1 TIMES} wird beim
          L\"oschen sichergestellt, dass nur solche Archive Logs aus der FRA entfernt werden, die bereits mindestens 1x gesichert worden sind.
      \subsection{Wiederherstellung eines Tablespaces}
        \subsubsection{Wenn der Tablespace unverschl\"usselt ist}
          Die Wiederherstellung eines Tablespaces kann sowohl im MOUNT- als auch im OPEN-Status der Datenbank durchgef\"uhrt werden. Im folgenden Beispiel wird angenommen, dass der Tablespace \identifier{bank} besch\"adigt wurde, w\"ahrend die Datenbank ge\"offnet ist. Wie schon beim Recovery der gesamten Datenbank, so muss auch hier erst gepr\"uft werden, ob alle ben\"otigten Dateien in der FRA vorliegen.
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1454,language=terminal]
[oracle@FEA11-119SRV ~]$ rman target /
              \end{lstlisting}
            \item \"Uberpr\"ufen ob alle ben\"otigten Dateien in der FRA vorliegen
              \begin{lstlisting}[caption={Voraussetzungen \"uberpr\"ufen},label=admin1455,language=rman]
RMAN> RESTORE PREVIEW tablespace bank;
              \end{lstlisting}
            \item Nicht vorliegende Archive Logs von SBT-Tapes holen
              \begin{lstlisting}[caption={Voraussetzungen \"uberpr\"ufen},label=admin1456,language=rman]
RMAN> RESTORE archive log UNTIL SEQUENCE 60;
              \end{lstlisting}
            \item Offline setzen des betreffenden Tablespaces
              \begin{lstlisting}[caption={Betreffenden Tablespace Offline
              setzen},label=admin1457,language=rman,emph={[10]ALTER,TABLESPACE,OFFLINE,IMMEDIATE},emphstyle={[10]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank OFFLINE IMMEDIATE';
              \end{lstlisting}
            \item Das Restore des Tablespaces durchf\"uhren
              \begin{lstlisting}[caption={Restore des betreffenden Tablespaces},label=admin1458,language=rman]
RMAN> RESTORE tablespace bank;
              \end{lstlisting}
            \item Recovern des Tablespaces
              \begin{lstlisting}[caption={Recovery des Tablespaces},label=admin1459,language=rman]
RMAN> RECOVER tablespace bank DELETE archivelog;
              \end{lstlisting}
              Die Klausel \languagerman{DELETE archivelog} sorgt daf\"ur, dass alle nicht mehr ben\"otigten Archive Logs sofort gel\"oscht werden. Dabei werden keine Logs gel\"oscht, die noch nicht gesichert wurden.
            \item Online setzen des betreffenden Tablespaces nach dem Recovery
              \begin{lstlisting}[caption={Betreffenden Tablespace Online setzen},label=admin1460,language=rman,emph={[10]ALTER,TABLESPACE,ONLINE},emphstyle={[10]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank ONLINE';
              \end{lstlisting}
          \end{enumerate}
        \subsubsection{Wenn der Tablespace verschl\"usselt ist}
          \label{recoverencryptedts}
          Bei einem verschl\"usselten Tablespace sind grunds\"atzlich die gleichen Schritte f\"ur ein Restore and Recovery notwendig, wie bei einem Unverschl\"usselten. Der einzige Unterschied ist, dass ein kryptierter Tablespace nur dann recovered werden kann, wenn das Wallet vorher ge\"offnet wurde.
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1461,language=terminal]
[oracle@FEA11-119SRV ~]$ rman target /
              \end{lstlisting}
            \item Das Wallet \"offnen
              \begin{lstlisting}[caption={\"Offnen des Wallets},label=admin1462,language=rman,emph={[9]ALTER,SYSTEM,SET,ENCRYPTION,WALLET,OPEN,IDENTIFIED,BY},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL'ALTER SYSTEM SET ENCRYPTION WALLET OPEN IDENTIFIED BY "P@ssw0rd"';
              \end{lstlisting}
            \item \"Uberpr\"ufen ob alle ben\"otigten Dateien in der FRA vorliegen
              \begin{lstlisting}[caption={Voraussetzungen \"uberpr\"ufen},label=admin1463,language=rman]
RMAN> RESTORE PREVIEW tablespace bank;
              \end{lstlisting}
            \item Nicht vorliegende Archive Logs von SBT-Tapes holen
              \begin{lstlisting}[caption={Voraussetzungen \"uberpr\"ufen},label=admin1464,language=rman]
RMAN> RESTORE archive log UNTIL SEQUENCE 60;
              \end{lstlisting}
            \item Offline setzen des betreffenden Tablespaces
              \begin{lstlisting}[caption={Betreffenden Tablespace Offline setzen},label=admin1465,language=rman,emph={[9]ALTER,TABLESPACE,OFFLINE,IMMEDIATE},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank OFFLINE IMMEDIATE';
              \end{lstlisting}
            \item Das Restore des Tablespaces durchf\"uhren
              \begin{lstlisting}[caption={Restore des betreffenden Tablespaces},label=admin1466,language=rman]
RMAN> RESTORE tablespace bank;
              \end{lstlisting}
            \item Recovern des Tablespaces
              \begin{lstlisting}[caption={Recovery des Tablespaces},label=admin1467,language=rman]
RMAN> RECOVER tablespace bank DELETE archivelog;
              \end{lstlisting}
              Die Klausel \languagerman{DELETE archivelog} sorgt daf\"ur, dass alle nicht mehr ben\"otigten Archive Logs sofort gel\"oscht werden. Dabei werden keine Logs gel\"oscht, die noch nicht gesichert wurden.
            \item Online setzen des betreffenden Tablespaces nach dem Recovery
              \begin{lstlisting}[caption={Betreffenden Tablespace Online setzen},label=admin1468,language=rman,emph={[9]ALTER,TABLESPACE,ONLINE},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank ONLINE';
              \end{lstlisting}
            \item Das Wallet schlie\ss{}en
              \begin{lstlisting}[caption={Schlie\ss{}en des Wallets},label=admin1469,language=rman,emph={[9]ALTER,SYSTEM,SET,ENCRYPTION,WALLET,CLOSE,IDENTIFIED,BY},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL'ALTER SYSTEM SET ENCRYPTION WALLET CLOSE IDENTIFIED BY "P@ssw0rd"';
              \end{lstlisting}
          \end{enumerate}
      \subsection{Wiederherstellen einzelner Datendateien}
        Sind nur einzelne Datendateien besch\"adigt, ist es meist wirtschaftlicher, explizit die besch\"adigten Dateien wiederherzustellen und nicht die gesamten Tablespaces.
        \subsubsection{Datendateien Offline setzen}
          Datendateien k\"onnen genauso wie Tablespaces Offline gesetzt werden. Wenn dies geschieht, ist der Tablespace der sie enth\"alt nicht verf\"ugbar, bis die Datendatei wieder Online gesetzt wurde.

          Um eine Datendatei Offline zu setzen, wird das \languageorasql{ALTER DATABASE}-Kommando und das \privileg{alter database}-System Privileg ben\"otigt.
          \begin{lstlisting}[caption={Eine Datendatei offline setzen},label=admin1470,language=oracle_sql]
SQL> ALTER DATABASE
  2  DATAFILE '/u02/oradata/orcl/bankl01.dbf' OFFLINE;
          \end{lstlisting}
          Eine Datendatei kann nicht nur mit ihrem Dateinamen, sondern auch mit ihrer internen Dateinummer angesprochen werden. Herausfinden kann man die Dateinummer mit Hilfe der View \identifier{dba\_data\_files}.
          \begin{lstlisting}[caption={Herausfinden der file\_id einer Datendatei},label=admin1471,language=oracle_sql]
SQL> SELECT file_id
  2  FROM   dba_data_files
  3  WHERE  file_name LIKE '%bank01%';

   FILE_ID
----------
         6
          \end{lstlisting}
          Im \languageorasql{ALTER DATABASE}-Kommando wird der Dateiname durch die Dateinummer ersetzt.
          \begin{lstlisting}[caption={Eine Datendatei mit Hilfe der file\_id Offline setzen},label=admin1472,language=oracle_sql]
SQL> ALTER DATABASE
  2  DATAFILE 6 OFFLINE;
          \end{lstlisting}
          Soll die Datendatei wieder Online gebracht werden, wird das \languageorasql{ALTER DATABASE}-Statement zusammen mit dem Schl\"usselwort \languageorasql{ONLINE} verwendet.
          \begin{lstlisting}[caption={Eine Datendatei online setzen},label=admin1473,language=oracle_sql]
SQL> ALTER DATABASE
  2  DATAFILE 6 ONLINE;
          \end{lstlisting}
        \subsubsection{Restore and Recovery von Datendateien}
          Im folgenden Beispiel wird angenommen, dass die Datenbank ge\"offnet ist.
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1474,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle
              \end{lstlisting}
            \item Offline setzen der betreffenden Datendatei
              \begin{lstlisting}[caption={Betreffende Datendatei Offline setzen},label=admin1475,language=rman,emph={[9]ALTER,DATABASE,DATAFILE,OFFLINE,IMMEDIATE},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE DATAFILE 6 OFFLINE';
              \end{lstlisting}
            \item Das Restore der Datendatei durchf\"uhren
              \begin{lstlisting}[caption={Restore der betreffenden Datendatei},label=admin1476,language=rman]
RMAN> RESTORE datafile 6;
              \end{lstlisting}
            \item Recovern der Datendatei
              \begin{lstlisting}[caption={Recovery der Datendatei},label=admin1477,language=rman]
RMAN> RECOVER datafile 6 DELETE archivelog;
              \end{lstlisting}
            \item Online setzen der Datendatei nach dem Recovery
              \begin{lstlisting}[caption={Betreffende Datendatei Online setzen},label=admin1478,language=rman,emph={[9]ALTER,DATABASE,DATAFILE,ONLINE},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE DATAFILE 6 ONLINE';
              \end{lstlisting}
          \end{enumerate}
        \subsubsection{Restore and Recovery einer Datendatei an einem neuen Speicherort}
          Um eine Datendatei an einem neuen Speicherort wiederherzustellen, muss dieser in der Kontrolldatei angegeben werden. RMAN bietet f\"ur das Angeben des neuen Speicherorts das \languagerman{SET NEWNAME}-Kommando und \languagerman{SWITCH DATAFILE} zum Umschalten auf den neuen Speicherort.

          Die Kombination der beiden RMAN-Kommandos \languagerman{SET NEWNAME} und \languagerman{SWITCH DATAFILE} ist vergleichbar mit dem SQL-Kommando \languageorasql{ALTER DATABASE RENAME FILE}.

          Im folgenden Beispiel wird davon ausgegangen, dass der Tablespace \identifier{bank} besch\"adigt wurde. Eine der beiden Datendateien dieses Tablespaces, muss an einem anderen Speicherort wiederhergestellt werden, da der Originalspeicherort derzeit nicht verf\"ugbar ist. Mit Hilfe der unter \ref{identifyfiles} beschriebenen Methode wurde herausgefunden, dass die Datendatei \oscommand{bank02.dbf} die Nummer 7 hat.
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1479,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle
              \end{lstlisting}
            \item Offline setzen der betreffenden Datendatei
              \begin{lstlisting}[caption={Betreffende Datendatei Offline setzen},label=admin1480,language=rman,emph={[9]ALTER,TABLESPACE,OFFLINE,TEMPORARY},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank OFFLINE TEMPORARY';
              \end{lstlisting}
            \item \"Offnen eines RUN-Blocks
            \begin{lstlisting}[caption={Einen RUN-Block \"offnen},label=admin1481,language=rman]
RMAN> RUN {
            \end{lstlisting}
            \item Neuen Speicherort der Datendatei festlegen
            \begin{lstlisting}[caption={Neuen Speicherort festlegen},label=admin1482,language=rman]
2>      SET NEWNAME FOR datafile 7 TO '/u02/oradata/ORCL/bank02.dbf';
            \end{lstlisting}
            \item Durchf\"uhren des Restores
            \begin{lstlisting}[caption={Restore durchf\"uhren},label=admin1483,language=rman]
3>      RESTORE datafile 7;
            \end{lstlisting}
            \item Umschalten auf den neuen Speicherort der Datendatei
            \begin{lstlisting}[caption={Auf den neuen Speicherort umschalten},label=admin1484,language=rman]
4>      SWITCH DATAFILE ALL;
            \end{lstlisting}
            \item Recovery der Datendatei durchf\"uhren und den RUN-Block schlie\ss{}en.
            \begin{lstlisting}[caption={Recovery durchf\"uhren},label=admin1485,language=rman]
5>      RECOVER datafile 7;
6>   }
            \end{lstlisting}
            \item Datendatei in den ONLINE-Status bringen
            \begin{lstlisting}[caption={Datendatei in den ONLINE-Status bringen},label=admin1486,language=rman,emph={[9]ALTER,TABLESPACE,ONLINE},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER TABLESPACE bank ONLINE';
            \end{lstlisting}
          \end{enumerate}
      \subsection{Wiederherstellen von Archive Logs}
        Ben\"otigt der RMAN Archive Logs f\"ur ein Recovery, stellt er diese selbstst\"andig wieder her. In manchen F\"allen ist es jedoch notwendig, Archive Logs manuell wiederherzustellen. Im Folgenden werden zwei Szenarios beschrieben, bei denen die Archive Logs manuell wiederherzustellen sind.
        \subsubsection{Die Archive Logs an einem neuen Speicherort wiederherstellen}
          Standardm\"assig geben \parameter{log\_archive\_format} und \parameter{log\_archive\_dest\_n} vor, unter welchem Namen und an welchem Speicherort die Archive Logs wiederhergestellt werden. Wenn es sinnvoll ist, kann mit dem \languagerman{SET ARCHIVELOG DESTINATION}-Kommando des RMAN ein anderer Ort definiert werden.
          \begin{enumerate}
            \item \"Offnen eines RUN-Blocks
              \begin{lstlisting}[caption={Einen RUN-Block \"offnen},label=admin1488,language=rman]
RMAN> RUN {
              \end{lstlisting}
            \item Neuen Speicherort der Archive Logs festlegen
              \begin{lstlisting}[caption={Neuen Speicherort festlegen},label=admin1489,language=rman]
2>      SET ARCHIVELOG DESTINATION TO '/tmp';
              \end{lstlisting}
            \item Wiederherstellen der Archive Logs und schlie\ss{}en des RUN-Blockes.
              \begin{lstlisting}[caption={Wiederherstellen der Archive Logs},label=admin1490,language=rman]
3>      RESTORE archivelog ALL;
4>    }
              \end{lstlisting}
          \end{enumerate}
        \subsubsection{Archive Logs auf mehrere Speicherorte verteilen}
          Es ist m\"oglich die Menge der Archive Logs auf mehrere Orte aufzuteilen, falls dies aus Speicherplatzgr\"unden notwendig ist. Das folgende Beispiel stellt 150 Archive Logs wieder her und verteilt diese auf zwei Locations.
          \begin{lstlisting}[caption={Wiederherstellen der Archive Logs an verschiedenen Speicherorten},label=admin1491,language=rman]
RMAN> RUN {
2>      SET ARCHIVELOG DESTINATION TO '/u02/backup';
3>      RESTORE ARCHIVELOG FROM SEQUENCE 1 UNTIL SEQUENCE 75;
4>
5>      SET ARCHIVELOG DESTINATION TO '/u03/backup';
6>      RESTORE ARCHIVELOG FROM SEQUENCE 76 UNTIL SEQUENCE 150;
7>    }
          \end{lstlisting}
          Wird innerhalb dieses RUN-Blocks ein Recovery durchgef\"uhrt, findet RMAN automatisch seine Archive Logs an den unterschiedlichen Speicherorten.
          \begin{merke}
            Durch den Befehl \languagerman{SET} get\"atigte Einstellungen gelten immer nur innerhalb des RUN-Blockes, in dem Sie vorgenommen wurden.
          \end{merke}
    \section{Block Media Recovery}
      Es kann vorkommen, dass durch einen Fehler, einzelne Bl\"ocke in einer Datendatei besch\"a\-digt werden. Um solche Sch\"aden zu beheben, ist es zum einen m\"oglich, die gesamte Datendatei wiederherzustellen oder aber nur die defekten Bl\"ocke zu recovern. Werden nur einzelne Bl\"ocke einer Datendatei repariert, spricht man von \enquote{Block Media Recovery}.

      Block Media Recovery hat dem Datafile Media Recovery (Recovery einer
      ganzen Datendatei) gegen\"uber folgende Vorteile:
      \begin{itemize}
        \item Die Zeit f\"ur das Instance Recovery verringert sich, da nur die wiederhergestellten Bl\"ocke dem Instance Recovery unterzogen werden m\"ussen.
        \item Die betroffene Datendatei kann w\"ahrend eines Block Media Recovery Online bleiben.
      \end{itemize}
      Das Block Media Recovery unterliegt aber auch einer ganzen Reihe von
      Einschränkungen, die beachtet werden müssen:
      \begin{itemize}
        \item Block Media Recovery kann nur aus dem RMAN heraus gesteuert werden.
        \item Ein einmal begonnenes Block Media Recovery muss vollst\"andig durchgef\"uhrt werden.
				\item F\"ur Block Media Recovery k\"onnen nur Full-Backups herangezogen werden, keine inkrementellen Backups.
        \item Es k\"onnen nur solche Bl\"ocke mit Block Media Recovery repariert werden, die als corrupt\footnote{corrupt = engl. fehlerhaft} markiert wurden. In \identifier{v\$database\_block\_corruption} kann ersehen werden, welche Bl\"ocke dies sind. Diese View wird aber nicht automatisch bef\"ullt. Die betroffene Datendatei muss erst mit \languagerman{VALIDATE} validiert werden.
      \end{itemize}
      \begin{merke}
        Block Media Recovery ist nur in der Enterprise Version von Oracle 11g m\"oglich!
      \end{merke}
      \subsection{Wann sollte Block Media Recovery angewendet werden?}
        Block Media Recovery stellt eine Erweiterung zum Datafile Media Recovery dar. In F\"allen, in denen die Anzahl der defekten Bl\"ocke sehr hoch ist, kann Block Media Recovery das Datafile Media Recovery nicht ersetzen.

        Das ein defekter Block vorliegt, kann an der Fehlermeldung ORA-01578 festgestellt werden. Hier ein Beispiel f\"ur eine solche Fehlermeldung:
        \begin{lstlisting}[caption={Der Fehler ORA-01578},label=admin1492,language=terminal]
ORA-01578: ORACLE data block corrupted (file # 7, block # 3)
ORA-01110: data file 7: '/u02/oradata/orcl/bank02.dbf'
ORA-01578: ORACLE data block corrupted (file # 7, block # 235)
ORA-01110: data file 2: '/u02/oradata/orcl/bank02.dbf'
        \end{lstlisting}
      \subsection{Block Media Recovery und die Redo Logs}
        F\"ur Datafile Media Recovery ist immer eine ununterbrochene Kette von Archived Logs notwendig, da das Recovery sonst nicht erfolgreich sein kann. Block Media Recovery kann unter Umst\"anden auch dann noch erfolgreich sein, wenn einzelne Archived Logs verloren gegangen sind. Die einzige Bedingung f\"ur Block Media Recovery ist, dass alle Archived Logs, die Informationen \"uber die wiederherzustellenden Bl\"ocke enthalten, vorhanden sein m\"ussen.

        Wenn der RMAN das Fehlen eines Archived Logs feststellt, bricht er seine Arbeit nicht sofort ab. Es kann vorkommen, dass ein Datenblock in einem sp\"ateren Archive Log als \enquote{newed block} gef\"uhrt wird. Dies geschieht beispielsweise dann, wenn alle Zeilen einer Tabelle gel\"oscht wurden oder die gesamte Tabelle aus dem Block gel\"oscht wurde.
        In so einem Fall formatiert Oracle den Block neu, wodurch alle alten Redo Informationen irrelevant werden.
      \subsection{Backups defekter Datendateien anfertigen}
        \label{corruptfile}
        Bevor ein Block Media Recovery durchgef\"uhrt wird, sollte zuerst ein Backup der betroffenen Datendatei(en) gemacht werden. Standardm\"a\ss{}ig weigert sich der RMAN eine Datendatei mit besch\"adigten Bl\"ocken zu sichern. Dies resultiert aus der Standardeinstellung des RMAN-Parameters \languagerman{MAXCORRUPT} mit dem Wert 0. Dieser Parameter kann so konfiguriert werden, dass eine bestimmte Anzahl defekter Bl\"ocke f\"ur eine Datendatei zul\"assig ist.
        \begin{lstlisting}[caption={Hotbackup einer defekten Datendatei anfertigen},label=admin1493,language=rman]
RMAN> RUN {
2>      SET MAXCORRUPT FOR datafile 6 TO 999;
3>      BACKUP AS BACKUPSET DATAFILE 6;
4>    }
        \end{lstlisting}
      \subsection{Block Media Recovery durchf\"uhren}
        Das RMAN-Kommando \languagerman{BLOCKRECOVER} kann einzelne Datenbl\"ocke in der Datenbank wiederherstellen. Das folgende Szenario zeigt eine einfache Nutzung dieses Kommandos.
        \begin{enumerate}
          \item Zwei defekte Bl\"ocke werden angezeigt.
          \begin{lstlisting}[caption={Der Fehler ORA-01578},label=admin1494,language=terminal]
ORA-01578: ORACLE data block corrupted (file # 7, block # 3)
ORA-01110: data file 7: '/u02/oradata/orcl/bank02.dbf'
ORA-01578: ORACLE data block corrupted (file # 7, block # 235)
ORA-01110: data file 2: '/u02/oradata/orcl/bank02.dbf'
          \end{lstlisting}
          \item Die Bl\"ocke k\"onnen recovered werden, w\"ahrend die Datenbank ge\"offnet ist.
          \begin{lstlisting}[caption={Das Kommando BLOCKRECOVER},label=admin1495,language=rman]
RMAN> BLOCKRECOVER datafile 7 block 3
2>    datafile 2 block 235;
          \end{lstlisting}
        \end{enumerate}
        Ist die Liste der defekten Bl\"ocke sehr gro\ss{}, kann das folgende Kommando genutzt werden, um alle korrupten Bl\"ocke in einem Arbeitsgang zu recovern:
          \begin{lstlisting}[caption={Das Kommando BLOCKRECOVER},label=admin1496,language=rman]
RMAN> BLOCKRECOVER CORRUPTION LIST;
          \end{lstlisting}
        \begin{literaturinternet}
          \item \cite{i1016424}
        \end{literaturinternet}
    \section{Unvollst\"andiges Recovery (Point-In-Time Recovery)}
      Point-In-Time Recovery versetzt die Datenbank in einen Stand zur\"uck, der zeitlich vor dem Aktuellen liegt. Diese Art des Recovery wird auch \textit{unvollst\"andiges Recovery} genannt, da nicht alle vorhandenen Archive Logs und inkrementellen Backups zur Wiederherstellung der Datenbank benutzt werden. Ein Point-In-Time-Recovery kann gezielt erfolgen oder unfreiwillig notwendig werden, da bestimmte Teile der Datenbank verloren gegangen sind.
      \subsection{Die Datenbank im Verlauf der Zeit}
        Ist Datenverlust f\"ur eine Datenbank inakzeptabel, m\"ussen zwei Dinge sichergestellt werden:
        \begin{enumerate}
          \item Die Datenbank muss sich im ARCHIVELOG Modus befinden.
          \item Es m\"ussen regelm\"assig Backups der Datenbank angefertigt werden.
        \end{enumerate}
        Wenn diese beiden Bedingungen erf\"ullt sind, k\"onnte ein Ausschnitt aus dem Lebenszyklus einer Datenbank wie folgt aussehen:
        \bild{Lebenszyklus einer Datenbank erster Teil}{lebenszyklus1}{0.4}
        \abbildung{lebenszyklus1} zeigt eine Datenbank f\"ur die die drei Backups, Backup 1, Backup 2 und Backup 3 existieren. Desweitern sind insgesamt 16 Archive Logs mit der Logsequenz Nummern 1 bis 16 vorhanden. In diesem Szenario kann die Datenbank auf jeden beliebigen Zeitpunkt zwischen der Erstellung von Backup 1 und JETZT zur\"uckgesetzt werden.

        In der folgenden \abbildung{lebenszyklus2} wird der Fall dargestellt, dass zum Zeitpunkt X f\"alschlicher Weise eine Tabelle gel\"oscht wurde, die unbedingt wiederhergestellt werden muss.
        \bild{Lebenszyklus einer Datenbank zweiter Teil}{lebenszyklus2}{0.4}
        Um den Verlust der Tabelle wieder auszugleichen, muss die Datenbank auf einen Zeitpunkt zur\"uckgesetzt werden, der vor dem Zeitpunkt X liegt.
        \bild{Lebenszyklus einer Datenbank dritter Teil}{lebenszyklus3}{0.4}
        Um dieses Ziel zu erreichen, m\"ussen folgende Schritte durchgef\"uhrt
        werden:
        \begin{enumerate}
          \item RESTORE: Wiederherstellen von Backup Nummer 3
          \item RECOVER: Benutzen der Archive Logs Nummer 12, 13, 14 und von Teilen des Archive Log Nummer 15 um sich an den Zeitpunkt (X - n) heranzutasten.
          \item \"Offnen der Datenbank
        \end{enumerate}
        Die Folgen dieses Szenarios w\"aren:
        \begin{itemize}
          \item Die Datenbank wurde zur\"uckgesetzt auf die Logsequenz Nummer 14.
          \item Der Inhalt der aktuellen Redo Log Datei, mit der Logsequenz Nummer 17 ist unbrauchbar.
        \end{itemize}
        Daraus ergibt sich Folgendes:
        \begin{enumerate}
          \item Die Redo Log Dateien m\"ussen geleert/formatiert werden, da ihr Inhalt unbrauchbar ist. Die Redo Logs werden im weiteren Verlauf mit neuem Inhalt gef\"ullt.
          \item Bei einem Logswitch w\"urde erneut eine Archive Log Datei mit der Nummer 15 erzeugt werden, die es aber bereits gibt.
        \end{enumerate}
        Um die Problematik der Erzeugung von Archive Log Dateien mit gleicher Log Sequenze Nummer (in diesem Beispiel LSN 15) zu vermeiden, hat Oracle den Begriff der \enquote{Inkarnation} eingef\"uhrt.
        \begin{merke}
          Unter einer Inkarnation versteht Oracle den Lebenszyklus einer Datenbank. Der Anfang eines Lebenszykluses wird durch den Zeitpunkt markiert, an dem die Logsequenz Nummer 1 vergeben wurde. Das Ende wird durch ein Point-In-Time-Recovery markiert.
        \end{merke}
        Mit diesen neuen Erkenntnissen ergibt sich nach dem Recovery der Datenbank, aus dem obigen Beispiel, ein anderes Bild:

        \bild{Lebens\-zyklus einer Datenbank vierter Teil}{lebenszyklus4}{0.5}

        Durch das \"Offnen der Datenbank und das Zur\"ucksetzen der Logsequenz Nummer auf 1 wird ein neuer Lebenszyklus der Datenbank begonnen, also eine neue Inkarnation.
        \begin{merke}
          Eine neue Datenbankinkarnation wird immer dann erstellt, wenn beim \"Offnen der Datenbank das Kommando \languageorasql{ALTER DATABASE OPEN RESETLOGS} verwendet wird. Die Z\"ahlung der Inkarnationen beginnt bei 1 und wird fortlaufend durchgef\"uhrt.
        \end{merke}
        Obwohl in dieser Situation jetzt zwei Archive Log Dateien mit der Logsequenz Nummer 1 existieren, kann die Datenbank diese Beiden, anhand der Inkarnationsnummer 1 bzw. 2 auseinanderhalten.

        \begin{merke}
          Um sehen zu k\"onnen, welche Datenbankinkarnationen existieren, kann im RMAN das Kommando \languagerman{LIST INCARNATION} oder in SQL*Plus die View  \identifier{v\$database\_incarnation} benutzt werden.
        \end{merke}

        \begin{lstlisting}[caption={Die View v\$database\_incarnation},label=admin1497,language=oracle_sql,emph={[9]CURRENT},emphstyle={[9]\color{black}}]
SQL> SELECT incarnation#, resetlogs_change#, prior_incarnation#
  2  FROM   v$database_incarnation

INCARNATION# RESETLOGS_CHANGE# PRIOR_INCARNATION#
------------ ----------------- ------------------
           1                 1                  0
           2            446075                  1
           3            498982                  2
           4            500243                  2

          \end{lstlisting}
\clearpage
          In \beispiel{admin1497} zeigt die Spalte \textit{RESETLOGS\_CHANGE\#}
          die SCN, des Startzeitpunktes der jeweiligen Inkarnation an. Wie zu
          sehen ist, beginnt Inkarnation Nummer 1 mit SCN 1 und jede weitere
          Inkarnation mit einer h\"oheren SCN. Somit l\"ast sich folgendes Bild
          zeichnen:

          \bild{Da\-ten\-bank\-in\-kar\-na\-tion\-en}{incarnations_scn}{0.375}

        \subsubsection{Inkarnationen und die Logsequenz Nummer (LSN)}
          Eine neue Inkarnation wird mit dem Kommando \lstinline[language=oracle_sql]{ALTER DATABASE OPEN RESETLOGS} erzeugt. Das Schl\"usselwort \lstinline[language=oracle_sql]{RESETLOGS} deutet darauf hin, dass die Logsequenz Nummer bei jeder neuen Inkarnation auf den Wert 1 zur\"uckgesetzt wird. Tats\"achlich geschehen folgende Schritte:
          \begin{enumerate}
            \item Die aktuellen Redo Logs werden archiviert,
            \item die Log Sequenze Nummer wird auf den Wert 1 zur\"uckgesetzt und
            \item die Redo Logs erhalten einen neuen Zeitstempel, sowie eine neue SCN.
          \end{enumerate}
      \subsection{Voraussetzungen f\"ur Database Point-In-Time Recovery}
        Um ein Database-Point-In-Time-Recovery durchf\"uhren zu k\"onnen, m\"ussen die folgenden Voraussetzungen gegeben sein:
        \begin{itemize}
          \item Die betreffende Datenbank muss sich im Archivelog-Modus befinden.
          \item Es m\"ussen Backups aller Datendateien bestehen, die vor dem gew\"unschten Reco\-very\-zeit\-punkt entstanden sind.
          \item Alle Archive Logs, die zum Roll-Forward des Backups bis zum gew\"unschten Reco\-very\-zeit\-punkt ben\"otigt werden, m\"ussen vorhanden sein.
        \end{itemize}
      \subsection{Database Point-In-Time Recovery vorbereiten}
        Die folgenden Schritte sollten f\"ur ein Datenbank Point-In-Time Recovery vorbereitet werden.
        \begin{itemize}
          \item Festlegen des Zielzeitpunktes, der SCN, des Restore-Points oder der Log Sequence Number, bei der das Recovery stoppen soll. Dies kann mit Hilfe der Oracle Flashback Features geschehen. Auch die Alert.log-Datei kann hierbei dienlich sein.
          \item Soll als Abbruchkriterium f\"ur das Recovery ein Zeitpunkt verwendet werden, sollten die beiden Umgebungsvariablen \oscommand{NLS\_LANG} und \oscommand{NLS\_DATE\_FORMAT} gesetzt sein.
        \end{itemize}
      \subsection{Point-In-Time Recovery durchf\"uhren}\label{dbpitrinc}
        \begin{enumerate}
          \item Starten des RMAN und mit der Zieldatenbank verbinden.
            \begin{lstlisting}[caption={Starten und Anmelden},label=admin1498,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle
            \end{lstlisting}
          \item \"Uberf\"uhren der Datenbank in die MOUNT-Phase.
            \begin{lstlisting}[caption={Shutdown und Mounten},label=admin1499,language=rman,alsolanguage=sqlplus]
RMAN> shutdown immediate
RMAN> startup mount
            \end{lstlisting}
          \item Die folgenden Schritte sollten in einem RUN-Block ausgef\"uhrt werden:
            \begin{enumerate}
              \item Zielzeitpunkt mit dem \languagerman{SET UNTIL}-Kommando festlegen.
              \item Kan\"ale zum Zugriff auf die Datenbank konfigurieren, falls keine automatisch Vorkonfigurierten vorhanden sind.
              \item Restore and Recovery
            \end{enumerate}
            \begin{lstlisting}[caption={Restore and Recovery},label=admin1500,language=rman]
RMAN> RUN {
2>      SET UNTIL TIME '31.10.2013 10:30:00';
#Alternativen
# SET UNTIL SCN 487159;
# SET UNTIL SEQUENCE 62;
# SET UNTIL RESTORE POINT before_update;
3>
4>      RESTORE database;
5>      RECOVER database;
6>    }
            \end{lstlisting}
          \item Datenbank mit \languageorasql{OPEN RESETLOGS} \"offnen
            \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1501,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
            \end{lstlisting}
        \end{enumerate}
      \subsection{Recovery nach Verlust der Kontrolldatei (mit Recovery Katalog)}
        \label{recoverywithabackupcontrolfile}
        Wenn es vorkommt, dass alle Kopien der Kontrolldatei einer Datenbank zerst\"ort werden oder verloren gehen, muss eine Kontrolldatei aus einem Backup wiederhergestellt werden. Diese wird dann als \enquote{Backupcontrolfile} bezeichnet. Da die Kontrolldatei aus einem Backup, nicht mehr den aktuellsten Stand der Datenbank wiederspiegelt, muss die gesamte Datenbank auf den Stand des Backupcontrolfile recovered werden.
        \subsubsection{Wiederherstellen eines Controlfiles aus einem Controlfile Autobackup}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank und am Recovery Katalog anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank und am Recovery Katalog anmelden},label=admin1502,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle catalog catowner/catpass@CATDB
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1503,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des Controlfiles aus dem Controlfile Autobackup
              \begin{lstlisting}[caption={Wiederherstellen des Controlfiles},label=admin1504,language=rman]
RMAN> RESTORE controlfile
2>    FROM AUTOBACKUP;
              \end{lstlisting}
            \item Die Zieldatenbank in den MOUNT-Status versetzen
              \begin{lstlisting}[caption={Zieldatenbank mounten},label=admin1505,language=rman,emph={[9]ALTER,DATABASE,MOUNT},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE MOUNT';
              \end{lstlisting}
            \item Wiederherstellen aller Datendateien
              \begin{lstlisting}[caption={Datendateien wiederherstellen},label=admin1506,language=rman]
RMAN> RESTORE database;
              \end{lstlisting}
            \item Recovern der Datenbank
              \begin{lstlisting}[caption={Recovern der Datenbank},label=admin1507,language=rman]
RMAN> RECOVER database;
              \end{lstlisting}
            \item \"Offnen der Datenbank mit der Option \languageorasql{OPEN RESETLOGS}
              \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1508,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
              \end{lstlisting}
            \end{enumerate}
        \subsubsection{Wiederherstellen eines Controlfiles aus einem Backup Set}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank und am Recovery Katalog anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank und am Recovery Katalog anmelden},label=admin1509,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle catalog catowner/catpass@CATDB
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1510,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des Controlfiles.
              \begin{lstlisting}[caption={Wiederherstellen des Controlfiles},label=admin1511,language=rman]
RMAN> RESTORE controlfile;
              \end{lstlisting}
            \item Die Zieldatenbank in den MOUNT-Status versetzen
              \begin{lstlisting}[caption={Zieldatenbank mounten},label=admin1512,language=rman,emph={[9]ALTER,DATABASE,MOUNT},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE MOUNT';
              \end{lstlisting}
            \item Wiederherstellen aller Datendateien
              \begin{lstlisting}[caption={Datendateien wiederherstellen},label=admin1513,language=rman]
RMAN> RESTORE database;
              \end{lstlisting}
            \item Recovern der Datenbank
              \begin{lstlisting}[caption={Recovern der Datenbank},label=admin1514,language=rman]
RMAN> RECOVER database;
              \end{lstlisting}
            \item \"Offnen der Datenbank mit der Option \languageorasql{OPEN RESETLOGS}
              \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1515,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
              \end{lstlisting}
            \end{enumerate}
\clearpage
      \subsection{Recovery nach Verlust der Kontrolldatei (ohne Recovery Katalog)}
        \subsubsection{Wiederherstellen eines Controlfiles aus einem Controlfile Autobackup}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden.
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden},label=admin1516,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle
              \end{lstlisting}
            \item Setzen der DBID
              \begin{lstlisting}[caption={Setzen der DBID},label=admin1517,language=rman]
RMAN> SET DBID 1351916467;
              \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1518,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des Controlfiles aus dem Controlfile Autobackup
              \begin{lstlisting}[caption={Wiederherstellen des Controlfiles},label=admin1519,language=rman]
RMAN> RESTORE controlfile FROM AUTOBACKUP
2>    RECOVERY AREA '/u05/fast_recovery_area'
3>    DB_NAME       'orcl';
              \end{lstlisting}
              \begin{merke}
                Wenn die Instanz nicht gemountet oder ge\"offnet ist, ist es dem
                RMAN unm\"oglich, den Speicherort der Controlfile Autobackups zu
                ermitteln. Mit Hilfe der beiden Parameter \languagerman{RECOVERY
                AREA} und \languagerman{DB_NAME} wird der Speicherort, die Fast
                Recovery Area, dem RMAN mitgeteilt.
              \end{merke}
            \item Die Zieldatenbank in den MOUNT-Status versetzen
              \begin{lstlisting}[caption={Zieldatenbank
              mounten},label=admin1520,language=rman,emph={[9]ALTER,DATABASE,MOUNT},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE MOUNT'
              \end{lstlisting}
\clearpage
            \item Wiederherstellen aller Datendateien
              \begin{lstlisting}[caption={Datendateien wiederherstellen},label=admin1521,language=rman]
RMAN> RESTORE database;
              \end{lstlisting}
            \item Recovern der Datenbank
              \begin{lstlisting}[caption={Recovern der Datenbank},label=admin1522,language=rman]
RMAN> RECOVER database;
              \end{lstlisting}
            \item \"Offnen der Datenbank mit der Option \languageorasql{OPEN RESETLOGS}
              \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1523,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
              \end{lstlisting}
            \end{enumerate}
        \subsubsection{Wiederherstellen eines Controlfiles aus einem Backup Set}
          \begin{enumerate}
            \item Mit dem RMAN an der Zieldatenbank anmelden und die DBID setzen.
              \begin{lstlisting}[caption={An der Zieldatenbank anmelden und die DBID setzen},label=admin1524,language=rman]
[oracle@FEA11-119SRV ~]$ rman target sys/oracle

RMAN> SET DBID 1351916467;
                  \end{lstlisting}
            \item Wurde die Zieldatenbank heruntergefahren, muss erst eine Instanz erzeugt werden. Der RMAN benutzt Standardeinstellungen, um eine Minimalinstanz zuerstellen. Diese kann f\"ur das weitere Recovery genutzt werden.
              \begin{lstlisting}[caption={Zieldatenbank im RMAN in den NOMOUNT-Status bringen},label=admin1525,language=rman,alsolanguage=sqlplus]
RMAN> startup nomount
              \end{lstlisting}
              \begin{merke}
                Dieser Schritt ist in SQL*Plus nicht m\"oglich!
              \end{merke}
            \item Wiederherstellen des Controlfiles.
              \begin{lstlisting}[caption={Wiederherstellen des Controlfiles},label=admin1526,language=rman]
RMAN> RESTORE controlfile
2>    FROM '/u02/3ukkpd6p.bkp';
              \end{lstlisting}
            \item Die Zieldatenbank in den MOUNT-Status versetzen
              \begin{lstlisting}[caption={Zieldatenbank mounten},label=admin1527,language=rman,emph={[9]ALTER,DATABASE,MOUNT},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE MOUNT'
              \end{lstlisting}
            \item Wiederherstellen aller Datendateien
              \begin{lstlisting}[caption={Datendateien wiederherstellen},label=admin1528,language=rman]
RMAN> RESTORE database;
              \end{lstlisting}
            \item Recovern der Datenbank
              \begin{lstlisting}[caption={Recovern der Datenbank},label=admin1529,language=rman]
RMAN> RECOVER database;
              \end{lstlisting}
            \item \"Offnen der Datenbank mit der Option \languageorasql{OPEN RESETLOGS}
              \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1530,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
              \end{lstlisting}
            \end{enumerate}
      \subsection{Wiederherstellen einer Datenbank im NOARCHIVELOG Modus}
        Das Wiederherstellen einer Datenbank im NOARCHIVELOG Modus ist \"ahnlich dem Wiederherstellen einer Datenbank im ARCHIVELOG Modus. Die Hauptunterschiede dabei sind:
        \begin{itemize}
          \item Es k\"onnen nur Coldbackups zur Wiederherstellung verwendet werden.
          \item Block Media Recovery ist nicht m\"oglich, da keine Archive Logs existieren.
        \end{itemize}
        Mit Hilfe von inkrementellen Backups ist auch im NOARCHIVELOG Modus eine eingeschr\"ankte Form des Recovery m\"oglich.

        Das folgende Szenario verdeutlicht das Recovery einer Datenbank im NOARCHIVELOG Modus.
        \begin{itemize}
          \item Die Datenbank l\"auft im NOARCHIVELOG Modus.
          \item Es wird ein Recovery Katalog benutzt.
          \item Die Datenbank wird konsistent heruntergefahren und es wird ein Level 0 Backup am Sonntagabend gemacht.
          \item Am darauf folgenden Mittwoch wird die Datenbank ebenfalls konsistent heruntergefahren und es wird ein Level 1 Backup angefertigt.
          \item Donnerstagabend crashed die Datenbank. Es gehen 50 \% aller Datendateien und s\"amtliche Redo Logs verloren.
        \end{itemize}
        In solch einem Fall muss ein Media Recovery unter Nutzung des Level 0 und des Level 1 Backups durchgef\"uhrt werden. Weiterhin muss ber\"ucksichtig werden, dass die Redo Logs komplett verloren gegangen sind.
        \begin{enumerate}
          \item Mit dem RMAN an der Zieldatenbank und am Recovery Katalog anmelden.
            \begin{lstlisting}[caption={An der Zieldatenbank und am Recovery Katalog anmelden},label=admin1531,language=rman]
[oracle@FEA11-119SRV ~]$ rman target / catalog catowner/catpass@CATDB
            \end{lstlisting}
          \item Herunterfahren der Datenbank und starten im NOMOUNT-Status.
            \begin{lstlisting}[caption={Shutdown und Mounten},label=admin1532,language=rman,alsolanguage=sqlplus]
RMAN> startup force nomount;
            \end{lstlisting}
            Ein \languagesqlplus{startup force nomount} kann ohne Weiteres durchgef\"uhrt werden, da die Datenbank bereits irreparabel besch\"adigt ist. Ein konsistentes Herunterfahren ist nicht mehr n\"otig/m\"oglich.
          \item Wiederherstellen der Kontrolldatei auf einem Autobackup oder einem Backup Set.
            \begin{lstlisting}[caption={Kontrolldatei wiederherstellen},label=admin1533,language=rman]
RMAN> RESTORE controlfile;
            \end{lstlisting}
          \item Die Datenbank in den MOUNT-Status \"uberf\"uhren
            \begin{lstlisting}[caption={MOUNT-Status erreichen},label=admin1534,language=rman,emph={[9]ALTER, DATABASE,MOUNT},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE MOUNT';
            \end{lstlisting}
          \item Wiederherstellen der Datenbankdateien
            \begin{lstlisting}[caption={Datenbankdateien wiederherstellen},label=admin1535,language=rman]
RMAN> RESTORE database;
            \end{lstlisting}
          \item Recovern der Datenbank
            \begin{lstlisting}[caption={Datenbankdateien wiederherstellen},label=admin1536,language=rman]
RMAN> RECOVER database NOREDO;
            \end{lstlisting}
          \item \"Offnen der Datenbank
            \begin{lstlisting}[caption={Datenbank mit open resetlogs \"offnen},label=admin1537,language=rman,emph={[9]ALTER,DATABASE,OPEN,RESETLOGS},emphstyle={[9]\color{magenta}\bfseries}]
RMAN> SQL 'ALTER DATABASE OPEN RESETLOGS';
            \end{lstlisting}
        \end{enumerate}
        Bei diesem Vorgang werden alle \"Anderungen, die bis einschlie\ss{}lich des Level 1 Backups vorgenommen wurden recovered. Die Angabe von \languagerman{NOREDO} sorgt daf\"ur, dass RMAN nicht versucht, die Redo Logs beim Recovery zu nutzen, da diese nicht mehr existieren.

        Selbst wenn die Redo Logs noch existieren w\"urden, m\"usste trotzdem die \languagerman{NOREDO}-Klausel angegeben werden, da zwischen den letzten \"Anderung im Level 1 Backup und den Redo Logs eine gro\ss{}e L\"ucke klafft.
    \section{Der Data Recovery Advisor}
      Der Data Recovery Advisor ist eine mit Oracle 11g neu eingef\"uhrte PL/SQL-Anwendung, die den Adminstrator bei einem Recovery-Szenario unterst\"utzt. Er kann automatisch nach Fehlern und L\"osungen suchen und, per Anweisung des Admins, eine Reparatur ausf\"uhren.

      Ohne dieses Tool muss der Admin selbstst\"andig eine Fehlerdiagnose durchf\"uhren und anschlie\ss{}end geeignete Ma\ss{}nahmen ergreifen, um die Sch\"aden zu beheben. Eine solches Prozedere ist sehr umst\"andlich und fehleranf\"allig, weshalb es gute Kenntnisse der Materie und ein hohes Ma\ss{} an Erfahrung erfordert.
      \subsection{Fehler}
        Fehler, im Sinne des Data Recovery Advisors sind persistente St\"orungen der Datenbank die durch einen \enquote{Data Integrity Check} gefunden wurden. Sobald ein Fehler festgestellt wurde, kann der Data Recovery Advisor Informationen dar\"uber liefern und ihn gegeben\-en\-falls beheben. Gespeichert werden Fehler nicht innerhalb der Datenbank, sondern im Automatic Diagnostic Repository, kurz ADR, einer Verzeichnisstruktur im Dateisystem. Daher wird die Funktionsweise des Data Recovery Advisor nicht beeintr\"achtigt, falls sich die Datenbank in der NOMOUNT-Phase befindet.
        \subsubsection{Fehlerarten}
          Der Data Recovery Advisor ist in der Lage, verschiedenste Fehlerarten zu erkennen. Beispielsweise kann er feststellen, dass Datenbankdateien (Datendateien, Kontroll- und Redo Log Dateien) nicht ge\"offnet werden k\"onnen, weil sie nicht existieren oder Zugriffsrechte fehlen. Des Weiteren kann er Besch\"adigungen von Dateien erkennen, wenn z. B. eine Datendatei nicht mehr synchron mit der Datenbank ist (Inkonsistenz) oder wenn einzelne Oraclebl\"ocke physikalisch besch\"adigt sind. Teilweise kann er sogar Fehler erkennen, die nicht in der Datenbank, sondern im Betriebssystem auftreten (Disk I/O, Treiberfehler, usw.).
        \subsubsection{Status und Priorit\"at}
          Jeder Fehler hat einen Status und eine Priorit\"at. Wenn ein Fehler entsteht, erh\"alt er automatisch den Status \enquote{Open}. Sobald der Fehler behoben wurde, wird der Status auf \enquote{Closed} ge\"andert. Diese Status\"anderung geschieht entweder durch das RMAN-Kommando \languagerman{LIST FAILURE} oder durch \languagerman{CHANGE FAILURE}.

          Wie schwerwiegend ein Fehler ist, wird in drei Priorit\"atsklassen ausgedr\"uckt: \enquote{LOW}, \enquote{HIGH} und \enquote{CRITICAL}.
          \begin{itemize}
            \item \textbf{CRITICAL}: Dies sind schwerwiegende Fehler, die die Verf\"ugbarkeit der gesamten Datenbank beeinflussen k\"onnen und die deshalb sofortiger Aufmerksamkeit bed\"urfen (Ausfall von Kontrolldateien oder des \identifier{system}-Tablespaces).
            \item \textbf{HIGH}: Dies Fehlerklasse umfasst alle Ereignisse, welche die Verf\"ugbarkeit von Teilen der Datenbank beeinflussen k\"onnen (Korrupte Bl\"ocke, Ausfall von Nicht-System-Tablespaces, fehlen von Archive Logs).
            \item \textbf{LOW}: Die Fehlerklasse \enquote{LOW} wird nicht vom System, sondern nur vom Administrator vergeben, wenn er Fehler der Klasse \enquote{HIGH} als \enquote{nicht besonders wichtig} einstuft.
          \end{itemize}
      \subsection{Die Fehlersuche - LIST FAILURE}
        Das Kommando \languagerman{LIST FAILURE} dient dazu, die Ergebnisse von automatischen oder manuellen Fehlerdiagnosen anzuzeigen. \languagerman{LIST FAILURE} selbst diagnostiziert keine Fehler.
        \begin{lstlisting}[caption={Das Kommando \languagerman{LIST FAILURE}},label=admin1538,language=rman]
RMAN> LIST FAILURE;

List of Database Failures
=========================

Failure ID Priority Status    Time Detected Summary
---------- -------- --------- ------------- -------
42         HIGH     &OPEN&      01-NOV-13     One or more non-system
datafiles are missing
1141       HIGH     &OPEN&      01-NOV-13     Datafile 7:
'/u01/app/oracle/oradata/orcl/bank02.dbf' contains one or more corrupt blocks
        \end{lstlisting}
        \beispiel{admin1538} zeigt zwei Fehler der Kategorie \enquote{HIGH}, versehen mit den IDs 42 und 1141. In der Spalte \enquote{Summary} wird eine kurze Erkl\"arung zu diesen Fehlern angezeigt.
      \subsection{Der Ratschlag - ADVISE FAILURE}
        Mit dem \languagerman{ADVISE FAILURE}-Befehl k\"onnen durch den RMAN generierte Reparaturskripte angezeigt und bereits behobene Fehler geschlossen werden (Status \enquote{CLOSED}).
        \begin{merke}
          Es muss immer zuerst das Kommando \languagerman{LIST FAILURE} ausgef\"uhrt werden, bevor der Befehl \languagerman{ADVISE FAILURE} ausgef\"uhrt werden kann.
        \end{merke}

        \begin{lstlisting}[caption={Das Kommando \languagerman{ADVISE FAILURE}},label=admin1539,language=rman]
RMAN> ADVISE FAILURE;

List of Database Failures
=========================

Failure ID Priority Status    Time Detected Summary
---------- -------- --------- ------------- -------
42         HIGH     &OPEN&      01-NOV-13     One or more non-system
datafiles are missing
1141       HIGH     &OPEN&      01-NOV-13     Datafile 7:
'/u01/app/oracle/oradata/orcl/bank02.dbf' contains one or more corrupt blocks

analyzing automatic repair options; this may take some time
using channel ORA_DISK_1
using channel ORA_DISK_2
allocated channel: ORA_SBT_TAPE_1
channel ORA_SBT_TAPE_1: SID=134 device type=SBT_TAPE
channel ORA_SBT_TAPE_1: WARNING: Oracle Test Disk API
analyzing automatic repair options complete

Mandatory Manual Actions
========================
no manual actions available

Optional Manual Actions
=======================
1. If file /u01/app/oracle/oradata/orcl/bank01.dbf was unintentionally
renamed or moved, restore it

Automated Repair Options
========================
Option Repair Description
------ ------------------
1      Restore and recover datafile 6; Recover multiple corrupt blocks
       in datafile 7
  Strategy: The repair includes complete media recovery with no data loss
  Repair script: /u01/app/oracle/diag/rdbms/orcl/orcl/hm/reco_184824511.hm
        \end{lstlisting}
        Zuerst wird eine Liste der erkannten Fehler angezeigt, bevor dann eine Analyse durchgef\"uhrt wird, um automatische Reparaturma\ss{}nahmen zu finden. Diese werden dann in einem Reparaturskript zusammengefasst, dessen Name ganz unten im Bericht angezeigt wird.
        \begin{lstlisting}[caption={Das Reparaturskript},label=admin1540,language=rman]
Strategy: The repair includes complete media recovery with no data loss
Repair script: /u01/app/oracle/diag/rdbms/orcl/orcl/hm/reco_184824511.hm
        \end{lstlisting}
        \begin{merke}
          RMAN versucht immer seine Reparaturskripte zu konsolidieren, was bedeutet, dass m\"oglichst viele Fehler mit m\"oglichst wenigen Reparaturschritten behoben werden sollen. In manchen F\"allen ist dies jedoch nicht m\"oglich, weshalb RMAN dann eine Meldung anzeigt, dass aktuell einige Fehler nicht behoben werden k\"onnen.
        \end{merke}
        \languagerman{ADVISE FAILURE} zeigt aber nicht nur automatische Reparaturma\ss{}nahmen an, sondern wo immer es sich anbietet auch Manuelle. Diese werden in \enquote{optionale} und \enquote{zwingend notwendige} Ma\ss{}nahmen unterteilt.

        \beispiel{admin1539} zeigt f\"ur Datendatei Nummer 6 einen optionalen Schritt an. Sollte die Datei nur aus Versehen umbenannt oder verschoben worden sein, kann dieser Schritt manuell r\"uckg\"angig gemacht werden. Eine solche Vorgehensweise ist unter Umst\"anden viel zeit- und ressourcensparender als ein Restore \& Recovery der Datendatei.

        Mandatory manual options werden immer dann angezeigt, wenn keine
        automatischen Reparaturschritte erzeugt werden k\"onnen. Dies k\"onnte
        z. B. dann der Fall sein, wenn ein Archive Log fehlt, dass f\"ur das
        Recovery einer Datendatei ben\"otigt wird.
        \begin{lstlisting}[caption={Mandatory manual options},label=admin1541,language=rman]
RMAN> ADVISE FAILURE;

List of Database Failures
=========================

Failure ID Priority Status    Time Detected Summary
---------- -------- --------- ------------- -------
42         HIGH     &OPEN&      01-NOV-13     One or more non-system
datafiles are missing
1141       HIGH     &OPEN&      01-NOV-13     Datafile 7:
'/u01/app/oracle/oradata/orcl/bank02.dbf' contains one or more corrupt blocks

analyzing automatic repair options; this may take some time
using channel ORA_DISK_1
using channel ORA_DISK_2
using channel ORA_SBT_TAPE_1
        \end{lstlisting}
\clearpage
        \begin{lstlisting}[language=rman]
analyzing automatic repair options complete

Mandatory Manual Actions
========================
1. If file /u01/app/oracle/oradata/orcl/bank01.dbf was unintentionally
   renamed or moved, restore it
2. If you have an export of tablespace BANK, then drop and re-create
   the tablespace and import the data.
3. No backup of block 232 in file 7 was found. Drop and re-create the
   associated object (if possible), or use the DBMS_REPAIR package to
   repair the block corruption
4. No backup of block 233 in file 7 was found. Drop and re-create the
   associated object (if possible), or use the DBMS_REPAIR package to
  repair the block corruption
5. No backup of block 234 in file 7 was found. Drop and re-create the
   associated object (if possible), or use the DBMS_REPAIR package to
   repair the block corruption
6. No backup of block 235 in file 7 was found. Drop and re-create the
   associated object (if possible), or use the DBMS_REPAIR package to
   repair the block corruption
7. Contact Oracle Support Services if the preceding recommendations
   cannot be used, or if they do not fix the failures selected for repair

Optional Manual Actions
=======================
no manual actions available

Automated Repair Options
========================
no automatic repair options available
        \end{lstlisting}
      \subsection{Die Reparatur - REPAIR FAILURE}
        Der \enquote{Dritte im Bunde} ist \languagerman{REPAIR FAILURE}. Dieses
        Kommando benutzt das von \languagerman{ADVISE FAILURE} erstellte
        Reparaturskript, um die festgestellten Fehler zu beheben. Vor der
        eigentlichen Reparatur kann mit Hilfe von \languagerman{REPAIR FAILURE
        PREVIEW} zuerst das komplette Repairscript angzeigt werden.
\clearpage
        \begin{lstlisting}[caption={Eine Vorschau auf das Repairscript},label=admin1542,language=rman]
RMAN> REPAIR FAILURE PREVIEW;

Strategy: The repair includes complete media recovery with no data loss
Repair script: /u01/app/oracle/diag/rdbms/orcl/orcl/hm/reco_1758777565.hm

contents of repair script:
   # restore and recover datafile
   sql 'alter database datafile 6 offline';
   restore datafile 6;
   recover datafile 6;
   sql 'alter database datafile 6 online';
   # block media recovery for multiple blocks
   recover datafile 7 block 232 to 235;
        \end{lstlisting}
        Bevor der Befehl \languagerman{REPAIR FAILURE} ausgef\"uhrt wird, sollte immer zuerst eine Endkontrolle des Reparaturskripts erfolgen.
        \begin{lstlisting}[caption={Die Fehler reparieren},label=admin1543,language=rman]
RMAN> REPAIR FAILURE;

Strategy: The repair includes complete media recovery with no data loss
Repair script: /u01/app/oracle/diag/rdbms/orcl/orcl/hm/reco_1758777565.hm

contents of repair script:
   # restore and recover datafile
   sql 'alter database datafile 6 offline';
   restore datafile 6;
   recover datafile 6;
   sql 'alter database datafile 6 online';
   # block media recovery for multiple blocks
   recover datafile 7 block 232 to 235;

Do you really want to execute the above repair (enter YES or NO)? YES
executing repair script
        \end{lstlisting}
\clearpage
    \section{Informationen}
      \subsection{Verzeichnis der relevanten Initialisierungsparameter}
        \begin{literaturinternet}
          \item \cite{REFRN10029}
          \item \cite{REFRN10030}
          \item \cite{REFRN10268}
          \item \cite{REFRN10295}
          \item \cite{REFRN10061}
          \item \cite{REFRN10089}
          \item \cite{REFRN10086}
        \end{literaturinternet}
      \subsection{Verzeichnis der relevanten Data Dictionary Views}
        \begin{literaturinternet}
          \item \cite{REFRN30047}
          \item \cite{REFRN30048}
          \item \cite{REFRN30049}
          \item \cite{sthref3281}
          \item \cite{REFRN30052}
          \item \cite{REFRN30196}
          \item \cite{sthref3785}
        \end{literaturinternet}
\clearpage
