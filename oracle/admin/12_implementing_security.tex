  \chapter{Implementing Security}
    \setcounter{page}{1}\kapitelnummer{chapter}
    \minitoc
\newpage
    \section{Database Auditing}
      Auditing ist das \"Uberwachen und Aufzeichnen von ausgew\"ahlten Aktionen,
      die innerhalb der Datenbank stattfinden. Es kann auf Einzelnen oder auf
      einer Kombination von Faktoren (z. B. Nutzername, Anwendung, Anmeldezeit,
      usw.) basieren. Auditing \"ublicherweise f\"ur die folgenden Zwecke
      genutzt:
      \begin{itemize}
        \item Abschreckung von Nutzern, vor unerlaubten Zugriffen auf Objekte,,
        au\ss erhalb ihres Verantwortungsbereiches.
        \item Daten \"uber bestimmte Aktivit\"aten in der Datenbank sammeln
        \item Verd\"achtige Nutzeraktivit\"aten aufdecken
        \item Aufdecken von Problemen mit Autorisations- und Zugriffskontrollmechanismen
      \end{itemize}
      In Oracle gibt es f\"unf Arten des Auditings:
      \begin{itemize}
        \item \textbf{Statementauditing}: Die Nutzung bestimmter SQL-Statements wird \"uberwacht.
        \item \textbf{Privilegeauditing}: Die Nutzung von Privilegien wird \"uberwacht.
        \item \textbf{Objectauditing}: Der Zugriff auf bestimmte Objekte wird \"uberwacht.
        \item \textbf{Networkauditing}: \"Uberwachung von Fehlern im Netzwerk
        \item \textbf{Standardauditing}: Standardm\"a\ss{}ige \"Uberwachung, die immer aktiv ist.
      \end{itemize}
      \begin{merke}
        Jeder Datenbankadministrator kann das Auditing jederzeit aktivieren.
      \end{merke}
      \subsection{Grunds\"atze und Vorgehensweisen beim Auditing}
        Oracle 11g erm\"oglicht es Auditinginformationen in den Auditingtrail
        der Datenbank oder den des Betriebssystems (Windowsereignisanzeige oder
        SysLog Daemon) zu schreiben. Je nachdem welche Nutzergruppe \"uberwacht
        werden muss, normale Nutzer oder Administratoren, empfiehlt es sich
        einen ad\"aquaten Auditingtrail auszuw\"ahlen, so dass dieser nicht
        durch den betroffenen Nutzerkreis ver\"andert/gef\"alscht werden kann.
        Datenbankadministratoren z. B. haben in einer Oracledatenbank
        unbeschränkten Zugriff, weshalb ein Sammeln der Auditingdaten innerhalb
        der Datenbank nicht sinnvoll ist.
        \subsubsection{Auditinginformationen \"uberschaubar halten}
          Auch wenn Auditing keine gro\ss en Kosten erzeugt, sollte die Menge der Auditinginformationen auf das Notwendigste beschr\"ankt werden. Auf diese Weise soll der Auditingtrail \"uberschaubar gehalten und eine einfache Auswertung der Informationen erm\"oglicht werden.

          Das Wichtigste f\"ur die Entwicklung einer Auditingstrategie ist: Der genaue Zweck des Auditings muss bestimmt werden. Erst wenn festgelegt wurde, warum die Datenbank \"uberwacht werden muss, kann eine zielf\"uhrende \"Uberwachungsstrategie entwickelt werden.

          Wenn das Ziel des Auditings das Sammeln von historischen Informationen \"uber die Datenbank ist, sollten folgende Regeln eingehalten werden:
          \begin{itemize}
            \item Auditinginformationen archivieren und den Auditingtrail leeren

              Wurden alle ben\"otigten Informationen gesammelt, sollten diese archiviert und der Auditingtrail geleert werden, damit dieser sp\"ater f\"ur neue \"Uberwachungen zur Ver\-f\"u\-gung steht.
            \item Datenschutzrichtlinien beachten
            
              Das Bundesdatenschutzgesetz (BDSG) regelt sehr genau, auf welche
              Weise Daten erhoben werden dürfen wie lange diese gespeichert
              werden dürfen und wer in welchem Falle Zugriff auf die gesammelten
              Daten hat.
          \end{itemize}
        \subsubsection{\"Uberwachen von verd\"achtigen Aktivit\"aten}
          Beim \"Uberwachen verd\"achtiger Aktivit\"aten sollte wie folgt vorgegangen werden:
          \begin{itemize}
            \item Erst umfassend und dann immer spezieller auditieren

              Wenn verd\"achtige Aktivit\"aten in einem System, wie z. B. einer Datenbank, festgestellt werden, liegen meist nicht viele Informationen \"uber diese vor. Daher muss am Anfang ein umfassenderes Auditing stattfinden, bis alle notwendigen Informationen gesammelt wurden, um die \"Uberwachung auf bestimmte Objekte, Nutzer oder Aktivit\"aten einschr\"anken zu k\"onnen.

              Die Auditinginformationen sollten immer wieder dahingehend ausgewertet werden, ob nicht eine weitere Spezialisierung des Auditings stattfinden kann.
            \item Absichern des Auditingtrails vor unauthorisierten Zugriffen

              Der Auditingtrail sollte vor unerw\"unschten Ver\"anderungen von au\ss erhalb ge\-sch\"u\-tzt werden, z. B. durch eine \"Uberwachung des Auditingtrails.
          \end{itemize}
        \subsubsection{\"Uberwachen administrativer Nutzer}
          Sessions des Nutzers \identifier{sys} oder anderer Nutzer, die sich
          mit den Zus\"atzen \languagesqlplus{as sysdba} oder
          \languagesqlplus{as sysoper} anmelden, werden standardm\"a\ss{}ig
          nicht auditiert. Ist es notwendig, eine \"Uberwachung f\"ur diese
          Nutzer zu aktivieren, geschieht dies mit Hilfe des
          Initialisierungsparameters \parameter{audit\_sys\_operations}
          (statischer Parameter). Der Standardwert f\"ur diesen Parameter ist
          \enquote{false}. Wird dieser Wert auf \enquote{true} ge\"andert,
          aktiviert sich dadurch das Auditing f\"ur administratives Personal.
          \begin{merke}
            Alle Auditinginformationen \"uber den Nutzer \identifier{sys} werden im Auditingtrail des Betriebssystems und nicht in der Datenbank aufbewahrt.
          \end{merke}
      \subsection{Der Audittrail}
        \subsubsection{Informationen im Auditingtrail}
          Ein Audittrail enth\"alt unterschiedliche Informationen, abh\"angig davon, welche Ereignisse \"uberwacht werden und wie das Auditing konfiguriert wurde. Der folgende Literaturhinweis zeigt eine Auflistung der Informationen, die immer im Auditingtrail, sowohl in der Datenbank, also auch im Betriebssystem, gespeichert werden.

          \begin{literaturinternet}
            \item \cite{BCGIDBFI}
          \end{literaturinternet}

          Ist es dem Audittrail nicht mehr m\"oglich neue Eintr\"age aufzunehmen, kann eine \"uberwachte Aktion nicht durchgef\"uhrt werden und bricht mit einer Fehlermeldung ab.

          Der Auditingtrail enth\"alt keine Informationen \"uber Werte, die in einem SQL-Statement verwendet wurden. Wird beispielsweise ein \languageorasql{UPDATE}-Statement \"uberwacht, werden die alten und neuen Werte der Tabelle nicht mit aufgezeichnet. Dies kann jedoch durch das sogenannte \enquote{Fine-Grained-Auditing} erreicht werden.
        \subsubsection{Die Wahl des Auditttrails}
          Welcher Auditingtrail verwendet werden sollte, ist von verschiedenen Faktoren abh\"angig:
          \begin{itemize}
            \item Welche Aktivit\"aten sollen \"uberwacht werden?
            \item Kann Oracle den Auditingtrail des verwendeten Betriebssystems benutzen?
            \item Welcher Auditingtrail kann besser gegen unerw\"unschte Zugriffe gesichert werden?
          \end{itemize}
          Beide Audittrails haben Vor- und Nachteile, die bei der Wahl ber\"ucksichtigt werden sollten. Die folgende Liste ist eine Gegen\"uberstellung der Vorteile beider Trails.

          Datenbankauditingtrail:
          \begin{itemize}
            \item Die Ergebnisse des Auditings k\"onnen, mit Hilfe von SQL oder PL/SQL und den vordefinierten Data Dictionary Views, schnell und einfach, in der Datenbank, analysiert werden.
            \item Es kann sehr einfach ein Report \"uber die Auditinginformationen aus der Datenbank erzeugt werden.
          \end{itemize}
          Betriebssystemauditingtrail:
          \begin{itemize}
            \item Auditinginformationen die im Auditingtrail des Betriebssystems geschrieben wurden, sind unter Umst\"anden sicherer als im Datenbankauditingtrail, da f\"ur den Zugriff auf den Trail des Betriebssystems Berechtigungen ben\"otigt werden, die meist nur ein Systemadministrator hat.
            \item Die Informationen haben eine gr\"o\ss{}ere Verf\"ugbarkeit, da sie auch dann noch erreichbar sind, wenn die Datenbank heruntergefahren wurde.
            \item Die Auditinginformationen k\"onnen als XML-Dateien an einen sicheren Ort im Netzwerk geschrieben werden. Mit Hilfe der View \identifier{v\$xml\_audit\_trail} k\"on\-nen diese Dateien ganz einfach durch SQL-Kommandos abgefragt werden.
            \item Die Nutzung des Betriebssystemauditingtrails konsolidiert alle Auditinginformationen. Es k\"onnen auf diese Art und Weise alle Auditinginformationen, aller Anwendungen an einer Quelle zusammengef\"uhrt werden, was eine zentrale Auswertung  erm\"oglicht.
          \end{itemize}
        \subsubsection{Konfiguration des Auditingtrails}
          Der statische Parameter \parameter{audit\_trail} legt fest, welcher Audittrail genutzt wird. Er kann folgende Werte annehmen:
          \begin{itemize}
            \item \textbf{NONE}: Das Auditing ist deaktiviert, da kein Auditingtrail verwendet wird.
            \item \textbf{DB}: Standardverhalten. Es wird der Auditingtrail der Datenbank benutzt, mit Ausnahme der Informationen, die immer in den Betriebssystemauditingtrail geschrieben werden.
            \item \textbf{DB, EXTENDED}: Es wird der Auditingtrail der Datenbank benutzt und es werden zus\"atzliche Informationen gespeichert.
            \item \textbf{OS}: Alle Auditinginformationen werden in den Betriebssystemauditingtrail geschrieben.
            \item \textbf{XML}: Wie OS, nur das alle Informationen in XML-Dateien geschrieben werden.
            \item \textbf{XML, EXTENDED} Wie XML, aber es werden zus\"atzliche Informationen gespeichert.
          \end{itemize}
          \begin{merke}
            Der Hauptunterschied zwischen den beiden Einstellungen \enquote{DB} und \enquote{XML} zu ihren \enquote{EXTENDED} Varianten ist, dass bei \enquote{EXTENDED} der genaue Wortlaut des \"uberwachten SQL-Statements mitgespeichert wird.
          \end{merke}
          \begin{lstlisting}[caption={Der Parameter \parameter{audit\_trail}},label=admin800,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET audit_trail=XML, EXTENDED SCOPE=spfile;
          \end{lstlisting}
        \subsubsection{Einen Speicherort f\"ur den Betriebssystemauditingtrail festlegen}
          Wenn der Parameter \parameter{audit\_trail} einen der beiden Werte \enquote{OS} oder \enquote{XML} hat, legt der Parameter \parameter{audit\_file\_dest} ein Verzeichnis auf dem Datentr\"ager fest, in dem die Datenbank ihre Auditinginformationen ablegt. Der \parameter{audit\_file\_dest}-Parameter ist dynamisch und kann mit Hilfe des Kommando \languageorasql{ALTER SYSTEM} wie folgt ge\"andert werden:
          \begin{lstlisting}[caption={Der Parameter \parameter{audit\_file\_dest}},label=admin801,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET audit_file_dest='/u01/app/oracle' DEFERRED;
          \end{lstlisting}
          \begin{literaturinternet}
            \item \cite{i2282157}
          \end{literaturinternet}

          Der Standardwert f\"ur den Parameter \parameter{audit\_file\_dest} ist:
          \begin{itemize}
            \item Windows: \oscommand{\%ORACLE\_BASE\%\textbackslash admin\textbackslash \%ORACLE\_SID\%\textbackslash adump}
            \item Linux/Unix: \oscommand{\$ORACLE\_BASE/admin/\$ORACLE\_SID/adump}
          \end{itemize}

      \begin{literaturinternet}
        \item \cite{085271}
      \end{literaturinternet}
      \subsection{Standardauditing}
        Unabh\"angig davon, ob das Datenbankauditing aktiviert wurde oder nicht, f\"uhrt Oracle standardm\"a\ss{}ig ein Auditing f\"ur bestimmte Aktivit\"aten durch und schreibt die Informationen in den Auditingtrail des Betriebssystems. Dies wird als \enquote{Standardauditing} bezeichnet. Es handelt sich dabei um die folgenden Aktivit\"aten:
        \begin{itemize}
          \item Verbindungen zur Instanz mit administrativen Privilegien

            Es wird ein Eintrag im Betriebssystemauditingtrail erzeugt, der den Nutzernamen des Betriebssystemnutzers enth\"alt, der sich mit einem der Zus\"atze \languagesqlplus{as sysdba} oder \languagesqlplus{as sysoper} angemeldet hat.
          \item Hochfahren der Instanz

            Es wird ein Eintrag im Betriebssystemauditingtrail erzeugt, der Informationen \"uber den Nutzer enth\"alt, der das Hochfahren der Instanz veranlasst hat.
          \item Herunterfahren der Instanz

            Es wird ein Eintrag im Betriebssystemauditingtrail erzeugt, der Informationen \"uber den Nutzer enth\"alt, der das Herunterfahren der Instanz veranlasst hat.
        \end{itemize}
        \begin{merke}
          Als Auditingtrail wird das System bezeichnet, welches die Auditinginformationen aufnimmt. Dies kann z. B. eine Datenbanktabelle, eine XML-Datei, die Windowsereignisanzeige oder der Linux SysLog Daemon sein.
        \end{merke}
      \subsection{Statementauditing aktivieren}
        \label{statementauditing}
        Um Statementauditing zu konfigurieren, muss das \languageorasql{AUDIT}-Kommando zusammen mit einem Bezeichner aufgerufen werden, der vorgibt, welche Art von Statements zu auditieren sind.
        \begin{merke}
          Zum \"Uberwachen von Systemprivilegien wird das Privileg \privileg{audit system} ben\"otigt. F\"ur Objektauditing wird das Privileg \privileg{audit any} ben\"otigt.
        \end{merke}
        Ein einfaches Beispiel f\"ur Statementauditing ist:
        \begin{lstlisting}[caption={Statementauditing aktivieren},label=admin802,language=oracle_sql]
SQL> AUDIT TABLE;
        \end{lstlisting}
        Dieses Kommando sorgt daf\"ur, dass alle \languageorasql{CREATE TABLE}-, \languageorasql{DROP TABLE}- und \languageorasql{TRUNCATE TABLE}-State\-ments auditiert werden.

        \begin{literaturinternet}
          \item \cite{i2059073}
        \end{literaturinternet}

        Mit Hilfe der \languageorasql{AUDITING BY}-Klausel kann das Auditing nach Nutzern eingeschr\"ankt werden. Um beispielsweise alle \languageorasql{ALTER TABLE}-Statements des Nutzers \identifier{bank} zu auditieren wird das \languageorasql{AUDIT}-Statement wie folgt abgewandelt:
        \begin{lstlisting}[caption={Statementauditing auf Nutzer einschr\"anken},label=admin803,language=oracle_sql]
SQL> AUDIT ALTER TABLE 
  2  BY bank;
        \end{lstlisting}
        Um nur erfolgreiche \languageorasql{ALTER TABLE}-Statements des Nutzers \identifier{bank} zu \"uberwachen, wird zus\"atzlich die Option \languageorasql{WHENEVER SUCCESSFUL} verwendet.
        \begin{lstlisting}[caption={Nur erfolgreiche Statements auditieren},label=admin804,language=oracle_sql]
SQL> AUDIT ALTER TABLE 
  2  BY bank
  3  WHENEVER SUCCESSFUL;
        \end{lstlisting}
        \begin{merke}
          Das Gegenst\"uck zur Option \languageorasql{WHENEVER SUCCESSFUL} ist die Option \languageorasql{WHENEVER NOT SUCCESSFUL} (Standardwert).
        \end{merke}
        Es ist m\"oglich Auditingrichtlinien f\"ur mehrere Nutzer und mehrere
        Ereignisse zu kombinieren. In einem solchen Fall, wird dann eine Liste
        mit Benutzernamen in der \languageorasql{BY}-Klausel angegeben.
        \begin{lstlisting}[caption={Statementauditingoptionen
        kombinieren},label=admin805,language=oracle_sql]  
SQL> AUDIT TABLE, ALTER TABLE 
  2  BY bank, hr 
  3  WHENEVER SUCCESSFUL;
        \end{lstlisting}
        \begin{merke}
          Eine neue Session bezieht ihre Auditingeinstellungen aus dem Data Dictionary. Diese Einstellungen bleiben w\"ahrend der gesamten Lebensdauer der Session erhalten. \"Anderungen an den Auditingeinstellungen werden f\"ur eine Session erst nach einem Neustart wirksam.
        \end{merke}
        Um eine \"Ubersicht dar\"uber zu erhalten, welche
        Statementauditingoptionen derzeit aktiviert sind, kann die View
        \identifier{dba\_stmt\_audit\_opts} abgefragt werden.
\clearpage
        \begin{lstlisting}[caption={Aktvierte Statementauditingoptionen}, label=admin806,language=oracle_sql]
SQL> SELECT user_name, audit_option, success, failure
  2  FROM   dba_stmt_audit_opts;

USER_NAME       AUDIT_OPTION                   SUCCESS    &FAILURE&
--------------- ------------------------------ ---------- ----------
                 &TABLE&                           &BY ACCESS&   &BY ACCESS&
BANK             &ALTER TABLE&                      &BY ACCESS&   &BY ACCESS&
HR               &ALTER TABLE&                      &BY ACCESS&   &NOT SET&
BANK             &TABLE&                           &BY ACCESS&   &NOT SET&
HR               &TABLE&                           &BY ACCESS&   &NOT SET&
        \end{lstlisting}
         \beispiel{admin806} zeigt, dass die Auditingstatements aus den
         Beispielen \beispiel{admin802}, \beispiel{admin803},
         \beispiel{admin804} und \beispiel{admin805} kumuliert werden. F\"ur die
         Eintr\"age drei, vier und f\"unf wurde jeweils die Klausel
         \languageorasql{WHENEVER SUCCESSFUL} angegeben, was am Wert
         \enquote{NOT SET} in der Spalte \identifier{failure} erkennbar ist.
      \subsection{Privilegeauditing aktivieren}
           Das Auditieren von Systemprivilegien funktioniert auf die gleiche Art
           und Weise wie das aktivierern von Statementauditing. Einziger
           Unterschied ist, dass dem \languageorasql{AUDIT}-Statement ein oder
           mehrere Systemprivilegien zur \"Uberwachung \"ubergeben werden
           m\"ussen.
          \begin{lstlisting}[caption={Ein einfaches Privilegienauditing konfigurieren},label=admin807,language=oracle_sql]
SQL> AUDIT &connect&;
          \end{lstlisting}
          Wie beim Statementauditing kann auch hier nach Nutzerkonten eingeschr\"ankt werden.
          \begin{lstlisting}[caption={Privilegienauditing nach Nutzern einschr\"anken},label=admin808,language=oracle_sql]
SQL> AUDIT &connect& 
  2  BY bank;
          \end{lstlisting}
          Die Angabe der Klauseln \languageorasql{WHENEVER SUCCESSFUL} und \languageorasql{WHENEVER NOT SUCCESSFUL} ist ebenfalls m\"oglich.
          \begin{lstlisting}[caption={Nur erfolglose Anmeldungen \"uberwachen},label=admin809,language=oracle_sql]
SQL> AUDIT &connect&
  2  BY bank
  3  WHENEVER NOT SUCCESSFUL;
          \end{lstlisting}
          Die View \identifier{dba\_priv\_audit\_opts} dient dazu, die gesetzten
          Privilegeauditingoptionen auszuwerten.
\clearpage
        \begin{lstlisting}[caption={Aktvierte Statementauditingoptionen}, label=admin810,language=oracle_sql]
SQL> SELECT user_name, privilege, success, failure
  2  FROM   dba_priv_audit_opts;

USER_NAME       PRIVILEGE                                SUCCESS    &FAILURE&
--------------- ---------------------------------------- ---------- ----------
BANK             &CREATE SESSION&                             &NOT SET&     &BY ACCESS&
                 &CREATE SESSION&                             &BY ACCESS&   &BY ACCESS&
        \end{lstlisting}
      \subsection{Objectauditing aktivieren}
        Das Objectauditing ist dem Privilegeauditing sehr \"ahnlich. Statt Systemprivilegien werden Objektprivilegien verwendet und es m\"ussen eines oder mehrere Objekte angegeben werden, auf die sich das Auditing bezieht.
        \begin{lstlisting}[caption={Ein einfaches Objectauditing konfigurieren},label=admin811,language=oracle_sql]
SQL> AUDIT SELECT, INSERT, UPDATE, DELETE ON bank.mitarbeiter
  2  BY ACCESS
  3  WHENEVER NOT SUCCESSFUL;
        \end{lstlisting}
        Ein weiterer Unterschied zum Statement- oder Privilegeauditing ist, dass
        beim Objectauditing keine \languageorasql{AUDITING BY}-Klausel verwendet
        werden kann, was bedeutet, dass nicht nach Nutzern eingeschr\"ankt
        werden kann. Neu beim Objectauditing ist, dass mit Hilfe der Angaben
        \languageorasql{BY SESSION} und \languageorasql{BY ACCESS} gesteuert
        werden kann, ob:
        \begin{itemize}
          \item \textbf{BY ACCESS}: Es wird bei jedem Auftreten eines Ereignisses ein Eintrag im Audittrail erzeugt.
          \item \textbf{BY SESSION}: Nur beim ersten Auftreten eines Ereignisses ein Eintrag im Audittrail erzeugt wird.
        \end{itemize}
        \begin{lstlisting}[caption={Nur eine Warnung pro Session f\"ur ein Ereignis},label=admin812,language=oracle_sql]
SQL> AUDIT select ON bank.Buchung
  2  BY SESSION
  3  WHENEVER SUCCESSFUL;
        \end{lstlisting}
        Auch f\"ur diese Art des Auditings existiert eine View, die eine Auswertung der Auditingoptionen erlaubt, \identifier{dba\_obj\_audit\_opts}. Sie gestaltet sich jedoch g\"anzlich anders, als \identifier{dba\_stmt\_audit\_opts} oder \identifier{dba\_priv\_audit\_opts}.

        In der View \identifier{dba\_obj\_audit\_opts} existiert f\"ur jedes Objektprivileg eine eigene Spalte. Die Spaltenbezeichnungen sind Abk\"urzungen der betroffenen Privilegien. Beispielsweise beinhaltet die Spalte \identifier{alt} die Objectauditingoptions f\"ur das Objektprivileg \privileg{alter} oder die Spalte \identifier{sel} die Optionen f\"ur das \privileg{select}-Privileg.
        \begin{lstlisting}[caption={Die View \identifier{dba\_obj\_audit\_opts}},label=admin813,language=oracle_sql]
 Name                                      Null?    Type
 ----------------------------------------- -------- --------------------
 &OWNER&                                               &VARCHAR2&(30)
 OBJECT_NAME                                        &VARCHAR2&(30)
 OBJECT_TYPE                                        &VARCHAR2&(23)
 ALT                                                &VARCHAR2&(3)
 AUD                                                &VARCHAR2&(3)
 COM                                                &VARCHAR2&(3)
 DEL                                                &VARCHAR2&(3)
 GRA                                                &VARCHAR2&(3)
 IND                                                &VARCHAR2&(3)
 INS                                                &VARCHAR2&(3)
 LOC                                                &VARCHAR2&(3)
 REN                                                &VARCHAR2&(3)
 SEL                                                &VARCHAR2&(3)
 UPD                                                &VARCHAR2&(3)
 REF                                                &CHAR&(3)
 EXE                                                &VARCHAR2&(3)
 CRE                                                &VARCHAR2&(3)
 REA                                                &VARCHAR2&(3)
 WRI                                                &VARCHAR2&(3)
 FBK                                                &VARCHAR2&(3)

        \end{lstlisting}
        Um die Auditingoptionen f\"ur die Objektprivilegien \privileg{select}, \privileg{insert}, \privileg{update} und \privileg{delete} abzufragen zu k\"onnen, m\"ussen die Spalten \identifier{sel}, \identifier{ins}, \identifier{upd} und \identifier{del} in die Abfrage einbezogen werden.
        \begin{lstlisting}[caption={Objectauditingoptions abfragen},label=admin814,language=oracle_sql,alsolanguage=sqlplus]
SQL> SELECT sel, ins, upd, del
  2  FROM   dba_obj_audit_opts;

SEL INS UPD DEL
--- --- --- ---
S/S A/- -/S A/A
        \end{lstlisting}
        Diese Angaben sind wie folgt zu interpretieren:

        Der linke Buchstabe, steht f\"ur die \"Uberwachung erfolgreich verlaufener Ereignisse (Klausel \languageorasql{WHENEVER SUCCESSFUL}). Hier gibt es drei M\"oglichkeiten:
        \begin{itemize}
          \item \textbf{S}: Es ist eine \"Uberwachung erfolgreicher Ereignisse im Modus \languageorasql{BY SESSION} konfiguriert.
          \item \textbf{A}: Es ist eine \"Uberwachung erfolgreicher Ereignisse im Modus \languageorasql{BY ACCESS} konfiguriert.
          \item \textbf{-}: Es wurde keine \"Uberwachung erfolgreicher Ereignisse konfiguriert.
        \end{itemize}
        Der rechte Buchstabe, steht f\"ur eine \"Uberwachung erfolglos verlaufener Ereignisse(Klausel \languageorasql{WHENEVER NOT SUCCESSFUL}). Hier gibt es widerum drei M\"oglichkeiten:
        \begin{itemize}
          \item \textbf{S}: Es ist eine \"Uberwachung erfolgloser Ereignisse im Modus \languageorasql{BY SESSION} konfiguriert.
          \item \textbf{A}: Es ist eine \"Uberwachung erfolgloser Ereignisse im Modus \languageorasql{BY ACCESS} konfiguriert.
          \item \textbf{-}: Es wurde keine \"Uberwachung erfolgloser Ereignisse konfiguriert.
        \end{itemize}
        Das Ergebnis aus \beispiel{admin814} zeigt vier verschiedene Varianten:
        \begin{itemize}
          \item \texttt{sel (S/S)}: F\"ur die Nutzung des \privileg{select}-Privilegs sollen sowohl erfolgreiche, als auch erfolglose Ereignisse, im Modus \languageorasql{BY SESSION} \"uberwacht werden.
          \item \texttt{ins (A/-)}: F\"ur die Nutzung des \privileg{insert}-Privilegs werden nur erfolgreiche Ereignisse, im Modus \languageorasql{BY ACCESS} \"uberwacht. Es erfolgt keine \"Uberwachung erfolgloser Ereignisse.
          \item \texttt{upd (-/S)}: F\"ur das \privileg{update}-Privileg werden nur erfolglose Ereignisse, im Modus \languageorasql{BY SESSION}, \"uberwacht. Es erfolgt keine \"Uberwachung erfolgreicher Ereignisse.
          \item \texttt{del (A/A)}: F\"ur die Nutzung des \privileg{delete}-Privilegs sollen sowohl erfolgreiche, als auch erfolglose Ereignisse, im Modus \languageorasql{BY ACCESS} \"uberwacht werden.
        \end{itemize}
      \subsection{Audittrails auswerten}
        Genauso wichtig oder sogar noch wichtiger als die Auditingoptionen sind die Auditingergebnisse, die in den Audittrails stehen. Wie f\"ur viele andere Dinge, stellt auch hier Oracle entsprechende Views zur Verf\"ugung. Die beiden wichtigsten sind \identifier{dba\_audit\_trail} und \identifier{dba\_common\_audit\_trail}.

        \identifier{dba\_audit\_trail} zeigt den Inhalt des Datenbank\-audittrails f\"ur alle Auditingarten an. Um nach den unterschiedlichen Auditingarten zu untergliedern gibt es noch die folgenden Views:
        \begin{itemize}
          \item \identifier{dba\_audit\_statement}: Enth\"alt alle Statementauditing-Eintr\"age im Datenbank\-audit\-trail.
          \item \identifier{dba\_audit\_object}: Enth\"alt alle Objectauditing-Eintr\"age im Datenbank\-audit\-trail.
          \item \identifier{dba\_audit\_session}: Enth\"alt alle connect und disconnect Eintr\"age im Datenbank\-audit\-trail.
        \end{itemize}
\clearpage
        \begin{merke}
          Statt \identifier{dba\_audit\_trail} direkt abzufragen, sollten die spezialisierten Views genutzt werden, da diese die Informationen des Datenbankauditingtrails \"ubersichtlicher darstellen.
        \end{merke}
        \begin{lstlisting}[caption={Den Datenbankauditingtrail nach connects auswerten},label=admin815,language=oracle_sql,alsolanguage=sqlplus]
SQL> col userhost format a30
SQL> SELECT   username, userhost,
              TO_CHAR(timestamp, 'DD.MM.YYYY HH24:MI') AS Time
  2  FROM     dba_audit_session
  3  ORDER BY timestamp;

USERNAME        USERHOST                       &TIME&
--------------- ------------------------------ ----------------
ALICE           FEA11-119WS03.oracle.com       11.09.2013 12:09
CHLOE           FEA11-119WS03.oracle.com       11.09.2013 12:12
BANK            FEA11-119WS03.oracle.com       18.09.2013 10:59
&SYSTEM&           FEA11-119WS03.oracle.com       18.09.2013 11:35
&SYSTEM&           FEA11-119WS03.oracle.com       18.09.2013 11:44
&SYSTEM&           FEA11-119WS03.oracle.com       18.09.2013 11:55
&SYSTEM&           FEA11-119WS03.oracle.com       18.09.2013 12:00
BANK            FEA11-119CL.oracle.com         14.10.2013 10:47
BANK            FEA11-119CL.oracle.com         14.10.2013 10:49
BANK            FEA11-119CL.oracle.com         14.10.2013 10:57
        \end{lstlisting}
        \beispiel{admin815} zeigt eine Auswertung des Audittrails bez\"uglich connect-Ereignissen.

        Der Betriebssystemaudittrail, der XML-Audittrail und das Fine Grained
        Auditing werden nur in der View \identifier{dba\_common\_audit\_trail}
        angezeigt, was bedeutet, dass die drei oben genannten Views
        \identifier{dba\_audit\_statement}, \identifier{dba\_audit\_object} und
        auch  \identifier{dba\_audit\_session} nicht funktionieren. Um die
        gleiche Auswertung zu erreichen, wie in \beispiel{admin814}, m\"usste
        dann die Spalte \identifier{action} der View
        \identifier{dba\_common\_audit\_trail} genutzt werden, um nach connect
        und disconnect Ereignissen zu filtern.
        \begin{lstlisting}[caption={Einen externen Audittrail auswerten},label=admin816,language=oracle_sql,alsolanguage=sqlplus]
SQL> col db_user format a10
SQL> col userhost format a29
SQL> col action format 999999
SQL> col extended_timestamp format a31
SQL> SELECT   db_user, userhost, action, extended_timestamp
  2  FROM     dba_common_audit_trail
  3  WHERE    action IN (100,101)
  4  ORDER BY extended_timestamp;
        \end{lstlisting}
\clearpage
        \begin{lstlisting}[caption={Einen externen Audittrail auswerten - Fortsetzung},language=oracle_sql,alsolanguage=sqlplus]
DB_USER    USERHOST                      ACTION EXTENDED_TIMESTAMP
---------- ----------------------------- ------ -------------------------------
BANK       FEA11-119CL.oracle.com           101 14.10.13 10:57:52,477400 +02:00
BANK       FEA11-119CL.oracle.com           100 14.10.13 11:03:32,648556 +02:00
BANK       FEA11-119SRV.oracle.com          100 16.10.13 10:54:51,029779 +02:00
BANK       FEA11-119SRV.oracle.com          101 16.10.13 10:54:53,737176 +02:00
BANK       FEA11-119SRV.oracle.com          100 16.10.13 10:54:54,059818 +02:00
BANK       FEA11-119SRV.oracle.com          100 16.10.13 10:54:57,221702 +02:00
BANK       FEA11-119SRV.oracle.com          100 16.10.13 10:54:59,997771 +02:00
BANK       FEA11-119SRV.oracle.com          101 16.10.13 10:55:02,779921 +02:00
        \end{lstlisting}
        Die Werte 100 und 101 der Spalte \identifier{action} stehen f\"ur
        connect (100) und disconnect (101). Sollte es so sein, dass der
        OS-Audittrail oder der XML-Audittrail genutzt werden, empfiehlt es sich
        f\"ur den Administrator, die drei Views
        \identifier{dba\_audit\_statement}, \identifier{dba\_audit\_object} und
        \identifier{dba\_audit\_session} nach zu bauen. Als Beispiel wird hier
        die View \identifier{common\_audit\_session} gezeigt, die alle connect
        und disconnect Ereignisse, auf Basis der View
        \identifier{dba\_common\_audit\_trail}   anzeigt.
        \begin{lstlisting}[caption={Eine eigene View f\"ur dba\_common\_audit\_trail},label=admin817,language=oracle_sql]
SQL> CREATE OR REPLACE VIEW common_audit_session
(DB_USER, USERHOST, ACTION, EXTENDED_TIMESTAMP, EXTENDED_ACTION)
  2  AS
  3    SELECT   db_user, userhost, action, extended_timestamp,
  4             DECODE(action, 100, 'CONNECT',
  5                            101, 'DISCONNECT',
  6                              0, 'CONNECT AS SYSDBA')
  7    FROM     dba_common_audit_trail
  8    WHERE    action IN (0, 100, 101)
  9    ORDER BY extended_timestamp;

View created.
        \end{lstlisting}
      \subsection{Auditing deaktivieren}
        Das Kommando \languageorasql{NOAUDIT} deaktiviert eine konfigurierte Auditingeinstellung wieder. Es k\"on\-nen damit alle Auditingarten deaktiviert werden.

        \begin{merke}
          Das Kommando \languageorasql{NOAUDIT} kennt die beiden Optionen \languageorasql{BY ACCESS} und \languageorasql{BY SESSION} nicht. Deshalb k\"onnen diese nicht verwendet werden.
        \end{merke}
        Im Folgenden werden einige Beispiele f\"ur das \languageorasql{NOAUDIT}-Kommando gezeigt.
\clearpage
        \begin{lstlisting}[caption={Statement- und Privilegeauditing deaktivieren},label=admin818,language=oracle_sql]
SQL> NOAUDIT TABLE;
SQL> NOAUDIT ALTER TABLE BY bank;
SQL> NOAUDIT ALTER TABLE BY bank WHENEVER SUCCESSFUL;
SQL> NOAUDIT connect;
        \end{lstlisting}
        \begin{lstlisting}[caption={Alle AUDIT ALL-Statements
        deaktivieren},label=admin819,language=oracle_sql]
SQL> NOAUDIT ALL;
SQL> NOAUDIT ALL BY bank;
SQL> NOAUDIT ALL BY bank WHENEVER SUCCESSFUL;
        \end{lstlisting}
        \begin{merke}
          Um alle Privilegeauditings zu deaktivieren gibt es das Schl\"usselwort \languageorasql{ALL PRIVILEGES}.
        \end{merke}
        \begin{lstlisting}[caption={Alle Privilegeauditings deaktivieren},label=admin820,language=oracle_sql]
SQL> NOAUDIT ALL PRIVILEGES;
SQL> NOAUDIT ALL PRIVILEGES BY bank;
SQL> NOAUDIT ALL PRIVILEGES BY bank
  2  WHENEVER SUCCESSFUL;
        \end{lstlisting}
        Auch beim Objectauditing gibt es die M\"oglichkeit, alle Auditings direkt zu deaktivieren. Dies geschieht mit dem Statement \languageorasql{NOAUDIT ALL ON DEFAULT}.
        \begin{lstlisting}[caption={Objectauditing deaktivieren},label=admin821,language=oracle_sql]
SQL> NOAUDIT DELETE ON bank.mitarbeiter;
SQL> NOAUDIT SELECT, UPDATE, INSERT ON bank.mitarbeiter;
SQL> NOAUDIT SELECT ON bank.mitarbeiter
  2  WHENEVER SUCCESSFUL;

SQL> NOAUDIT ALL ON bank.mitarbeiter;
SQL> NOAUDIT ALL ON DEFAULT;
        \end{lstlisting}
    \section{Die Nutzerauthentifizierung sicherer gestalten}
      \subsection{Sichere Authentifizierung}
        \subsubsection{Brute Force Protection}
          Mit Oracle 11g kommt ein altes/neues Feature, welches als Schutz vor
          Brute Force Attacken fungiert. Oracle verz\"ogert bei fehlerhaften
          Anmeldeversuchen den n\"achsten Anmeldevorgang. Es gilt:
\clearpage
          \begin{itemize}
            \item W\"ahrend der ersten drei Anmeldeversuche existiert noch keine Verz\"ogerung
            \item Ab dem vierten Versuch wird eine stetig ansteigende Verz\"ogerung (max. 10 Sekunden) eingebaut.
          \end{itemize}
          Ein einfacher Test mit einem Java-Programm zeigt die Auswirkungen dieses neuen Features.
          \begin{lstlisting}[caption={Logon Delay Test},language=terminal]
[oracle@FEA11-119CL ~]$ /usr/java/jdk1.7.0_45/bin/java AuthDelayTest
Connecting with URL=jdbc:oracle:oci8:@ORCL as bank/wrong_password
Versuch: 0
Delay: 0 Sek.
Versuch: 1
Delay: 0 Sek.
Versuch: 2
Delay: 0 Sek.
Versuch: 3
Delay: 1 Sek.
Versuch: 4
Delay: 2 Sek.
Versuch: 5
Delay: 3 Sek.
Versuch: 6
Delay: 4 Sek.
Versuch: 7
Delay: 5 Sek.
Versuch: 8
Delay: 6 Sek.
Versuch: 9
Delay: 7 Sek.
Versuch: 10
Delay: 0 Sek.
Versuch: 11
Delay: 0 Sek.
Versuch: 12
Delay: 0 Sek.
Versuch: 13
Delay: 0 Sek.
          \end{lstlisting}
          Das das Delay ab Versuch Nummer 10 wieder auf 0 zur\"uckgeht, h\"angt
         damit zusammen, dass der Account dann gesperrt ist.
\clearpage
        \subsubsection{max\_failed\_login\_attempts}
          Mit dem Profilparameter \languageorasql{MAX\_FAILED\_LOGIN\_ATTEMPTS}
          ist es m\"oglich, f\"ur valide Nutzerkonten eine maximale Anzahl
          fehlerhafter Anmeldeversuche festzulegen. Ein Konto wird gesperrt,
          sobald das Passwort zu oft falsch eingegeben wurde. Dieser Mechanismus
          sch\"utzt vor Brute Force Attacken, nicht aber vor dem Aussp\"ahen von
          Nutzernamen.

          Mit dem neuen \parameter{sec\_max\_failed\_login\_attempts}-Parameter
          kann die maximale Anzahl fehlerhafter Anmeldeversuche f\"ur einen
          Client konfiguriert werden. Sendet der Client zu h\"aufig eine falsche
          Kombination aus Nutzername und Passwort, wird seine Netzwerkverbindung
          zur Datenbank getrennt. Dieser Initialisierungsparameter bezieht sich
          auch auf Anmeldeversuche mit nicht existenten Nutzerkonten, im
          Unterschied zum Profilparameter
          \languageorasql{MAX\_FAILED\_LOGIN\_ATTEMPTS}, der nur f\"ur existente
          Konten gilt.
          
          Wenn beispielsweise ein Hacker einen Serverprozess startet um mittels
          Brute Force unterschiedliche Kombinationen aus Nutzername und Passwort
          zu testen, kann mittels dieses neuen Initialisierungsparameters
          seine Verbindung zum Serverprozess nach n Versuchen getrennt werden. Ohne diesen
          Parameter k\"onnte der Hacker tausende von Versuchen
          starten, ohne dabei unterbrochen zu werden.
          \begin{lstlisting}[caption={Der Parameter \parameter{sec\_max\_failed\_login\_attempts}},label=admin825,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET sec_max_failed_login_attempts = 3
  3  SCOPE=spfile;
        \end{lstlisting}
          Wird der Parameter wie in \beispiel{admin825} konfiguriert, bedeutet dies f\"ur alle Clients, dass nach drei falschen Anmeldeversuchen die Connection zum Datenbankserver getrennt wird.

          Dieser Parameter ist statisch!
      \subsection{Sichere Passw\"orter}
        Bis zur Einf\"uhrung von Oracle 11g waren alle Nutzerpassw\"orter,
        inklusive der Administratorenpassw\"orter case insensitiv,
        \enquote{HalloWelt} war gleich \enquote{hallowelt}. Durch den neuen
        Initialisierungsparameter \parameter{sec\_case\_sensitive\_logon} ist es
        nun m\"oglich, Passw\"orter case sensitiv in der Datenbank zu speichern.
        Der Kern dieses neuen Verfahrens ist der SHA1 Hashing Algorithmus.
        Dieser ist im Gegensatz zum 3DES-Algorithmus in der Lage die
        Passw\"orter case sensitiv zum hashen. Zus\"atzlich dazu bringt der
        SHA1-Algorithmus ein Salt mit sich, der die Passwort-Hashes noch
        sicherer macht.
\clearpage
        \begin{lstlisting}[caption={\parameter{sec\_case\_sensitive\_logon}},label=admin826,language=sqlplus]
SQL> show parameter sec_case_sensitive_logon

NAME                              &TYPE&         VALUE
--------------------------------- ------------ ----------------
sec_case_sensitive_logon          boolean      &TRUE&
        \end{lstlisting}
        Eine Stolperfalle, die es zu beachten gilt ist, dass die case-sensitivit\"at von Administratorenpassw\"ortern nicht nur von \parameter{sec\_case\_sensitive\_logon} abh\"angig ist, sondern zus\"atzlich auch davon, wie die Passwortdatei erstellt wurde. Wird die Passwortdatei mit dem Parameter \texttt{ignorecase=y} erstellt, bleibt \parameter{sec\_case\_sensitive\_logon} f\"ur die Administratoren wirkungslos. Nur wenn \texttt{ignorecase=n} ist, haben auch Admins case-sensitive Passw\"orter.
        \begin{merke}
          In Oracle 12c ist gilt dieser Parameter als Deprecated (veraltet), da Passw\"orter in der Version 12c nur noch case sensitiv gespeichert werden.
        \end{merke}
    \section{Verschl\"usselte Tablespaces}
      Seit Oracle 11g ist es m\"oglich, statt der gesamten Datenbank, nur
      einzelne Tablespaces zu verschl\"usseln. Dies hat den Vorteil, dass der
      Administrator gezielt, sensitive Daten verschl\"usseln kann. Der von
      Oracle genutzte Verschl\"usselungsmechanismus wird als Transparent Data
      Encryption (TDE) bezeichnet. Das Schl\"usselwort \enquote{Transparent}
      bedeutet, dass alle Anwendungen, ohne Ver\"anderung, die verschl\"usselten
      Daten nutzen k\"onnen, als seien sie unverschl\"usselt. Die Daten werden
      sogar automatisch verschl\"usselt im Undo Tablespace und in den Redo Logs
      abgelegt, so dass auch dort Datendiebstahl nicht ohne weiteres erfolgen
      kann.

      Oracle benutzt zur Verschl\"usselung Industriestandards, wie AES256,
      AES192, AES128 und 3DES168. Welcher Standard genutzt werden soll, muss bei
      der Erstellung des Tablespaces angegeben werden. Unterschiedliche
      Tablespaces k\"onnen unterschiedliche Verschl\"usselungsverfahren nutzen.
      \begin{merke}
        Das Standardverfahren innerhalb der Oracle-Datenbank ist AES128.
      \end{merke}
      Grundlage f\"ur die Kryptierung ist ein Wallet.
      \subsection{Vorbereiten der Tablespaceverschl\"usselung}
        \subsubsection{Wallets}
          Ein Wallet\footnote{engl. Brieftasche} ist ein verschl\"uselter
          Speicher f\"ur Zertifikate und Schl\"ussel. Es kann f\"ur
          unterschiedliche Zwecke eingesetzt werden, wie z. B. Authentifizierung
          oder Verschl\"usselung. Wird das Wallet zur Verschl\"usselung benutzt,
          spricht man von einem \enquote{Encryptionwallet}.
        \subsubsection{Erstellen eines Walletspeicherortes}
          Um ein Wallet f\"ur die Verschl\"usselung eines Tablespaces nutzen zu
          k\"onnen, m\"uss vorher ein \enquote{Walletspeicher} definiert werden.
          Hierbei handelt es sich um ein Verzeichnis, welches der Datenbank
          bekannt gemacht werden muss. Dazu muss der Walletspeicher in der Datei
          \oscommand{sqlnet.ora} eingetragen werden.
          \begin{lstlisting}[caption={Ein Encryptionwallet
          registrieren},label=admin837,language=configfile]
ENCRYPTION_WALLET_LOCATION =
  (SOURCE =
    (METHOD = FILE)
    (METHOD_DATA =
      (DIRECTORY = /u01/app/oracle/wallets/))
  )
          \end{lstlisting}
          Der \oscommand{sqlnet.ora}-Parameter \languageconfigfile{ENCRYPTION_WALLET_LOCATION} gibt an, wo das Wallet gespeichert werden soll. \languageconfigfile{METHOD = FILE} weisst darauf hin, dass das Wallet als Datei auf dem Dateisystem abgelegt wird. \languageconfigfile{DIRECTORY} gibt den eigentlichen Speicherort an.
        \subsubsection{Erstellen des Encryptionwallets}
          Das Encryptionwallet wird direkt mit SQL erzeugt.
          \begin{lstlisting}[caption={Ein Encryptionwallet erzeugen},label=admin838,language=oracle_sql]
SQL> ALTER SYSTEM SET ENCRYPTION KEY
  2  IDENTIFIED BY "P@ssw0rd";
          \end{lstlisting}
      \subsection{Einen verschl\"usselten Tablespace erstellen}
        \subsubsection{\"Offnen des Wallets}
          Um ein Encryptionwallet nutzen zu k\"onnen, muss es zuerst ge\"offnet werden.
          \begin{lstlisting}[caption={Ein Encryptionwallet \"offnen},label=admin839,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET ENCRYPTION WALLET OPEN
  3  IDENTIFIED BY "P@ssw0rd";
          \end{lstlisting}
          Nach dem \"Offnen des Wallets kann der Tablespace kreiert werden.
        \subsubsection{Erstellen des Tablespaces}
          Die Erstellung des verschl\"usselten Tablespaces erfolgt mit Hilfe des SQL-Kommandos \languageorasql{CREATE TABLESPACE}.
          \begin{lstlisting}[caption={Einen kryptierten Tablespace mit AES128-Verschl\"usselung erstellen},label=admin840,language=oracle_sql]
SQL> CREATE TABLESPACE crypto_ts
  2  DATAFILE '/u02/oradata/orcl/crypto_ts01.dbf' SIZE 50M
  3  ENCRYPTION
  4  DEFAULT STORAGE(ENCRYPT);

Tablespace created.
          \end{lstlisting}
          Die Zeilen 3 und 4 \languageorasql{ENCRYPTION} und \languageorasql{DEFAULT STORAGE(ENCRYPT)} sorgen f\"ur die Verschl\"usselung. Die \languageorasql{ENCRYPTION}-Klausel kann variiert werden, um einen anderen Verschl\"usselungsalgorithmus zu verwenden.
          \begin{lstlisting}[caption={Einen kryptierten Tablespace mit alternativer Verschl\"usselungsmethode erzeugen},label=admin841,language=oracle_sql]
SQL> CREATE TABLESPACE crypto_ts_aes256
  2  DATAFILE '/u02/oradata/orcl/crypto_ts_aes25601.dbf' SIZE 50M
  3  ENCRYPTION USING 'AES256'
  4  DEFAULT STORAGE(ENCRYPT);

Tablespace created.
          \end{lstlisting}
          So wohl das Erstellen, als auch der Zugriff auf kryptierte Tablespaces funktioniert nur, wenn das Encryptionwallet ge\"offnet wurde.
          \begin{lstlisting}[caption={Einen kryptierten Tablespace mit AES128-Verschl\"usselung erstellen},label=admin842,language=oracle_sql]
SQL> CREATE TABLESPACE crypto_ts_false
  2  DATAFILE '/u02/oradata/orcl/crypto_ts_false01.dbf' SIZE 50M
  3  ENCRYPTION
  4  DEFAULT STORAGE(ENCRYPT);

&\textcolor{red}{ORA-28365: wallet is not open}&
          \end{lstlisting}
          Oracle quittiert den Zugriff ohne ge\"offnetes Wallet mit dem Fehler ORA-28365.
        \subsubsection{Schlie\ss{}en des Wallets}
          Sollte das Wallet f\"ur keinen weiteren Vorgang gebraucht werden, ist es ratsam, das Wallet wieder zu schlie\ss{}en.
          \begin{lstlisting}[caption={Das Encryptionwallet schlie\ss{}en},label=admin843,language=oracle_sql]
SQL> ALTER SYSTEM
  2  SET ENCRYPTION WALLET CLOSE
  3  IDENTIFIED BY "P@ssw0rd";
          \end{lstlisting}
      \subsection{Umgang mit verschl\"usselten Tablespaces}
        \subsubsection{Informationen sammeln}
          Informationen \"uber die Verschl\"usselung und den benutzten
          Algorithmus liefert die View \identifier{v\$encrypted\_tablespaces}.
          \begin{lstlisting}[caption={},label=admin844,language=oracle_sql]
SQL> SELECT t.ts#, t.name, e.encryptionalg, e.encryptedts
  2  FROM   v$tablespace t INNER JOIN v$encrypted_tablespaces e
  3           ON (t.ts# = e.ts#);

       TS# NAME                           ENCRYPT ENC
---------- ------------------------------ ------- ---
        16 CRYPTO_TS                      AES128  YES
        17 CRYPTO_TS_AES256               AES256  YES
          \end{lstlisting}
        \subsubsection{Einschr\"ankungen}
          Im Umgang mit kryptierten Tablespaces existieren drei wesentliche Einschr\"ankungen:
          \begin{itemize}
            \item Ein unverschl\"usselter Tablespace kann nicht im Nachhinein verschl\"usselt werden. Dies kann nur \"uber Umwege, mittels der Oracle Data Pump erfolgen.
            \item Verschl\"usselte Tablespaces k\"onnen nicht ohne Weiteres in eine andere Datenbank umgezogen werden.
            \item Beim Wiederherstellen eines kryptierten Tablespaces muss vor der Recovery-Phase das Wallet ge\"offnet werden, da sonst der Oracle Recovery Manager die Datenbl\"ocke nicht verarbeiten kann.
          \end{itemize}

          \begin{literaturinternet}
            \item \cite{ADMIN12327}
          \end{literaturinternet}
    \section{Informationen}
      \subsection{Verzeichnis der relevanten Initialisierungsparameter}
        \begin{literaturinternet}
          \item \cite{REFRN10019}
          \item \cite{REFRN10274}
          \item \cite{REFRN10299}
        \end{literaturinternet}
      \subsection{Verzeichnis der relevanten Data Dictionary Views}
        \begin{literaturinternet}
          \item \cite{sthref1850}
          \item \cite{sthref1854}
          \item \cite{sthref1856}
          \item \cite{sthref1858}
          \item \cite{sthref2293}
          \item \cite{sthref2337}
          \item \cite{sthref2472}
          \item \cite{sthref2579}
          \item \cite{REFRN30496}
          \item \cite{REFRN30405}
        \end{literaturinternet}
      \subsection{Verzeichnis der Konfigurationsdateien und ihrer Parameter}
        \begin{literaturinternet}
          \item  \cite{NETRF006}
        \end{literaturinternet}
\clearpage
